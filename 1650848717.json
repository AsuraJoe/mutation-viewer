{"config": {"Build Date": "17 Mar 2022", "Commit": "ac98382", "LLVM Version": "12.0.0", "Mull Version": "0.17.1", "URL": "https://github.com/mull-project/mull"}, "files": {"/home/tpugh_/new_programs/flex/source/flex.c": {"language": "cpp", "mutants": [{"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 153}, "start": {"column": 19, "line": 153}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 153}, "start": {"column": 19, "line": 153}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 155}, "start": {"column": 25, "line": 155}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 165}, "start": {"column": 17, "line": 165}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 165}, "start": {"column": 17, "line": 165}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 165}, "start": {"column": 31, "line": 165}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 166}, "start": {"column": 30, "line": 166}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 215}, "start": {"column": 13, "line": 215}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 223}, "start": {"column": 19, "line": 223}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 269}, "start": {"column": 18, "line": 269}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 269}, "start": {"column": 18, "line": 269}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 269}, "start": {"column": 28, "line": 269}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 20, "line": 271}, "start": {"column": 19, "line": 271}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 15, "line": 272}, "start": {"column": 14, "line": 272}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 281}, "start": {"column": 18, "line": 281}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 281}, "start": {"column": 18, "line": 281}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 281}, "start": {"column": 28, "line": 281}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 309}, "start": {"column": 20, "line": 309}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 57, "line": 315}, "start": {"column": 55, "line": 315}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 18, "line": 372}, "start": {"column": 16, "line": 372}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 383}, "start": {"column": 19, "line": 383}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 400}, "start": {"column": 23, "line": 400}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 28, "line": 436}, "start": {"column": 27, "line": 436}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 28, "line": 436}, "start": {"column": 27, "line": 436}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 28, "line": 438}, "start": {"column": 27, "line": 438}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 28, "line": 438}, "start": {"column": 27, "line": 438}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 448}, "start": {"column": 20, "line": 448}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 450}, "start": {"column": 20, "line": 450}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 457}, "start": {"column": 14, "line": 457}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 464}, "start": {"column": 14, "line": 464}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 14, "line": 500}, "start": {"column": 13, "line": 500}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 500}, "start": {"column": 29, "line": 500}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 502}, "start": {"column": 23, "line": 502}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 522}, "start": {"column": 16, "line": 522}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 22, "line": 528}, "start": {"column": 21, "line": 528}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 22, "line": 538}, "start": {"column": 21, "line": 538}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 16, "line": 544}, "start": {"column": 15, "line": 544}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 544}, "start": {"column": 26, "line": 544}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 39, "line": 544}, "start": {"column": 38, "line": 544}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 43, "line": 544}, "start": {"column": 42, "line": 544}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 14, "line": 548}, "start": {"column": 13, "line": 548}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 15, "line": 554}, "start": {"column": 14, "line": 554}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 15, "line": 556}, "start": {"column": 14, "line": 556}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 568}, "start": {"column": 20, "line": 568}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 576}, "start": {"column": 20, "line": 576}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 630}, "start": {"column": 23, "line": 630}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 44, "line": 631}, "start": {"column": 43, "line": 631}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 50, "line": 631}, "start": {"column": 48, "line": 631}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 17, "line": 643}, "start": {"column": 15, "line": 643}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 643}, "start": {"column": 32, "line": 643}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 646}, "start": {"column": 15, "line": 646}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 662}, "start": {"column": 23, "line": 662}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 662}, "start": {"column": 32, "line": 662}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 681}, "start": {"column": 13, "line": 681}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 693}, "start": {"column": 12, "line": 693}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 26, "line": 693}, "start": {"column": 24, "line": 693}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 693}, "start": {"column": 33, "line": 693}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 772}, "start": {"column": 13, "line": 772}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 781}, "start": {"column": 13, "line": 781}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 26, "line": 789}, "start": {"column": 6, "line": 789}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 793}, "start": {"column": 13, "line": 793}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 35, "line": 849}, "start": {"column": 34, "line": 849}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 35, "line": 849}, "start": {"column": 34, "line": 849}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 893}, "start": {"column": 24, "line": 893}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 902}, "start": {"column": 26, "line": 902}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 904}, "start": {"column": 31, "line": 904}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 907}, "start": {"column": 26, "line": 907}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 909}, "start": {"column": 31, "line": 909}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 27, "line": 912}, "start": {"column": 26, "line": 912}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 27, "line": 912}, "start": {"column": 26, "line": 912}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 28, "line": 928}, "start": {"column": 27, "line": 928}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 28, "line": 928}, "start": {"column": 27, "line": 928}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 979}, "start": {"column": 13, "line": 979}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 1245}, "start": {"column": 17, "line": 1245}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 1245}, "start": {"column": 17, "line": 1245}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 27, "line": 1245}, "start": {"column": 24, "line": 1245}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 20, "line": 1246}, "start": {"column": 19, "line": 1246}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 1246}, "start": {"column": 24, "line": 1246}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 16, "line": 1249}, "start": {"column": 15, "line": 1249}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 16, "line": 1251}, "start": {"column": 14, "line": 1251}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 16, "line": 1251}, "start": {"column": 14, "line": 1251}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 1255}, "start": {"column": 3, "line": 1255}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 22, "line": 1261}, "start": {"column": 21, "line": 1261}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 1270}, "start": {"column": 7, "line": 1270}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 19, "line": 1270}, "start": {"column": 17, "line": 1270}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 19, "line": 1270}, "start": {"column": 17, "line": 1270}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 1274}, "start": {"column": 3, "line": 1274}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 1281}, "start": {"column": 15, "line": 1281}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 37, "line": 1291}, "start": {"column": 36, "line": 1291}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 42, "line": 1291}, "start": {"column": 41, "line": 1291}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 59, "line": 1291}, "start": {"column": 58, "line": 1291}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 1324}, "start": {"column": 17, "line": 1324}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 1324}, "start": {"column": 17, "line": 1324}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 1324}, "start": {"column": 26, "line": 1324}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 1334}, "start": {"column": 12, "line": 1334}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 1334}, "start": {"column": 16, "line": 1334}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 1334}, "start": {"column": 16, "line": 1334}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 12, "line": 1337}, "start": {"column": 11, "line": 1337}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 1337}, "start": {"column": 15, "line": 1337}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 1337}, "start": {"column": 15, "line": 1337}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 45, "line": 1339}, "start": {"column": 44, "line": 1339}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 19, "line": 1403}, "start": {"column": 3, "line": 1403}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 1453}, "start": {"column": 17, "line": 1453}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 1453}, "start": {"column": 17, "line": 1453}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 1453}, "start": {"column": 32, "line": 1453}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 1459}, "start": {"column": 13, "line": 1459}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 48, "line": 1459}, "start": {"column": 46, "line": 1459}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 1463}, "start": {"column": 18, "line": 1463}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 1471}, "start": {"column": 19, "line": 1471}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 1471}, "start": {"column": 19, "line": 1471}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 1471}, "start": {"column": 28, "line": 1471}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 1501}, "start": {"column": 17, "line": 1501}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 1501}, "start": {"column": 17, "line": 1501}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 1501}, "start": {"column": 26, "line": 1501}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 1505}, "start": {"column": 18, "line": 1505}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 1505}, "start": {"column": 18, "line": 1505}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 46, "line": 1505}, "start": {"column": 43, "line": 1505}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 1506}, "start": {"column": 18, "line": 1506}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 11, "line": 1509}, "start": {"column": 10, "line": 1509}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 11, "line": 1509}, "start": {"column": 10, "line": 1509}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 31, "line": 1511}, "start": {"column": 30, "line": 1511}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 31, "line": 1511}, "start": {"column": 30, "line": 1511}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 1512}, "start": {"column": 14, "line": 1512}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 1520}, "start": {"column": 17, "line": 1520}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 1520}, "start": {"column": 17, "line": 1520}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 45, "line": 1520}, "start": {"column": 42, "line": 1520}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 11, "line": 1522}, "start": {"column": 10, "line": 1522}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1522}, "start": {"column": 14, "line": 1522}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 1550}, "start": {"column": 17, "line": 1550}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 1550}, "start": {"column": 17, "line": 1550}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 1550}, "start": {"column": 26, "line": 1550}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 1561}, "start": {"column": 17, "line": 1561}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 1561}, "start": {"column": 17, "line": 1561}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 1561}, "start": {"column": 26, "line": 1561}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 29, "line": 1656}, "start": {"column": 27, "line": 1656}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 29, "line": 1656}, "start": {"column": 27, "line": 1656}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 49, "line": 1656}, "start": {"column": 41, "line": 1656}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 29, "line": 1671}, "start": {"column": 27, "line": 1671}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 29, "line": 1671}, "start": {"column": 27, "line": 1671}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 46, "line": 1671}, "start": {"column": 38, "line": 1671}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 1676}, "start": {"column": 17, "line": 1676}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 22, "line": 1678}, "start": {"column": 21, "line": 1678}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 1680}, "start": {"column": 13, "line": 1680}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 1687}, "start": {"column": 14, "line": 1687}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 29, "line": 1695}, "start": {"column": 27, "line": 1695}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 29, "line": 1695}, "start": {"column": 27, "line": 1695}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 46, "line": 1695}, "start": {"column": 38, "line": 1695}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 1718}, "start": {"column": 2, "line": 1718}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 1772}, "start": {"column": 17, "line": 1772}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 1772}, "start": {"column": 17, "line": 1772}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 30, "line": 1772}, "start": {"column": 27, "line": 1772}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 1778}, "start": {"column": 17, "line": 1778}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 1778}, "start": {"column": 17, "line": 1778}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 1778}, "start": {"column": 31, "line": 1778}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 1821}, "start": {"column": 31, "line": 1821}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 1826}, "start": {"column": 31, "line": 1826}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 43, "line": 1835}, "start": {"column": 41, "line": 1835}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 43, "line": 1835}, "start": {"column": 41, "line": 1835}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 1837}, "start": {"column": 17, "line": 1837}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 1855}, "start": {"column": 18, "line": 1855}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 1855}, "start": {"column": 18, "line": 1855}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 1855}, "start": {"column": 29, "line": 1855}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 34, "line": 1875}, "start": {"column": 33, "line": 1875}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 1887}, "start": {"column": 18, "line": 1887}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 1887}, "start": {"column": 18, "line": 1887}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 44, "line": 1887}, "start": {"column": 41, "line": 1887}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 29, "line": 1896}, "start": {"column": 28, "line": 1896}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 1898}, "start": {"column": 17, "line": 1898}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 1898}, "start": {"column": 17, "line": 1898}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 41, "line": 1898}, "start": {"column": 38, "line": 1898}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 11, "line": 1906}, "start": {"column": 10, "line": 1906}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1906}, "start": {"column": 14, "line": 1906}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 32, "line": 1907}, "start": {"column": 31, "line": 1907}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 37, "line": 1907}, "start": {"column": 36, "line": 1907}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 24, "line": 1910}, "start": {"column": 23, "line": 1910}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 38, "line": 1910}, "start": {"column": 37, "line": 1910}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 1918}, "start": {"column": 4, "line": 1918}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 50, "line": 1920}, "start": {"column": 49, "line": 1920}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 50, "line": 1920}, "start": {"column": 49, "line": 1920}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 1932}, "start": {"column": 3, "line": 1932}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 21, "line": 1933}, "start": {"column": 3, "line": 1933}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 1934}, "start": {"column": 3, "line": 1934}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 1937}, "start": {"column": 20, "line": 1937}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 1937}, "start": {"column": 20, "line": 1937}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 1942}, "start": {"column": 18, "line": 1942}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 1942}, "start": {"column": 18, "line": 1942}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 1942}, "start": {"column": 29, "line": 1942}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 19, "line": 1945}, "start": {"column": 8, "line": 1945}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 24, "line": 1955}, "start": {"column": 22, "line": 1955}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 24, "line": 1955}, "start": {"column": 22, "line": 1955}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 1955}, "start": {"column": 33, "line": 1955}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 1961}, "start": {"column": 23, "line": 1961}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 24, "line": 1972}, "start": {"column": 23, "line": 1972}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 1973}, "start": {"column": 7, "line": 1973}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 14, "line": 1978}, "start": {"column": 13, "line": 1978}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 14, "line": 1978}, "start": {"column": 13, "line": 1978}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 24, "line": 1990}, "start": {"column": 15, "line": 1990}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 1992}, "start": {"column": 6, "line": 1992}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 27, "line": 2013}, "start": {"column": 24, "line": 2013}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 2013}, "start": {"column": 29, "line": 2013}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 19, "line": 2016}, "start": {"column": 6, "line": 2016}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 2017}, "start": {"column": 6, "line": 2017}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 2020}, "start": {"column": 5, "line": 2020}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 32, "line": 2029}, "start": {"column": 30, "line": 2029}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 32, "line": 2029}, "start": {"column": 30, "line": 2029}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 41, "line": 2029}, "start": {"column": 38, "line": 2029}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 46, "line": 2029}, "start": {"column": 43, "line": 2029}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 2031}, "start": {"column": 19, "line": 2031}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 2031}, "start": {"column": 36, "line": 2031}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 2033}, "start": {"column": 6, "line": 2033}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 26, "line": 2035}, "start": {"column": 24, "line": 2035}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 2035}, "start": {"column": 41, "line": 2035}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 12, "line": 2045}, "start": {"column": 11, "line": 2045}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 12, "line": 2045}, "start": {"column": 11, "line": 2045}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 2059}, "start": {"column": 12, "line": 2059}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 34, "line": 2060}, "start": {"column": 14, "line": 2060}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 2064}, "start": {"column": 19, "line": 2064}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 2064}, "start": {"column": 19, "line": 2064}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 45, "line": 2064}, "start": {"column": 42, "line": 2064}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 39, "line": 2068}, "start": {"column": 36, "line": 2068}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 2077}, "start": {"column": 16, "line": 2077}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 2092}, "start": {"column": 19, "line": 2092}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 2092}, "start": {"column": 19, "line": 2092}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 2092}, "start": {"column": 31, "line": 2092}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 2093}, "start": {"column": 22, "line": 2093}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 2093}, "start": {"column": 22, "line": 2093}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 18, "line": 2113}, "start": {"column": 17, "line": 2113}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 18, "line": 2113}, "start": {"column": 17, "line": 2113}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2145}, "start": {"column": 17, "line": 2145}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2145}, "start": {"column": 17, "line": 2145}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 2145}, "start": {"column": 29, "line": 2145}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 2146}, "start": {"column": 16, "line": 2146}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 2148}, "start": {"column": 19, "line": 2148}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 2163}, "start": {"column": 20, "line": 2163}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 2163}, "start": {"column": 20, "line": 2163}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 37, "line": 2163}, "start": {"column": 34, "line": 2163}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 2164}, "start": {"column": 18, "line": 2164}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 2167}, "start": {"column": 12, "line": 2167}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 2167}, "start": {"column": 12, "line": 2167}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 2169}, "start": {"column": 6, "line": 2169}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 2174}, "start": {"column": 5, "line": 2174}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 2178}, "start": {"column": 5, "line": 2178}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 2183}, "start": {"column": 7, "line": 2183}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 19, "line": 2183}, "start": {"column": 17, "line": 2183}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 19, "line": 2183}, "start": {"column": 17, "line": 2183}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2197}, "start": {"column": 17, "line": 2197}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2197}, "start": {"column": 17, "line": 2197}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 2197}, "start": {"column": 31, "line": 2197}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 2203}, "start": {"column": 12, "line": 2203}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 2226}, "start": {"column": 18, "line": 2226}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 2226}, "start": {"column": 18, "line": 2226}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 30, "line": 2226}, "start": {"column": 27, "line": 2226}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 2230}, "start": {"column": 19, "line": 2230}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 2230}, "start": {"column": 19, "line": 2230}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 2245}, "start": {"column": 17, "line": 2245}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 2247}, "start": {"column": 18, "line": 2247}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 2247}, "start": {"column": 18, "line": 2247}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 30, "line": 2247}, "start": {"column": 27, "line": 2247}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 2248}, "start": {"column": 19, "line": 2248}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 2248}, "start": {"column": 19, "line": 2248}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 12, "line": 2253}, "start": {"column": 10, "line": 2253}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 12, "line": 2253}, "start": {"column": 10, "line": 2253}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2277}, "start": {"column": 17, "line": 2277}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2277}, "start": {"column": 17, "line": 2277}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 30, "line": 2277}, "start": {"column": 27, "line": 2277}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 2283}, "start": {"column": 12, "line": 2283}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 2283}, "start": {"column": 12, "line": 2283}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 14, "line": 2285}, "start": {"column": 10, "line": 2285}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 2291}, "start": {"column": 20, "line": 2291}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 2291}, "start": {"column": 20, "line": 2291}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 2291}, "start": {"column": 30, "line": 2291}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 2296}, "start": {"column": 26, "line": 2296}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 2298}, "start": {"column": 14, "line": 2298}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 2301}, "start": {"column": 14, "line": 2301}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 2301}, "start": {"column": 14, "line": 2301}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 2307}, "start": {"column": 19, "line": 2307}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 21, "line": 2312}, "start": {"column": 10, "line": 2312}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 2316}, "start": {"column": 20, "line": 2316}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 2316}, "start": {"column": 20, "line": 2316}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 2316}, "start": {"column": 30, "line": 2316}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 2318}, "start": {"column": 26, "line": 2318}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 2320}, "start": {"column": 14, "line": 2320}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 2323}, "start": {"column": 14, "line": 2323}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 2323}, "start": {"column": 14, "line": 2323}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 2325}, "start": {"column": 19, "line": 2325}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 23, "line": 2327}, "start": {"column": 12, "line": 2327}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 19, "line": 2333}, "start": {"column": 17, "line": 2333}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 19, "line": 2333}, "start": {"column": 17, "line": 2333}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 33, "line": 2333}, "start": {"column": 31, "line": 2333}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 33, "line": 2333}, "start": {"column": 31, "line": 2333}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 2337}, "start": {"column": 17, "line": 2337}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 2341}, "start": {"column": 33, "line": 2341}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 20, "line": 2342}, "start": {"column": 9, "line": 2342}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2369}, "start": {"column": 17, "line": 2369}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2369}, "start": {"column": 17, "line": 2369}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 2369}, "start": {"column": 28, "line": 2369}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 2371}, "start": {"column": 18, "line": 2371}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 2372}, "start": {"column": 17, "line": 2372}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2378}, "start": {"column": 17, "line": 2378}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2378}, "start": {"column": 17, "line": 2378}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 2378}, "start": {"column": 31, "line": 2378}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 14, "line": 2383}, "start": {"column": 12, "line": 2383}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 2385}, "start": {"column": 13, "line": 2385}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 2385}, "start": {"column": 13, "line": 2385}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 23, "line": 2385}, "start": {"column": 15, "line": 2385}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 33, "line": 2385}, "start": {"column": 31, "line": 2385}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 33, "line": 2385}, "start": {"column": 31, "line": 2385}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 15, "line": 2391}, "start": {"column": 13, "line": 2391}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 15, "line": 2391}, "start": {"column": 13, "line": 2391}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 15, "line": 2401}, "start": {"column": 11, "line": 2401}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 2412}, "start": {"column": 21, "line": 2412}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 2412}, "start": {"column": 21, "line": 2412}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 2412}, "start": {"column": 31, "line": 2412}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 2414}, "start": {"column": 25, "line": 2414}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 2416}, "start": {"column": 16, "line": 2416}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 2419}, "start": {"column": 13, "line": 2419}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 2419}, "start": {"column": 20, "line": 2419}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 2419}, "start": {"column": 20, "line": 2419}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 30, "line": 2419}, "start": {"column": 27, "line": 2419}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 2423}, "start": {"column": 12, "line": 2423}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 2423}, "start": {"column": 19, "line": 2423}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 2423}, "start": {"column": 19, "line": 2423}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 2423}, "start": {"column": 30, "line": 2423}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 2428}, "start": {"column": 21, "line": 2428}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 2428}, "start": {"column": 21, "line": 2428}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 2428}, "start": {"column": 31, "line": 2428}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 2430}, "start": {"column": 25, "line": 2430}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 2432}, "start": {"column": 16, "line": 2432}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2478}, "start": {"column": 17, "line": 2478}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2478}, "start": {"column": 17, "line": 2478}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 2478}, "start": {"column": 29, "line": 2478}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 25, "line": 2490}, "start": {"column": 24, "line": 2490}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 25, "line": 2490}, "start": {"column": 24, "line": 2490}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 43, "line": 2490}, "start": {"column": 37, "line": 2490}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 23, "line": 2492}, "start": {"column": 22, "line": 2492}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 17, "line": 2495}, "start": {"column": 16, "line": 2495}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 17, "line": 2495}, "start": {"column": 16, "line": 2495}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 2497}, "start": {"column": 17, "line": 2497}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 2498}, "start": {"column": 5, "line": 2498}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2527}, "start": {"column": 17, "line": 2527}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2527}, "start": {"column": 17, "line": 2527}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 28, "line": 2527}, "start": {"column": 25, "line": 2527}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 2528}, "start": {"column": 15, "line": 2528}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 20, "line": 2530}, "start": {"column": 13, "line": 2530}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 26, "line": 2531}, "start": {"column": 24, "line": 2531}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 20, "line": 2532}, "start": {"column": 14, "line": 2532}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 2568}, "start": {"column": 15, "line": 2568}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 2568}, "start": {"column": 15, "line": 2568}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 30, "line": 2572}, "start": {"column": 28, "line": 2572}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 13, "line": 2578}, "start": {"column": 12, "line": 2578}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 28, "line": 2580}, "start": {"column": 26, "line": 2580}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 40, "line": 2580}, "start": {"column": 38, "line": 2580}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 40, "line": 2580}, "start": {"column": 38, "line": 2580}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 2582}, "start": {"column": 14, "line": 2582}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 2582}, "start": {"column": 14, "line": 2582}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 27, "line": 2582}, "start": {"column": 24, "line": 2582}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 2586}, "start": {"column": 33, "line": 2586}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 2591}, "start": {"column": 19, "line": 2591}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 2591}, "start": {"column": 19, "line": 2591}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 2594}, "start": {"column": 19, "line": 2594}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 17, "line": 2620}, "start": {"column": 15, "line": 2620}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 2628}, "start": {"column": 18, "line": 2628}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 2628}, "start": {"column": 34, "line": 2628}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 2638}, "start": {"column": 9, "line": 2638}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 41, "line": 2638}, "start": {"column": 40, "line": 2638}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 41, "line": 2638}, "start": {"column": 40, "line": 2638}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 56, "line": 2638}, "start": {"column": 50, "line": 2638}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 18, "line": 2656}, "start": {"column": 16, "line": 2656}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 18, "line": 2659}, "start": {"column": 16, "line": 2659}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 33, "line": 2727}, "start": {"column": 32, "line": 2727}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 14, "line": 2729}, "start": {"column": 12, "line": 2729}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 14, "line": 2729}, "start": {"column": 12, "line": 2729}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 2735}, "start": {"column": 12, "line": 2735}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 2735}, "start": {"column": 12, "line": 2735}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 2747}, "start": {"column": 32, "line": 2747}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 2768}, "start": {"column": 32, "line": 2768}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 40, "line": 2798}, "start": {"column": 39, "line": 2798}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 11, "line": 2802}, "start": {"column": 10, "line": 2802}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 20, "line": 2802}, "start": {"column": 19, "line": 2802}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 2823}, "start": {"column": 17, "line": 2823}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 23, "line": 2823}, "start": {"column": 21, "line": 2823}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 23, "line": 2823}, "start": {"column": 21, "line": 2823}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 19, "line": 2826}, "start": {"column": 18, "line": 2826}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 24, "line": 2826}, "start": {"column": 22, "line": 2826}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 24, "line": 2826}, "start": {"column": 22, "line": 2826}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 16, "line": 2829}, "start": {"column": 15, "line": 2829}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 30, "line": 2829}, "start": {"column": 29, "line": 2829}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 14, "line": 2830}, "start": {"column": 13, "line": 2830}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 14, "line": 2831}, "start": {"column": 13, "line": 2831}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 28, "line": 2831}, "start": {"column": 27, "line": 2831}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 14, "line": 2832}, "start": {"column": 13, "line": 2832}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 14, "line": 2835}, "start": {"column": 13, "line": 2835}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2840}, "start": {"column": 17, "line": 2840}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2840}, "start": {"column": 17, "line": 2840}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 2840}, "start": {"column": 29, "line": 2840}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 15, "line": 2846}, "start": {"column": 14, "line": 2846}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 15, "line": 2847}, "start": {"column": 14, "line": 2847}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2850}, "start": {"column": 17, "line": 2850}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2850}, "start": {"column": 17, "line": 2850}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 2850}, "start": {"column": 28, "line": 2850}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 2852}, "start": {"column": 15, "line": 2852}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 44, "line": 2853}, "start": {"column": 43, "line": 2853}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 49, "line": 2853}, "start": {"column": 48, "line": 2853}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 2855}, "start": {"column": 20, "line": 2855}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 2858}, "start": {"column": 20, "line": 2858}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 2858}, "start": {"column": 20, "line": 2858}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 41, "line": 2858}, "start": {"column": 39, "line": 2858}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 21, "line": 2863}, "start": {"column": 20, "line": 2863}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 26, "line": 2863}, "start": {"column": 25, "line": 2863}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 37, "line": 2868}, "start": {"column": 36, "line": 2868}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 54, "line": 2868}, "start": {"column": 53, "line": 2868}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 37, "line": 2869}, "start": {"column": 36, "line": 2869}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 54, "line": 2869}, "start": {"column": 53, "line": 2869}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 11, "line": 2876}, "start": {"column": 10, "line": 2876}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 2876}, "start": {"column": 14, "line": 2876}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 2879}, "start": {"column": 17, "line": 2879}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 2879}, "start": {"column": 17, "line": 2879}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 28, "line": 2879}, "start": {"column": 27, "line": 2879}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 2879}, "start": {"column": 32, "line": 2879}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 2898}, "start": {"column": 17, "line": 2898}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 2898}, "start": {"column": 17, "line": 2898}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 2898}, "start": {"column": 26, "line": 2898}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 24, "line": 2900}, "start": {"column": 22, "line": 2900}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 24, "line": 2900}, "start": {"column": 22, "line": 2900}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 38, "line": 2900}, "start": {"column": 36, "line": 2900}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 38, "line": 2900}, "start": {"column": 36, "line": 2900}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 20, "line": 2913}, "start": {"column": 19, "line": 2913}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 2915}, "start": {"column": 18, "line": 2915}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 2915}, "start": {"column": 18, "line": 2915}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 2915}, "start": {"column": 29, "line": 2915}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 2917}, "start": {"column": 19, "line": 2917}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 2917}, "start": {"column": 19, "line": 2917}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 35, "line": 2917}, "start": {"column": 34, "line": 2917}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 40, "line": 3075}, "start": {"column": 39, "line": 3075}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 25, "line": 3078}, "start": {"column": 24, "line": 3078}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 3082}, "start": {"column": 17, "line": 3082}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 3082}, "start": {"column": 17, "line": 3082}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 3082}, "start": {"column": 29, "line": 3082}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 56, "line": 3135}, "start": {"column": 55, "line": 3135}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 24, "line": 3173}, "start": {"column": 23, "line": 3173}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 24, "line": 3173}, "start": {"column": 23, "line": 3173}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 24, "line": 3182}, "start": {"column": 23, "line": 3182}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 24, "line": 3182}, "start": {"column": 23, "line": 3182}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 24, "line": 3206}, "start": {"column": 23, "line": 3206}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 24, "line": 3206}, "start": {"column": 23, "line": 3206}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 24, "line": 3211}, "start": {"column": 23, "line": 3211}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 24, "line": 3211}, "start": {"column": 23, "line": 3211}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 41, "line": 3332}, "start": {"column": 40, "line": 3332}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 41, "line": 3332}, "start": {"column": 40, "line": 3332}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 40, "line": 3450}, "start": {"column": 39, "line": 3450}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 3460}, "start": {"column": 2, "line": 3460}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 35, "line": 3479}, "start": {"column": 34, "line": 3479}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 3483}, "start": {"column": 18, "line": 3483}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 3483}, "start": {"column": 18, "line": 3483}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 3483}, "start": {"column": 30, "line": 3483}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 3487}, "start": {"column": 19, "line": 3487}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 3497}, "start": {"column": 20, "line": 3497}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 3497}, "start": {"column": 20, "line": 3497}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 3497}, "start": {"column": 29, "line": 3497}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 9, "line": 3501}, "start": {"column": 6, "line": 3501}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 17, "line": 3505}, "start": {"column": 16, "line": 3505}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 17, "line": 3505}, "start": {"column": 16, "line": 3505}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 32, "line": 3505}, "start": {"column": 30, "line": 3505}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 32, "line": 3505}, "start": {"column": 30, "line": 3505}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 3506}, "start": {"column": 26, "line": 3506}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 3522}, "start": {"column": 14, "line": 3522}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 3522}, "start": {"column": 14, "line": 3522}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 3541}, "start": {"column": 18, "line": 3541}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 3541}, "start": {"column": 18, "line": 3541}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 3541}, "start": {"column": 30, "line": 3541}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 3556}, "start": {"column": 14, "line": 3556}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 6, "line": 3564}, "start": {"column": 3, "line": 3564}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 3568}, "start": {"column": 17, "line": 3568}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 3568}, "start": {"column": 17, "line": 3568}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 3568}, "start": {"column": 29, "line": 3568}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 47, "line": 3599}, "start": {"column": 46, "line": 3599}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 3601}, "start": {"column": 18, "line": 3601}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 3601}, "start": {"column": 18, "line": 3601}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 3601}, "start": {"column": 29, "line": 3601}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 3613}, "start": {"column": 25, "line": 3613}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 25, "line": 3615}, "start": {"column": 23, "line": 3615}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 25, "line": 3615}, "start": {"column": 23, "line": 3615}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 28, "line": 3617}, "start": {"column": 27, "line": 3617}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 3619}, "start": {"column": 17, "line": 3619}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 3619}, "start": {"column": 17, "line": 3619}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 3619}, "start": {"column": 29, "line": 3619}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 3623}, "start": {"column": 16, "line": 3623}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 3626}, "start": {"column": 10, "line": 3626}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 3629}, "start": {"column": 15, "line": 3629}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 3629}, "start": {"column": 15, "line": 3629}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 3632}, "start": {"column": 4, "line": 3632}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 22, "line": 3633}, "start": {"column": 21, "line": 3633}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 3633}, "start": {"column": 25, "line": 3633}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 3642}, "start": {"column": 8, "line": 3642}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 38, "line": 3642}, "start": {"column": 36, "line": 3642}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 38, "line": 3642}, "start": {"column": 36, "line": 3642}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 56, "line": 3642}, "start": {"column": 53, "line": 3642}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 31, "line": 3650}, "start": {"column": 29, "line": 3650}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 31, "line": 3650}, "start": {"column": 29, "line": 3650}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 3652}, "start": {"column": 26, "line": 3652}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 3654}, "start": {"column": 17, "line": 3654}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 3654}, "start": {"column": 17, "line": 3654}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 37, "line": 3654}, "start": {"column": 34, "line": 3654}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 31, "line": 3659}, "start": {"column": 29, "line": 3659}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 31, "line": 3659}, "start": {"column": 29, "line": 3659}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 3661}, "start": {"column": 20, "line": 3661}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 3663}, "start": {"column": 17, "line": 3663}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 3663}, "start": {"column": 17, "line": 3663}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 3663}, "start": {"column": 28, "line": 3663}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 3668}, "start": {"column": 15, "line": 3668}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 3668}, "start": {"column": 30, "line": 3668}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 31, "line": 3676}, "start": {"column": 29, "line": 3676}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 31, "line": 3676}, "start": {"column": 29, "line": 3676}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 3678}, "start": {"column": 20, "line": 3678}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 3680}, "start": {"column": 17, "line": 3680}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 3680}, "start": {"column": 17, "line": 3680}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 3680}, "start": {"column": 28, "line": 3680}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 3682}, "start": {"column": 15, "line": 3682}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 3683}, "start": {"column": 4, "line": 3683}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 55, "line": 3778}, "start": {"column": 54, "line": 3778}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 34, "line": 3785}, "start": {"column": 33, "line": 3785}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 43, "line": 3785}, "start": {"column": 42, "line": 3785}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 24, "line": 3787}, "start": {"column": 22, "line": 3787}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 24, "line": 3787}, "start": {"column": 22, "line": 3787}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 3824}, "start": {"column": 22, "line": 3824}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 3824}, "start": {"column": 22, "line": 3824}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 55, "line": 3837}, "start": {"column": 54, "line": 3837}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 3839}, "start": {"column": 18, "line": 3839}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 3839}, "start": {"column": 18, "line": 3839}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 3839}, "start": {"column": 30, "line": 3839}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 3860}, "start": {"column": 18, "line": 3860}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 3860}, "start": {"column": 18, "line": 3860}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 3860}, "start": {"column": 31, "line": 3860}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 53, "line": 4148}, "start": {"column": 52, "line": 4148}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 4187}, "start": {"column": 17, "line": 4187}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 4187}, "start": {"column": 17, "line": 4187}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 4187}, "start": {"column": 28, "line": 4187}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 4286}, "start": {"column": 15, "line": 4286}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 32, "line": 4327}, "start": {"column": 31, "line": 4327}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 32, "line": 4327}, "start": {"column": 31, "line": 4327}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 4344}, "start": {"column": 14, "line": 4344}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 31, "line": 4344}, "start": {"column": 29, "line": 4344}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 31, "line": 4344}, "start": {"column": 29, "line": 4344}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 45, "line": 4344}, "start": {"column": 44, "line": 4344}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 31, "line": 4346}, "start": {"column": 30, "line": 4346}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 4348}, "start": {"column": 17, "line": 4348}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 4348}, "start": {"column": 17, "line": 4348}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 32, "line": 4352}, "start": {"column": 31, "line": 4352}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 35, "line": 4373}, "start": {"column": 34, "line": 4373}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 18, "line": 4436}, "start": {"column": 17, "line": 4436}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 18, "line": 4436}, "start": {"column": 17, "line": 4436}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 4437}, "start": {"column": 18, "line": 4437}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 4437}, "start": {"column": 18, "line": 4437}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 26, "line": 4437}, "start": {"column": 23, "line": 4437}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 4438}, "start": {"column": 14, "line": 4438}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 4438}, "start": {"column": 14, "line": 4438}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 4438}, "start": {"column": 20, "line": 4438}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 17, "line": 4441}, "start": {"column": 16, "line": 4441}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 10, "line": 4442}, "start": {"column": 9, "line": 4442}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 11, "line": 4455}, "start": {"column": 9, "line": 4455}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 11, "line": 4455}, "start": {"column": 9, "line": 4455}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 11, "line": 4459}, "start": {"column": 9, "line": 4459}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 11, "line": 4459}, "start": {"column": 9, "line": 4459}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 14, "line": 4490}, "start": {"column": 13, "line": 4490}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 20, "line": 4490}, "start": {"column": 19, "line": 4490}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 25, "line": 4490}, "start": {"column": 24, "line": 4490}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 4493}, "start": {"column": 12, "line": 4493}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 4496}, "start": {"column": 36, "line": 4496}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 4519}, "start": {"column": 34, "line": 4519}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 17, "line": 4551}, "start": {"column": 16, "line": 4551}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 26, "line": 4551}, "start": {"column": 25, "line": 4551}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 26, "line": 4551}, "start": {"column": 25, "line": 4551}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 41, "line": 4551}, "start": {"column": 40, "line": 4551}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 4552}, "start": {"column": 20, "line": 4552}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 4552}, "start": {"column": 20, "line": 4552}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 28, "line": 4552}, "start": {"column": 25, "line": 4552}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 17, "line": 4553}, "start": {"column": 16, "line": 4553}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 27, "line": 4553}, "start": {"column": 25, "line": 4553}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 27, "line": 4553}, "start": {"column": 25, "line": 4553}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 38, "line": 4553}, "start": {"column": 37, "line": 4553}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 13, "line": 4555}, "start": {"column": 12, "line": 4555}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 4559}, "start": {"column": 17, "line": 4559}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 4562}, "start": {"column": 21, "line": 4562}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 36, "line": 4562}, "start": {"column": 34, "line": 4562}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 36, "line": 4562}, "start": {"column": 34, "line": 4562}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 4566}, "start": {"column": 20, "line": 4566}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 4566}, "start": {"column": 20, "line": 4566}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 4580}, "start": {"column": 15, "line": 4580}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 4580}, "start": {"column": 15, "line": 4580}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 4597}, "start": {"column": 7, "line": 4597}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 4597}, "start": {"column": 18, "line": 4597}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 4597}, "start": {"column": 18, "line": 4597}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 4690}, "start": {"column": 13, "line": 4690}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 4690}, "start": {"column": 13, "line": 4690}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 4692}, "start": {"column": 12, "line": 4692}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 4705}, "start": {"column": 20, "line": 4705}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 4707}, "start": {"column": 4, "line": 4707}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 29, "line": 4731}, "start": {"column": 27, "line": 4731}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 29, "line": 4742}, "start": {"column": 27, "line": 4742}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 4755}, "start": {"column": 15, "line": 4755}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 4755}, "start": {"column": 15, "line": 4755}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 4761}, "start": {"column": 15, "line": 4761}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 4768}, "start": {"column": 2, "line": 4768}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 4782}, "start": {"column": 15, "line": 4782}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 4782}, "start": {"column": 15, "line": 4782}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 4788}, "start": {"column": 15, "line": 4788}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 4794}, "start": {"column": 2, "line": 4794}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 4853}, "start": {"column": 5, "line": 4853}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 4875}, "start": {"column": 5, "line": 4875}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 26, "line": 4945}, "start": {"column": 23, "line": 4945}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 4946}, "start": {"column": 15, "line": 4946}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 4947}, "start": {"column": 4, "line": 4947}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 4982}, "start": {"column": 9, "line": 4982}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 4983}, "start": {"column": 3, "line": 4983}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 4991}, "start": {"column": 2, "line": 4991}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 12, "line": 5005}, "start": {"column": 10, "line": 5005}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 12, "line": 5005}, "start": {"column": 10, "line": 5005}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 5005}, "start": {"column": 20, "line": 5005}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 5005}, "start": {"column": 20, "line": 5005}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 33, "line": 5005}, "start": {"column": 31, "line": 5005}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 33, "line": 5005}, "start": {"column": 31, "line": 5005}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 5027}, "start": {"column": 14, "line": 5027}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 35, "line": 5048}, "start": {"column": 34, "line": 5048}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 5074}, "start": {"column": 36, "line": 5074}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 35, "line": 5075}, "start": {"column": 33, "line": 5075}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 40, "line": 5075}, "start": {"column": 38, "line": 5075}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 5077}, "start": {"column": 15, "line": 5077}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 5129}, "start": {"column": 15, "line": 5129}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 5129}, "start": {"column": 15, "line": 5129}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 5133}, "start": {"column": 8, "line": 5133}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 20, "line": 5133}, "start": {"column": 19, "line": 5133}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 5133}, "start": {"column": 24, "line": 5133}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 5171}, "start": {"column": 13, "line": 5171}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 5171}, "start": {"column": 13, "line": 5171}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 5226}, "start": {"column": 32, "line": 5226}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 5256}, "start": {"column": 17, "line": 5256}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 5256}, "start": {"column": 17, "line": 5256}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 28, "line": 5256}, "start": {"column": 25, "line": 5256}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 5282}, "start": {"column": 19, "line": 5282}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 5282}, "start": {"column": 19, "line": 5282}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 5282}, "start": {"column": 31, "line": 5282}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 5293}, "start": {"column": 13, "line": 5293}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 31, "line": 5327}, "start": {"column": 29, "line": 5327}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 31, "line": 5327}, "start": {"column": 29, "line": 5327}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 41, "line": 5327}, "start": {"column": 38, "line": 5327}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 5331}, "start": {"column": 18, "line": 5331}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 40, "line": 5333}, "start": {"column": 39, "line": 5333}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 48, "line": 5333}, "start": {"column": 47, "line": 5333}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 5335}, "start": {"column": 22, "line": 5335}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 5336}, "start": {"column": 19, "line": 5336}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 17, "line": 5338}, "start": {"column": 16, "line": 5338}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 5338}, "start": {"column": 24, "line": 5338}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 5344}, "start": {"column": 13, "line": 5344}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 24, "line": 5347}, "start": {"column": 23, "line": 5347}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 28, "line": 5347}, "start": {"column": 27, "line": 5347}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 5349}, "start": {"column": 14, "line": 5349}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 33, "line": 5350}, "start": {"column": 32, "line": 5350}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 33, "line": 5351}, "start": {"column": 32, "line": 5351}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 31, "line": 5352}, "start": {"column": 30, "line": 5352}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 28, "line": 5395}, "start": {"column": 27, "line": 5395}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 28, "line": 5395}, "start": {"column": 27, "line": 5395}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 17, "line": 5407}, "start": {"column": 16, "line": 5407}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 17, "line": 5407}, "start": {"column": 16, "line": 5407}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 33, "line": 5407}, "start": {"column": 32, "line": 5407}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 33, "line": 5407}, "start": {"column": 32, "line": 5407}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 18, "line": 5418}, "start": {"column": 17, "line": 5418}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 18, "line": 5418}, "start": {"column": 17, "line": 5418}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 5468}, "start": {"column": 13, "line": 5468}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 5471}, "start": {"column": 17, "line": 5471}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 27, "line": 5505}, "start": {"column": 25, "line": 5505}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 5507}, "start": {"column": 23, "line": 5507}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 5511}, "start": {"column": 23, "line": 5511}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 5544}, "start": {"column": 13, "line": 5544}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 5547}, "start": {"column": 19, "line": 5547}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 5631}, "start": {"column": 13, "line": 5631}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 5634}, "start": {"column": 19, "line": 5634}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 5649}, "start": {"column": 33, "line": 5649}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 5656}, "start": {"column": 32, "line": 5656}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 35, "line": 5723}, "start": {"column": 34, "line": 5723}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 5725}, "start": {"column": 10, "line": 5725}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 5736}, "start": {"column": 19, "line": 5736}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 5736}, "start": {"column": 19, "line": 5736}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 28, "line": 5736}, "start": {"column": 25, "line": 5736}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 5768}, "start": {"column": 7, "line": 5768}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 19, "line": 5768}, "start": {"column": 17, "line": 5768}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 19, "line": 5768}, "start": {"column": 17, "line": 5768}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 41, "line": 5770}, "start": {"column": 39, "line": 5770}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 41, "line": 5770}, "start": {"column": 39, "line": 5770}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 5775}, "start": {"column": 3, "line": 5775}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 5809}, "start": {"column": 11, "line": 5809}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 5809}, "start": {"column": 11, "line": 5809}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 5817}, "start": {"column": 16, "line": 5817}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 5818}, "start": {"column": 3, "line": 5818}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 27, "line": 5846}, "start": {"column": 25, "line": 5846}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 5849}, "start": {"column": 34, "line": 5849}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 26, "line": 5850}, "start": {"column": 24, "line": 5850}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 9, "line": 5855}, "start": {"column": 3, "line": 5855}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 5864}, "start": {"column": 7, "line": 5864}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 21, "line": 5864}, "start": {"column": 19, "line": 5864}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 21, "line": 5864}, "start": {"column": 19, "line": 5864}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 5866}, "start": {"column": 3, "line": 5866}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 18, "line": 5876}, "start": {"column": 17, "line": 5876}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 18, "line": 5876}, "start": {"column": 17, "line": 5876}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 7505}, "start": {"column": 17, "line": 7505}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 39, "line": 7508}, "start": {"column": 37, "line": 7508}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 29, "line": 7596}, "start": {"column": 28, "line": 7596}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 58, "line": 7596}, "start": {"column": 56, "line": 7596}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 7638}, "start": {"column": 2, "line": 7638}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 7663}, "start": {"column": 7, "line": 7663}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 18, "line": 7663}, "start": {"column": 16, "line": 7663}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 18, "line": 7663}, "start": {"column": 16, "line": 7663}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 20, "line": 7789}, "start": {"column": 19, "line": 7789}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 27, "line": 7789}, "start": {"column": 26, "line": 7789}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 27, "line": 7789}, "start": {"column": 26, "line": 7789}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 37, "line": 7789}, "start": {"column": 36, "line": 7789}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 13, "line": 7798}, "start": {"column": 12, "line": 7798}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 7798}, "start": {"column": 18, "line": 7798}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 7798}, "start": {"column": 18, "line": 7798}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 32, "line": 7798}, "start": {"column": 31, "line": 7798}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 7806}, "start": {"column": 27, "line": 7806}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 7807}, "start": {"column": 23, "line": 7807}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 7826}, "start": {"column": 19, "line": 7826}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 17, "line": 7840}, "start": {"column": 16, "line": 7840}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 7840}, "start": {"column": 22, "line": 7840}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 7840}, "start": {"column": 22, "line": 7840}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 36, "line": 7840}, "start": {"column": 35, "line": 7840}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 27, "line": 7845}, "start": {"column": 25, "line": 7845}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 38, "line": 7847}, "start": {"column": 37, "line": 7847}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 7848}, "start": {"column": 12, "line": 7848}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 7848}, "start": {"column": 12, "line": 7848}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 18, "line": 7850}, "start": {"column": 17, "line": 7850}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 17, "line": 7861}, "start": {"column": 16, "line": 7861}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 7861}, "start": {"column": 22, "line": 7861}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 7861}, "start": {"column": 22, "line": 7861}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 36, "line": 7861}, "start": {"column": 35, "line": 7861}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 18, "line": 7868}, "start": {"column": 17, "line": 7868}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 25, "line": 7868}, "start": {"column": 23, "line": 7868}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 25, "line": 7868}, "start": {"column": 23, "line": 7868}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 21, "line": 7869}, "start": {"column": 20, "line": 7869}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 18, "line": 7889}, "start": {"column": 17, "line": 7889}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 25, "line": 7889}, "start": {"column": 23, "line": 7889}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 25, "line": 7889}, "start": {"column": 23, "line": 7889}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 21, "line": 7890}, "start": {"column": 20, "line": 7890}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 24, "line": 7923}, "start": {"column": 23, "line": 7923}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 33, "line": 7923}, "start": {"column": 32, "line": 7923}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 19, "line": 7936}, "start": {"column": 18, "line": 7936}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 30, "line": 7936}, "start": {"column": 29, "line": 7936}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 35, "line": 7936}, "start": {"column": 33, "line": 7936}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 35, "line": 7936}, "start": {"column": 33, "line": 7936}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 7941}, "start": {"column": 17, "line": 7941}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 7941}, "start": {"column": 17, "line": 7941}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 7941}, "start": {"column": 30, "line": 7941}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 7946}, "start": {"column": 18, "line": 7946}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 7946}, "start": {"column": 18, "line": 7946}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 7946}, "start": {"column": 29, "line": 7946}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 25, "line": 7948}, "start": {"column": 24, "line": 7948}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 29, "line": 7948}, "start": {"column": 28, "line": 7948}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 7956}, "start": {"column": 20, "line": 7956}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 7956}, "start": {"column": 20, "line": 7956}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 18, "line": 7960}, "start": {"column": 17, "line": 7960}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 18, "line": 7960}, "start": {"column": 17, "line": 7960}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 19, "line": 7961}, "start": {"column": 7, "line": 7961}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 17, "line": 7969}, "start": {"column": 16, "line": 7969}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 17, "line": 7969}, "start": {"column": 16, "line": 7969}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 7970}, "start": {"column": 6, "line": 7970}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 35, "line": 7982}, "start": {"column": 34, "line": 7982}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 39, "line": 7982}, "start": {"column": 38, "line": 7982}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 7996}, "start": {"column": 2, "line": 7996}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 17, "line": 8038}, "start": {"column": 16, "line": 8038}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 17, "line": 8038}, "start": {"column": 16, "line": 8038}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 8043}, "start": {"column": 15, "line": 8043}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 8043}, "start": {"column": 15, "line": 8043}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 15, "line": 8049}, "start": {"column": 14, "line": 8049}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 14, "line": 8061}, "start": {"column": 13, "line": 8061}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 24, "line": 8061}, "start": {"column": 22, "line": 8061}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 24, "line": 8061}, "start": {"column": 22, "line": 8061}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 16, "line": 8070}, "start": {"column": 15, "line": 8070}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 8070}, "start": {"column": 20, "line": 8070}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 8073}, "start": {"column": 17, "line": 8073}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 8, "line": 8086}, "start": {"column": 5, "line": 8086}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 8088}, "start": {"column": 14, "line": 8088}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 25, "line": 8088}, "start": {"column": 23, "line": 8088}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 25, "line": 8088}, "start": {"column": 23, "line": 8088}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 8095}, "start": {"column": 17, "line": 8095}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 8095}, "start": {"column": 17, "line": 8095}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 19, "line": 8096}, "start": {"column": 18, "line": 8096}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 40, "line": 8103}, "start": {"column": 39, "line": 8103}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 49, "line": 8103}, "start": {"column": 48, "line": 8103}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 8105}, "start": {"column": 26, "line": 8105}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 8106}, "start": {"column": 17, "line": 8106}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 26, "line": 8107}, "start": {"column": 24, "line": 8107}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 8107}, "start": {"column": 41, "line": 8107}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 8110}, "start": {"column": 16, "line": 8110}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 6, "line": 8114}, "start": {"column": 3, "line": 8114}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 56, "line": 8128}, "start": {"column": 55, "line": 8128}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 22, "line": 8131}, "start": {"column": 21, "line": 8131}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 8143}, "start": {"column": 18, "line": 8143}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 8143}, "start": {"column": 18, "line": 8143}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 8143}, "start": {"column": 29, "line": 8143}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 8145}, "start": {"column": 18, "line": 8145}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 14, "line": 8146}, "start": {"column": 13, "line": 8146}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 22, "line": 8160}, "start": {"column": 21, "line": 8160}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 8162}, "start": {"column": 2, "line": 8162}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 8164}, "start": {"column": 17, "line": 8164}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 28, "line": 8164}, "start": {"column": 26, "line": 8164}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 28, "line": 8164}, "start": {"column": 26, "line": 8164}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 8171}, "start": {"column": 17, "line": 8171}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 8171}, "start": {"column": 17, "line": 8171}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 8171}, "start": {"column": 28, "line": 8171}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 8173}, "start": {"column": 14, "line": 8173}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 8174}, "start": {"column": 14, "line": 8174}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 12, "line": 8183}, "start": {"column": 2, "line": 8183}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 8213}, "start": {"column": 18, "line": 8213}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 8215}, "start": {"column": 16, "line": 8215}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 27, "line": 8224}, "start": {"column": 25, "line": 8224}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 27, "line": 8224}, "start": {"column": 25, "line": 8224}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 45, "line": 8224}, "start": {"column": 38, "line": 8224}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 8226}, "start": {"column": 21, "line": 8226}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 24, "line": 8227}, "start": {"column": 22, "line": 8227}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 40, "line": 8227}, "start": {"column": 38, "line": 8227}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 8231}, "start": {"column": 18, "line": 8231}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 33, "line": 8240}, "start": {"column": 32, "line": 8240}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 33, "line": 8240}, "start": {"column": 32, "line": 8240}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 8242}, "start": {"column": 21, "line": 8242}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 24, "line": 8243}, "start": {"column": 22, "line": 8243}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 40, "line": 8243}, "start": {"column": 38, "line": 8243}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 19, "line": 8257}, "start": {"column": 18, "line": 8257}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 26, "line": 8257}, "start": {"column": 24, "line": 8257}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 26, "line": 8257}, "start": {"column": 24, "line": 8257}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 37, "line": 8257}, "start": {"column": 36, "line": 8257}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 8262}, "start": {"column": 20, "line": 8262}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 8262}, "start": {"column": 20, "line": 8262}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 20, "line": 8267}, "start": {"column": 10, "line": 8267}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 8267}, "start": {"column": 36, "line": 8267}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 52, "line": 8267}, "start": {"column": 42, "line": 8267}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 8271}, "start": {"column": 20, "line": 8271}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 8271}, "start": {"column": 28, "line": 8271}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 37, "line": 8271}, "start": {"column": 36, "line": 8271}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 42, "line": 8271}, "start": {"column": 40, "line": 8271}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 42, "line": 8271}, "start": {"column": 40, "line": 8271}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 24, "line": 8274}, "start": {"column": 22, "line": 8274}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 24, "line": 8274}, "start": {"column": 22, "line": 8274}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 8274}, "start": {"column": 32, "line": 8274}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 8275}, "start": {"column": 18, "line": 8275}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 8276}, "start": {"column": 19, "line": 8276}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 37, "line": 8276}, "start": {"column": 35, "line": 8276}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 23, "line": 8277}, "start": {"column": 22, "line": 8277}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 8277}, "start": {"column": 26, "line": 8277}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 37, "line": 8277}, "start": {"column": 35, "line": 8277}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 21, "line": 8279}, "start": {"column": 11, "line": 8279}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 8280}, "start": {"column": 20, "line": 8280}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 8280}, "start": {"column": 20, "line": 8280}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 27, "line": 8281}, "start": {"column": 25, "line": 8281}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 41, "line": 8281}, "start": {"column": 31, "line": 8281}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 23, "line": 8284}, "start": {"column": 22, "line": 8284}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 8284}, "start": {"column": 30, "line": 8284}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 39, "line": 8284}, "start": {"column": 38, "line": 8284}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 44, "line": 8284}, "start": {"column": 42, "line": 8284}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 44, "line": 8284}, "start": {"column": 42, "line": 8284}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 16, "line": 8292}, "start": {"column": 15, "line": 8292}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 22, "line": 8304}, "start": {"column": 21, "line": 8304}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 8305}, "start": {"column": 20, "line": 8305}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 19, "line": 8307}, "start": {"column": 18, "line": 8307}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 24, "line": 8307}, "start": {"column": 22, "line": 8307}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 24, "line": 8307}, "start": {"column": 22, "line": 8307}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 23, "line": 8313}, "start": {"column": 21, "line": 8313}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 23, "line": 8313}, "start": {"column": 21, "line": 8313}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 8313}, "start": {"column": 31, "line": 8313}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 8314}, "start": {"column": 17, "line": 8314}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 8315}, "start": {"column": 18, "line": 8315}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 8315}, "start": {"column": 34, "line": 8315}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 8317}, "start": {"column": 17, "line": 8317}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 8318}, "start": {"column": 17, "line": 8318}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 8321}, "start": {"column": 16, "line": 8321}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 20, "line": 8323}, "start": {"column": 9, "line": 8323}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 39, "line": 8323}, "start": {"column": 37, "line": 8323}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 54, "line": 8323}, "start": {"column": 43, "line": 8323}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8337}, "start": {"column": 17, "line": 8337}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8337}, "start": {"column": 17, "line": 8337}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 27, "line": 8340}, "start": {"column": 25, "line": 8340}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 19, "line": 8341}, "start": {"column": 8, "line": 8341}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 22, "line": 8341}, "start": {"column": 20, "line": 8341}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 22, "line": 8341}, "start": {"column": 20, "line": 8341}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 8344}, "start": {"column": 26, "line": 8344}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 18, "line": 8349}, "start": {"column": 17, "line": 8349}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 18, "line": 8349}, "start": {"column": 17, "line": 8349}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 23, "line": 8351}, "start": {"column": 21, "line": 8351}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 8353}, "start": {"column": 18, "line": 8353}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 8353}, "start": {"column": 18, "line": 8353}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 8366}, "start": {"column": 7, "line": 8366}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 8366}, "start": {"column": 18, "line": 8366}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 8366}, "start": {"column": 18, "line": 8366}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 36, "line": 8366}, "start": {"column": 35, "line": 8366}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 48, "line": 8366}, "start": {"column": 46, "line": 8366}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 48, "line": 8366}, "start": {"column": 46, "line": 8366}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 8381}, "start": {"column": 17, "line": 8381}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 20, "line": 8389}, "start": {"column": 19, "line": 8389}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 28, "line": 8389}, "start": {"column": 27, "line": 8389}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 8391}, "start": {"column": 17, "line": 8391}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 8391}, "start": {"column": 17, "line": 8391}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 8391}, "start": {"column": 28, "line": 8391}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 8392}, "start": {"column": 20, "line": 8392}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 12, "line": 8407}, "start": {"column": 2, "line": 8407}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 22, "line": 8416}, "start": {"column": 21, "line": 8416}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 16, "line": 8418}, "start": {"column": 15, "line": 8418}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 26, "line": 8418}, "start": {"column": 24, "line": 8418}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 26, "line": 8418}, "start": {"column": 24, "line": 8418}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 8422}, "start": {"column": 3, "line": 8422}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 8428}, "start": {"column": 17, "line": 8428}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 8428}, "start": {"column": 17, "line": 8428}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 8428}, "start": {"column": 28, "line": 8428}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 8429}, "start": {"column": 17, "line": 8429}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 8430}, "start": {"column": 17, "line": 8430}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 20, "line": 8433}, "start": {"column": 18, "line": 8433}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 8434}, "start": {"column": 17, "line": 8434}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 35, "line": 8440}, "start": {"column": 26, "line": 8440}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 43, "line": 8447}, "start": {"column": 34, "line": 8447}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 8456}, "start": {"column": 17, "line": 8456}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 8458}, "start": {"column": 13, "line": 8458}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 8463}, "start": {"column": 23, "line": 8463}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 16, "line": 8496}, "start": {"column": 15, "line": 8496}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 8506}, "start": {"column": 17, "line": 8506}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 8506}, "start": {"column": 17, "line": 8506}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 8506}, "start": {"column": 28, "line": 8506}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 8507}, "start": {"column": 19, "line": 8507}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 8509}, "start": {"column": 17, "line": 8509}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 8510}, "start": {"column": 17, "line": 8510}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 17, "line": 8513}, "start": {"column": 16, "line": 8513}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 26, "line": 8513}, "start": {"column": 25, "line": 8513}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 26, "line": 8513}, "start": {"column": 25, "line": 8513}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 22, "line": 8514}, "start": {"column": 21, "line": 8514}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 15, "line": 8528}, "start": {"column": 13, "line": 8528}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 15, "line": 8528}, "start": {"column": 13, "line": 8528}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 8533}, "start": {"column": 3, "line": 8533}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 28, "line": 8562}, "start": {"column": 27, "line": 8562}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 34, "line": 8562}, "start": {"column": 33, "line": 8562}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 8564}, "start": {"column": 22, "line": 8564}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 8564}, "start": {"column": 22, "line": 8564}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 8566}, "start": {"column": 17, "line": 8566}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 8571}, "start": {"column": 4, "line": 8571}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 8622}, "start": {"column": 15, "line": 8622}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 8622}, "start": {"column": 33, "line": 8622}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 8626}, "start": {"column": 16, "line": 8626}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 37, "line": 8641}, "start": {"column": 36, "line": 8641}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 8673}, "start": {"column": 18, "line": 8673}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 8693}, "start": {"column": 18, "line": 8693}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 15, "line": 9443}, "start": {"column": 13, "line": 9443}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 15, "line": 9443}, "start": {"column": 13, "line": 9443}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 9454}, "start": {"column": 24, "line": 9454}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 32, "line": 9454}, "start": {"column": 31, "line": 9454}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 25, "line": 9480}, "start": {"column": 23, "line": 9480}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 25, "line": 9480}, "start": {"column": 23, "line": 9480}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 24, "line": 9494}, "start": {"column": 23, "line": 9494}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 24, "line": 9494}, "start": {"column": 23, "line": 9494}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 19, "line": 9523}, "start": {"column": 17, "line": 9523}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 19, "line": 9523}, "start": {"column": 17, "line": 9523}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 9542}, "start": {"column": 11, "line": 9542}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 9550}, "start": {"column": 14, "line": 9550}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 16, "line": 9561}, "start": {"column": 14, "line": 9561}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 16, "line": 9561}, "start": {"column": 14, "line": 9561}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 9590}, "start": {"column": 11, "line": 9590}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 9590}, "start": {"column": 11, "line": 9590}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 9590}, "start": {"column": 22, "line": 9590}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 9590}, "start": {"column": 22, "line": 9590}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 49, "line": 9590}, "start": {"column": 47, "line": 9590}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 9602}, "start": {"column": 11, "line": 9602}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 9602}, "start": {"column": 11, "line": 9602}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 9604}, "start": {"column": 15, "line": 9604}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 17, "line": 9606}, "start": {"column": 13, "line": 9606}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 9609}, "start": {"column": 16, "line": 9609}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 9612}, "start": {"column": 11, "line": 9612}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 9623}, "start": {"column": 14, "line": 9623}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 9641}, "start": {"column": 11, "line": 9641}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 14, "line": 9647}, "start": {"column": 13, "line": 9647}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 14, "line": 9647}, "start": {"column": 13, "line": 9647}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 21, "line": 9648}, "start": {"column": 20, "line": 9648}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 28, "line": 9675}, "start": {"column": 24, "line": 9675}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 9684}, "start": {"column": 19, "line": 9684}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 9684}, "start": {"column": 19, "line": 9684}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 9684}, "start": {"column": 30, "line": 9684}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 9764}, "start": {"column": 22, "line": 9764}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 9764}, "start": {"column": 22, "line": 9764}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 9766}, "start": {"column": 20, "line": 9766}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 9766}, "start": {"column": 20, "line": 9766}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 40, "line": 9766}, "start": {"column": 37, "line": 9766}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 9778}, "start": {"column": 20, "line": 9778}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 9778}, "start": {"column": 20, "line": 9778}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 9778}, "start": {"column": 31, "line": 9778}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 30, "line": 9788}, "start": {"column": 29, "line": 9788}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 30, "line": 9788}, "start": {"column": 29, "line": 9788}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 9800}, "start": {"column": 22, "line": 9800}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 9800}, "start": {"column": 22, "line": 9800}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 9802}, "start": {"column": 20, "line": 9802}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 9802}, "start": {"column": 20, "line": 9802}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 40, "line": 9802}, "start": {"column": 37, "line": 9802}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 9810}, "start": {"column": 20, "line": 9810}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 9810}, "start": {"column": 20, "line": 9810}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 9810}, "start": {"column": 31, "line": 9810}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 9820}, "start": {"column": 22, "line": 9820}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 9820}, "start": {"column": 22, "line": 9820}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 9828}, "start": {"column": 20, "line": 9828}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 9828}, "start": {"column": 20, "line": 9828}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 9828}, "start": {"column": 31, "line": 9828}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 30, "line": 9830}, "start": {"column": 16, "line": 9830}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9832}, "start": {"column": 23, "line": 9832}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 9854}, "start": {"column": 19, "line": 9854}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 9854}, "start": {"column": 19, "line": 9854}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 9854}, "start": {"column": 30, "line": 9854}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 9858}, "start": {"column": 20, "line": 9858}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 9858}, "start": {"column": 20, "line": 9858}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 40, "line": 9858}, "start": {"column": 37, "line": 9858}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9859}, "start": {"column": 23, "line": 9859}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 9862}, "start": {"column": 12, "line": 9862}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 9862}, "start": {"column": 12, "line": 9862}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 9863}, "start": {"column": 15, "line": 9863}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 39, "line": 9875}, "start": {"column": 37, "line": 9875}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 9881}, "start": {"column": 20, "line": 9881}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 9881}, "start": {"column": 20, "line": 9881}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 40, "line": 9881}, "start": {"column": 37, "line": 9881}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9882}, "start": {"column": 23, "line": 9882}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 9890}, "start": {"column": 12, "line": 9890}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 9890}, "start": {"column": 12, "line": 9890}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 9891}, "start": {"column": 15, "line": 9891}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 39, "line": 9897}, "start": {"column": 37, "line": 9897}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 35, "line": 9918}, "start": {"column": 33, "line": 9918}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 47, "line": 9927}, "start": {"column": 45, "line": 9927}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 48, "line": 10002}, "start": {"column": 46, "line": 10002}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 10081}, "start": {"column": 19, "line": 10081}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 10081}, "start": {"column": 19, "line": 10081}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 45, "line": 10081}, "start": {"column": 44, "line": 10081}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 45, "line": 10081}, "start": {"column": 44, "line": 10081}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 10088}, "start": {"column": 20, "line": 10088}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 23, "line": 10090}, "start": {"column": 21, "line": 10090}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 23, "line": 10090}, "start": {"column": 21, "line": 10090}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 10109}, "start": {"column": 19, "line": 10109}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 10109}, "start": {"column": 19, "line": 10109}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 10127}, "start": {"column": 19, "line": 10127}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 10127}, "start": {"column": 19, "line": 10127}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 40, "line": 10135}, "start": {"column": 39, "line": 10135}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 10155}, "start": {"column": 4, "line": 10155}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 28, "line": 10157}, "start": {"column": 21, "line": 10157}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 10173}, "start": {"column": 4, "line": 10173}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 30, "line": 10175}, "start": {"column": 21, "line": 10175}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 10180}, "start": {"column": 4, "line": 10180}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 30, "line": 10182}, "start": {"column": 21, "line": 10182}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 10193}, "start": {"column": 4, "line": 10193}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 31, "line": 10195}, "start": {"column": 29, "line": 10195}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 31, "line": 10195}, "start": {"column": 29, "line": 10195}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 50, "line": 10195}, "start": {"column": 48, "line": 10195}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 50, "line": 10195}, "start": {"column": 48, "line": 10195}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 22, "line": 10214}, "start": {"column": 20, "line": 10214}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 22, "line": 10214}, "start": {"column": 20, "line": 10214}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 42, "line": 10214}, "start": {"column": 40, "line": 10214}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 42, "line": 10214}, "start": {"column": 40, "line": 10214}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 21, "line": 10216}, "start": {"column": 19, "line": 10216}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 21, "line": 10216}, "start": {"column": 19, "line": 10216}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 40, "line": 10216}, "start": {"column": 38, "line": 10216}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 40, "line": 10216}, "start": {"column": 38, "line": 10216}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 10220}, "start": {"column": 19, "line": 10220}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 10220}, "start": {"column": 19, "line": 10220}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 30, "line": 10225}, "start": {"column": 28, "line": 10225}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 30, "line": 10225}, "start": {"column": 28, "line": 10225}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 44, "line": 10225}, "start": {"column": 41, "line": 10225}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 42, "line": 10231}, "start": {"column": 41, "line": 10231}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 42, "line": 10231}, "start": {"column": 41, "line": 10231}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 31, "line": 10240}, "start": {"column": 29, "line": 10240}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 31, "line": 10240}, "start": {"column": 29, "line": 10240}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 50, "line": 10240}, "start": {"column": 48, "line": 10240}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 50, "line": 10240}, "start": {"column": 48, "line": 10240}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 40, "line": 10244}, "start": {"column": 39, "line": 10244}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 40, "line": 10244}, "start": {"column": 39, "line": 10244}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 31, "line": 10306}, "start": {"column": 29, "line": 10306}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 31, "line": 10306}, "start": {"column": 29, "line": 10306}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 50, "line": 10306}, "start": {"column": 48, "line": 10306}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 50, "line": 10306}, "start": {"column": 48, "line": 10306}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 10309}, "start": {"column": 4, "line": 10309}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 26, "line": 10362}, "start": {"column": 25, "line": 10362}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 38, "line": 10362}, "start": {"column": 37, "line": 10362}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 10363}, "start": {"column": 15, "line": 10363}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 10363}, "start": {"column": 15, "line": 10363}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 33, "line": 10363}, "start": {"column": 31, "line": 10363}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 33, "line": 10363}, "start": {"column": 31, "line": 10363}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 63, "line": 10363}, "start": {"column": 61, "line": 10363}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 10366}, "start": {"column": 29, "line": 10366}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 10375}, "start": {"column": 7, "line": 10375}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 10424}, "start": {"column": 19, "line": 10424}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 10429}, "start": {"column": 18, "line": 10429}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 10458}, "start": {"column": 13, "line": 10458}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 10479}, "start": {"column": 11, "line": 10479}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 10483}, "start": {"column": 11, "line": 10483}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 10483}, "start": {"column": 11, "line": 10483}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 10483}, "start": {"column": 22, "line": 10483}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 10483}, "start": {"column": 22, "line": 10483}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 49, "line": 10483}, "start": {"column": 47, "line": 10483}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 10487}, "start": {"column": 11, "line": 10487}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 10487}, "start": {"column": 11, "line": 10487}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 10489}, "start": {"column": 15, "line": 10489}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 17, "line": 10491}, "start": {"column": 13, "line": 10491}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 10494}, "start": {"column": 16, "line": 10494}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 10497}, "start": {"column": 11, "line": 10497}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 10549}, "start": {"column": 17, "line": 10549}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 10549}, "start": {"column": 17, "line": 10549}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 37, "line": 10549}, "start": {"column": 34, "line": 10549}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 10573}, "start": {"column": 2, "line": 10573}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 46, "line": 12213}, "start": {"column": 45, "line": 12213}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 55, "line": 12213}, "start": {"column": 53, "line": 12213}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 29, "line": 12216}, "start": {"column": 27, "line": 12216}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 29, "line": 12216}, "start": {"column": 27, "line": 12216}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 57, "line": 12219}, "start": {"column": 56, "line": 12219}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 39, "line": 12222}, "start": {"column": 37, "line": 12222}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 12226}, "start": {"column": 15, "line": 12226}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 12272}, "start": {"column": 4, "line": 12272}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 12295}, "start": {"column": 26, "line": 12295}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 12299}, "start": {"column": 25, "line": 12299}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12307}, "start": {"column": 1, "line": 12307}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12311}, "start": {"column": 1, "line": 12311}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12331}, "start": {"column": 1, "line": 12331}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 23, "line": 12335}, "start": {"column": 14, "line": 12335}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12353}, "start": {"column": 1, "line": 12353}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 37, "line": 12370}, "start": {"column": 36, "line": 12370}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12381}, "start": {"column": 1, "line": 12381}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 12390}, "start": {"column": 4, "line": 12390}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 40, "line": 12408}, "start": {"column": 39, "line": 12408}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 14, "line": 12409}, "start": {"column": 12, "line": 12409}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 14, "line": 12409}, "start": {"column": 12, "line": 12409}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 12409}, "start": {"column": 30, "line": 12409}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 51, "line": 12409}, "start": {"column": 49, "line": 12409}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 13, "line": 12413}, "start": {"column": 12, "line": 12413}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 12425}, "start": {"column": 4, "line": 12425}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12432}, "start": {"column": 1, "line": 12432}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 12635}, "start": {"column": 26, "line": 12635}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12650}, "start": {"column": 1, "line": 12650}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 12655}, "start": {"column": 1, "line": 12655}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 12668}, "start": {"column": 20, "line": 12668}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 12668}, "start": {"column": 20, "line": 12668}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12685}, "start": {"column": 1, "line": 12685}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 12698}, "start": {"column": 1, "line": 12698}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 12751}, "start": {"column": 26, "line": 12751}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 50, "line": 12824}, "start": {"column": 48, "line": 12824}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 12826}, "start": {"column": 18, "line": 12826}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 12830}, "start": {"column": 5, "line": 12830}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 41, "line": 12838}, "start": {"column": 40, "line": 12838}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 18, "line": 12857}, "start": {"column": 17, "line": 12857}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 12859}, "start": {"column": 40, "line": 12859}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 12868}, "start": {"column": 36, "line": 12868}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 12869}, "start": {"column": 15, "line": 12869}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 12869}, "start": {"column": 15, "line": 12869}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 36, "line": 12869}, "start": {"column": 35, "line": 12869}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 12869}, "start": {"column": 40, "line": 12869}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 12873}, "start": {"column": 23, "line": 12873}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 12941}, "start": {"column": 4, "line": 12941}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 13079}, "start": {"column": 4, "line": 13079}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 13116}, "start": {"column": 4, "line": 13116}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 13118}, "start": {"column": 20, "line": 13118}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 26, "line": 13134}, "start": {"column": 14, "line": 13134}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 13159}, "start": {"column": 4, "line": 13159}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 13161}, "start": {"column": 20, "line": 13161}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 13187}, "start": {"column": 1, "line": 13187}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 13211}, "start": {"column": 18, "line": 13211}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 49, "line": 13253}, "start": {"column": 48, "line": 13253}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 63, "line": 13253}, "start": {"column": 62, "line": 13253}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 46, "line": 13259}, "start": {"column": 44, "line": 13259}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 13282}, "start": {"column": 19, "line": 13282}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 13282}, "start": {"column": 19, "line": 13282}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 13395}, "start": {"column": 18, "line": 13395}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 13395}, "start": {"column": 18, "line": 13395}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 62, "line": 13395}, "start": {"column": 61, "line": 13395}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 13399}, "start": {"column": 41, "line": 13399}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 20, "line": 13401}, "start": {"column": 19, "line": 13401}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 33, "line": 13401}, "start": {"column": 32, "line": 13401}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 48, "line": 13401}, "start": {"column": 46, "line": 13401}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 38, "line": 13421}, "start": {"column": 37, "line": 13421}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 52, "line": 13421}, "start": {"column": 51, "line": 13421}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 13423}, "start": {"column": 17, "line": 13423}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 13423}, "start": {"column": 17, "line": 13423}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 13423}, "start": {"column": 35, "line": 13423}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 13426}, "start": {"column": 43, "line": 13426}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 36, "line": 13434}, "start": {"column": 35, "line": 13434}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 53, "line": 13434}, "start": {"column": 52, "line": 13434}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 25, "line": 13436}, "start": {"column": 23, "line": 13436}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 25, "line": 13436}, "start": {"column": 23, "line": 13436}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 24, "line": 13447}, "start": {"column": 23, "line": 13447}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 36, "line": 13451}, "start": {"column": 35, "line": 13451}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 21, "line": 13453}, "start": {"column": 19, "line": 13453}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 21, "line": 13453}, "start": {"column": 19, "line": 13453}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 40, "line": 13454}, "start": {"column": 39, "line": 13454}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 25, "line": 13461}, "start": {"column": 24, "line": 13461}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 50, "line": 13473}, "start": {"column": 49, "line": 13473}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 13474}, "start": {"column": 22, "line": 13474}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 13478}, "start": {"column": 20, "line": 13478}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 13478}, "start": {"column": 20, "line": 13478}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 13487}, "start": {"column": 18, "line": 13487}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 13489}, "start": {"column": 23, "line": 13489}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 43, "line": 13508}, "start": {"column": 42, "line": 13508}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 49, "line": 13526}, "start": {"column": 48, "line": 13526}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 49, "line": 13526}, "start": {"column": 48, "line": 13526}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 45, "line": 13534}, "start": {"column": 44, "line": 13534}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 54, "line": 13534}, "start": {"column": 52, "line": 13534}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 28, "line": 13537}, "start": {"column": 26, "line": 13537}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 28, "line": 13537}, "start": {"column": 26, "line": 13537}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 56, "line": 13540}, "start": {"column": 55, "line": 13540}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 44, "line": 13569}, "start": {"column": 43, "line": 13569}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 53, "line": 13569}, "start": {"column": 51, "line": 13569}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 27, "line": 13572}, "start": {"column": 25, "line": 13572}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 27, "line": 13572}, "start": {"column": 25, "line": 13572}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 55, "line": 13575}, "start": {"column": 54, "line": 13575}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 13576}, "start": {"column": 32, "line": 13576}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 13596}, "start": {"column": 13, "line": 13596}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 13596}, "start": {"column": 13, "line": 13596}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 45, "line": 13599}, "start": {"column": 44, "line": 13599}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 38, "line": 13601}, "start": {"column": 37, "line": 13601}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 13605}, "start": {"column": 18, "line": 13605}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 13605}, "start": {"column": 18, "line": 13605}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 13608}, "start": {"column": 24, "line": 13608}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 13609}, "start": {"column": 24, "line": 13609}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 13613}, "start": {"column": 14, "line": 13613}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 13613}, "start": {"column": 14, "line": 13613}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 13637}, "start": {"column": 19, "line": 13637}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 13643}, "start": {"column": 19, "line": 13643}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 13643}, "start": {"column": 19, "line": 13643}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 13649}, "start": {"column": 28, "line": 13649}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 13695}, "start": {"column": 36, "line": 13695}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 27, "line": 13723}, "start": {"column": 25, "line": 13723}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 57, "line": 13778}, "start": {"column": 56, "line": 13778}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 13800}, "start": {"column": 9, "line": 13800}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 57, "line": 13837}, "start": {"column": 56, "line": 13837}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 57, "line": 13837}, "start": {"column": 56, "line": 13837}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 13868}, "start": {"column": 9, "line": 13868}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 13884}, "start": {"column": 12, "line": 13884}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 13884}, "start": {"column": 12, "line": 13884}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 17, "line": 13885}, "start": {"column": 16, "line": 13885}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 22, "line": 13885}, "start": {"column": 20, "line": 13885}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 17, "line": 13886}, "start": {"column": 16, "line": 13886}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 22, "line": 13886}, "start": {"column": 20, "line": 13886}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 13894}, "start": {"column": 24, "line": 13894}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 13920}, "start": {"column": 30, "line": 13920}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 11, "line": 13943}, "start": {"column": 10, "line": 13943}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 13948}, "start": {"column": 17, "line": 13948}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 13948}, "start": {"column": 17, "line": 13948}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 27, "line": 13948}, "start": {"column": 24, "line": 13948}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 13951}, "start": {"column": 20, "line": 13951}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 28, "line": 13975}, "start": {"column": 26, "line": 13975}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 28, "line": 13975}, "start": {"column": 26, "line": 13975}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 36, "line": 13980}, "start": {"column": 35, "line": 13980}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 37, "line": 13994}, "start": {"column": 35, "line": 13994}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 29, "line": 14004}, "start": {"column": 28, "line": 14004}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 29, "line": 14004}, "start": {"column": 28, "line": 14004}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 26, "line": 14137}, "start": {"column": 25, "line": 14137}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 26, "line": 14137}, "start": {"column": 25, "line": 14137}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 14158}, "start": {"column": 13, "line": 14158}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}], "source": "/* flex - tool to generate fast lexical analyzers */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n *\n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#ifndef lint\nchar copyright[] =\n\"@(#) Copyright (c) 1990 The Regents of the University of California.\\n\\\n All rights reserved.\\n\";\n#endif /* not lint */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n#include \"flexdef.h\"\n#include \"version.h\"\n#include <ctype.h> \n#include \"parse.h\"\n\nstatic char flex_version[] = FLEX_VERSION;\n\n\n/* declare functions that have forward references */\n\nvoid flexinit PROTO((int, char**));\nvoid readin PROTO((void));\nvoid set_up_initial_allocations PROTO((void));\n\n#ifdef NEED_ARGV_FIXUP\nextern void argv_fixup PROTO((int *, char ***));\n#endif\n\n\n/* these globals are all defined and commented in flexdef.h */\nint printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;\nint interactive, caseins, lex_compat, do_yylineno, useecs, fulltbl, usemecs;\nint fullspd, gen_line_dirs, performance_report, backing_up_report;\nint C_plus_plus, long_align, use_read, yytext_is_array, do_yywrap, csize;\nint yymore_used, reject, real_reject, continued_action, in_rule;\nint yymore_really_used, reject_really_used;\nint datapos, dataline, linenum, out_linenum;\nFILE *skelfile = NULL;\n\n/* ### add for testing ### */\nFILE *err = NULL;\n/* ####################### */\n\nint skel_ind = 0;\nchar *action_array;\nint action_size, defs1_offset, prolog_offset, action_offset, action_index;\nchar *infilename = NULL, *outfilename = NULL;\nint did_outfilename;\nchar *prefix, *yyclass;\nint do_stdinit, use_stdout;\nint onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];\nint onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;\nint current_mns, current_max_rules;\nint num_rules, num_eof_rules, default_rule, lastnfa;\nint *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;\nint *accptnum, *assoc_rule, *state_type;\nint *rule_type, *rule_linenum, *rule_useful;\nint current_state_type;\nint variable_trailing_context_rules;\nint numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];\nint protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];\nint numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];\nint tecbck[CSIZE + 1];\nint lastsc, *scset, *scbol, *scxclu, *sceof;\nint current_max_scs;\nchar **scname;\nint current_max_dfa_size, current_max_xpairs;\nint current_max_template_xpairs, current_max_dfas;\nint lastdfa, *nxt, *chk, *tnxt;\nint *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;\nunion dfaacc_union *dfaacc;\nint *accsiz, *dhash, numas;\nint numsnpairs, jambase, jamstate;\nint lastccl, *cclmap, *ccllen, *cclng, cclreuse;\nint current_maxccls, current_max_ccl_tbl_size;\nChar *ccltbl;\nchar nmstr[MAXLINE];\nint sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;\nint tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;\nint num_backing_up, bol_needed;\nFILE *backing_up_file;\nint end_of_buffer_state;\nchar **input_files;\nint num_input_files;\n\n/* Make sure program_name is initialized so we don't crash if writing\n * out an error message before getting the program name from argv[0].\n */\nchar *program_name = \"flex\";\n\n#ifndef SHORT_FILE_NAMES\nstatic char *outfile_template = \"lex.%s.%s\";\nstatic char *backing_name = \"lex.backup\";\n#else\nstatic char *outfile_template = \"lex%s.%s\";\nstatic char *backing_name = \"lex.bck\";\n#endif\n\n#ifdef THINK_C\n#include <console.h>\n#endif\n\n#ifdef MS_DOS\nextern unsigned _stklen = 16384;\n#endif\n\nstatic char outfile_path[MAXLINE];\nstatic int outfile_created = 0;\nstatic char *skelname = NULL;\n\n\nint main( argc, argv )\nint argc;\nchar **argv;\n\t{\n\tint i;\n\n#ifdef THINK_C\n\targc = ccommand( &argv );\n#endif\n#ifdef NEED_ARGV_FIXUP\n\targv_fixup( &argc, &argv );\n#endif\n\n/* ### add for testing ### */\n        if(--argc >0){\n                err = fopen( *++argv, \"w\" );\n                --argv; ++argc;\n        }\n/* ####################### */\n\n\tflexinit( argc, argv );\n\n\treadin();\n\n\tntod();\n\n\tfor ( i = 1; i <= num_rules; ++i )\n\t\tif ( ! rule_useful[i] && i != default_rule )\n\t\t\tline_warning( _( \"rule cannot be matched\" ),\n\t\t\t\t\trule_linenum[i] );\n\n\tif ( spprdflt && ! reject && rule_useful[default_rule] )\n\t\tline_warning(\n\t\t\t_( \"-s option given but default rule can be matched\" ),\n\t\t\trule_linenum[default_rule] );\n\n\t/* Generate the C state transition tables from the DFA. */\n\tmake_tables();\n\n\t/* Note, flexend does not return.  It exits with its argument\n\t * as status.\n\t */\n\tflexend( 0 );\n\n\treturn 0;\t/* keep compilers/lint happy */\n\t}\n\n\n/* check_options - check user-specified options */\n\nvoid check_options()\n\t{\n\tint i;\n\n\tif ( lex_compat )\n\t\t{\n\t\tif ( C_plus_plus )\n\t\t\tflexerror( _( \"Can't use -+ with -l option\" ) );\n\n\t\tif ( fulltbl || fullspd )\n\t\t\tflexerror( _( \"Can't use -f or -F with -l option\" ) );\n\n\t\t/* Don't rely on detecting use of yymore() and REJECT,\n\t\t * just assume they'll be used.\n\t\t */\n\t\tyymore_really_used = reject_really_used = true;\n\n\t\tyytext_is_array = true;\n\t\tdo_yylineno = true;\n\t\tuse_read = false;\n\t\t}\n\n\tif ( do_yylineno )\n\t\t/* This should really be \"maintain_backup_tables = true\" */\n\t\treject_really_used = true;\n\n\tif ( csize == unspecified )\n\t\t{\n\t\tif ( (fulltbl || fullspd) && ! useecs )\n\t\t\tcsize = DEFAULT_CSIZE;\n\t\telse\n\t\t\tcsize = CSIZE;\n\t\t}\n\n\tif ( interactive == unspecified )\n\t\t{\n\t\tif ( fulltbl || fullspd )\n\t\t\tinteractive = false;\n\t\telse\n\t\t\tinteractive = true;\n\t\t}\n\n\tif ( fulltbl || fullspd )\n\t\t{\n\t\tif ( usemecs )\n\t\t\tflexerror(\n\t\t\t_( \"-Cf/-CF and -Cm don't make sense together\" ) );\n\n\t\tif ( interactive )\n\t\t\tflexerror( _( \"-Cf/-CF and -I are incompatible\" ) );\n\n\t\tif ( lex_compat )\n\t\t\tflexerror(\n\t\t_( \"-Cf/-CF are incompatible with lex-compatibility mode\" ) );\n\n\t\tif ( do_yylineno )\n\t\t\tflexerror(\n\t\t\t_( \"-Cf/-CF and %option yylineno are incompatible\" ) );\n\n\t\tif ( fulltbl && fullspd )\n\t\t\tflexerror( _( \"-Cf and -CF are mutually exclusive\" ) );\n\t\t}\n\n\tif ( C_plus_plus && fullspd )\n\t\tflexerror( _( \"Can't use -+ with -CF option\" ) );\n\n\tif ( C_plus_plus && yytext_is_array )\n\t\t{\n\t\twarn( _( \"%array incompatible with -+ option\" ) );\n\t\tyytext_is_array = false;\n\t\t}\n\n\tif ( useecs )\n\t\t{ /* Set up doubly-linked equivalence classes. */\n\n\t\t/* We loop all the way up to csize, since ecgroup[csize] is\n\t\t * the position used for NUL characters.\n\t\t */\n\t\tecgroup[1] = NIL;\n\n\t\tfor ( i = 2; i <= csize; ++i )\n\t\t\t{\n\t\t\tecgroup[i] = i - 1;\n\t\t\tnextecm[i - 1] = i;\n\t\t\t}\n\n\t\tnextecm[csize] = NIL;\n\t\t}\n\n\telse\n\t\t{\n\t\t/* Put everything in its own equivalence class. */\n\t\tfor ( i = 1; i <= csize; ++i )\n\t\t\t{\n\t\t\tecgroup[i] = i;\n\t\t\tnextecm[i] = BAD_SUBSCRIPT;\t/* to catch errors */\n\t\t\t}\n\t\t}\n\n\tif ( ! use_stdout )\n\t\t{\n\t\tFILE *prev_stdout;\n\n\t\tif ( ! did_outfilename )\n\t\t\t{\n\t\t\tchar *suffix;\n\n\t\t\tif ( C_plus_plus )\n\t\t\t\tsuffix = \"cc\";\n\t\t\telse\n\t\t\t\tsuffix = \"c\";\n\n\t\t\tsprintf( outfile_path, outfile_template,\n\t\t\t\tprefix, suffix );\n\n\t\t\toutfilename = outfile_path;\n\t\t\t}\n\n\t\tprev_stdout = freopen( outfilename, \"w\", stdout );\n\n\t\tif ( prev_stdout == NULL )\n\t\t\tlerrsf( _( \"could not create %s\" ), outfilename );\n\n\t\toutfile_created = 1;\n\t\t}\n\n\tif ( skelname && (skelfile = fopen( skelname, \"r\" )) == NULL )\n\t\tlerrsf( _( \"can't open skeleton file %s\" ), skelname );\n\n\tif ( strcmp( prefix, \"yy\" ) )\n\t\t{\n#define GEN_PREFIX(name) out_str3( \"#define yy%s %s%s\\n\", name, prefix, name )\n\t\tif ( C_plus_plus )\n\t\t\tGEN_PREFIX( \"FlexLexer\" );\n\t\telse\n\t\t\t{\n\t\t\tGEN_PREFIX( \"_create_buffer\" );\n\t\t\tGEN_PREFIX( \"_delete_buffer\" );\n\t\t\tGEN_PREFIX( \"_scan_buffer\" );\n\t\t\tGEN_PREFIX( \"_scan_string\" );\n\t\t\tGEN_PREFIX( \"_scan_bytes\" );\n\t\t\tGEN_PREFIX( \"_flex_debug\" );\n\t\t\tGEN_PREFIX( \"_init_buffer\" );\n\t\t\tGEN_PREFIX( \"_flush_buffer\" );\n\t\t\tGEN_PREFIX( \"_load_buffer_state\" );\n\t\t\tGEN_PREFIX( \"_switch_to_buffer\" );\n\t\t\tGEN_PREFIX( \"in\" );\n\t\t\tGEN_PREFIX( \"leng\" );\n\t\t\tGEN_PREFIX( \"lex\" );\n\t\t\tGEN_PREFIX( \"out\" );\n\t\t\tGEN_PREFIX( \"restart\" );\n\t\t\tGEN_PREFIX( \"text\" );\n\n\t\t\tif ( do_yylineno )\n\t\t\t\tGEN_PREFIX( \"lineno\" );\n\t\t\t}\n\n\t\tif ( do_yywrap )\n\t\t\tGEN_PREFIX( \"wrap\" );\n\n\t\toutn( \"\" );\n\t\t}\n\n\tif ( did_outfilename )\n\t\tline_directive_out( stdout, 0 );\n\n\tskelout();\n\t}\n\n\n/* flexend - terminate flex\n *\n * note\n *    This routine does not return.\n */\n\nvoid flexend( exit_status )\nint exit_status;\n\n\t{\n\tint tblsiz;\n\tint unlink();\n\n\tif ( skelfile != NULL )\n\t\t{\n\t\tif ( ferror( skelfile ) )\n\t\t\tlerrsf( _( \"input error reading skeleton file %s\" ),\n\t\t\t\tskelname );\n\n\t\telse if ( fclose( skelfile ) )\n\t\t\tlerrsf( _( \"error closing skeleton file %s\" ),\n\t\t\t\tskelname );\n\t\t}\n\n\tif ( exit_status != 0 && outfile_created )\n\t\t{\n\t\tif ( ferror( stdout ) )\n\t\t\tlerrsf( _( \"error writing output file %s\" ),\n\t\t\t\toutfilename );\n\n\t\telse if ( fclose( stdout ) )\n\t\t\tlerrsf( _( \"error closing output file %s\" ),\n\t\t\t\toutfilename );\n\n\t\telse if ( unlink( outfilename ) )\n\t\t\tlerrsf( _( \"error deleting output file %s\" ),\n\t\t\t\toutfilename );\n\t\t}\n\n\tif ( backing_up_report && backing_up_file )\n\t\t{\n\t\tif ( num_backing_up == 0 )\n\t\t\tfprintf( backing_up_file, _( \"No backing up.\\n\" ) );\n\t\telse if ( fullspd || fulltbl )\n\t\t\tfprintf( backing_up_file,\n\t\t\t\t_( \"%d backing up (non-accepting) states.\\n\" ),\n\t\t\t\tnum_backing_up );\n\t\telse\n\t\t\tfprintf( backing_up_file,\n\t\t\t\t_( \"Compressed tables always back up.\\n\" ) );\n\n\t\tif ( ferror( backing_up_file ) )\n\t\t\tlerrsf( _( \"error writing backup file %s\" ),\n\t\t\t\tbacking_name );\n\n\t\telse if ( fclose( backing_up_file ) )\n\t\t\tlerrsf( _( \"error closing backup file %s\" ),\n\t\t\t\tbacking_name );\n\t\t}\n\n\tif ( printstats )\n\t\t{\n\t\tfprintf( err, _( \"%s version %s usage statistics:\\n\" ),\n\t\t\tprogram_name, flex_version );\n\n\t\tfprintf( err, _( \"  scanner options: -\" ) );\n\n\t\tif ( C_plus_plus )\n\t\t\tputc( '+', err );\n\t\tif ( backing_up_report )\n\t\t\tputc( 'b', err );\n\t\tif ( ddebug )\n\t\t\tputc( 'd', err );\n\t\tif ( caseins )\n\t\t\tputc( 'i', err );\n\t\tif ( lex_compat )\n\t\t\tputc( 'l', err );\n\t\tif ( performance_report > 0 )\n\t\t\tputc( 'p', err );\n\t\tif ( performance_report > 1 )\n\t\t\tputc( 'p', err );\n\t\tif ( spprdflt )\n\t\t\tputc( 's', err );\n\t\tif ( use_stdout )\n\t\t\tputc( 't', err );\n\t\tif ( printstats )\n\t\t\tputc( 'v', err );\t/* always true! */\n\t\tif ( nowarn )\n\t\t\tputc( 'w', err );\n\t\tif ( interactive == false )\n\t\t\tputc( 'B', err );\n\t\tif ( interactive == true )\n\t\t\tputc( 'I', err );\n\t\tif ( ! gen_line_dirs )\n\t\t\tputc( 'L', err );\n\t\tif ( trace )\n\t\t\tputc( 'T', err );\n\n\t\tif ( csize == unspecified )\n\t\t\t/* We encountered an error fairly early on, so csize\n\t\t\t * never got specified.  Define it now, to prevent\n\t\t\t * bogus table sizes being written out below.\n\t\t\t */\n\t\t\tcsize = 256;\n\n\t\tif ( csize == 128 )\n\t\t\tputc( '7', err );\n\t\telse\n\t\t\tputc( '8', err );\n\n\t\tfprintf( err, \" -C\" );\n\n\t\tif ( long_align )\n\t\t\tputc( 'a', err );\n\t\tif ( fulltbl )\n\t\t\tputc( 'f', err );\n\t\tif ( fullspd )\n\t\t\tputc( 'F', err );\n\t\tif ( useecs )\n\t\t\tputc( 'e', err );\n\t\tif ( usemecs )\n\t\t\tputc( 'm', err );\n\t\tif ( use_read )\n\t\t\tputc( 'r', err );\n\n\t\tif ( did_outfilename )\n\t\t\tfprintf( err, \" -o%s\", outfilename );\n\n\t\tif ( skelname )\n\t\t\tfprintf( err, \" -S%s\", skelname );\n\n\t\tif ( strcmp( prefix, \"yy\" ) )\n\t\t\tfprintf( err, \" -P%s\", prefix );\n\n\t\tputc( '\\n', err );\n\n\t\tfprintf( err, _( \"  %d/%d NFA states\\n\" ),\n\t\t\tlastnfa, current_mns );\n\t\tfprintf( err, _( \"  %d/%d DFA states (%d words)\\n\" ),\n\t\t\tlastdfa, current_max_dfas, totnst );\n\t\tfprintf( err, _( \"  %d rules\\n\" ),\n\t\tnum_rules + num_eof_rules - 1 /* - 1 for def. rule */ );\n\n\t\tif ( num_backing_up == 0 )\n\t\t\tfprintf( err, _( \"  No backing up\\n\" ) );\n\t\telse if ( fullspd || fulltbl )\n\t\t\tfprintf( err,\n\t\t\t_( \"  %d backing-up (non-accepting) states\\n\" ),\n\t\t\t\tnum_backing_up );\n\t\telse\n\t\t\tfprintf( err,\n\t\t\t\t_( \"  Compressed tables always back-up\\n\" ) );\n\n\t\tif ( bol_needed )\n\t\t\tfprintf( err,\n\t\t\t\t_( \"  Beginning-of-line patterns used\\n\" ) );\n\n\t\tfprintf( err, _( \"  %d/%d start conditions\\n\" ), lastsc,\n\t\t\tcurrent_max_scs );\n\t\tfprintf( err,\n\t\t\t_( \"  %d epsilon states, %d double epsilon states\\n\" ),\n\t\t\tnumeps, eps2 );\n\n\t\tif ( lastccl == 0 )\n\t\t\tfprintf( err, _( \"  no character classes\\n\" ) );\n\t\telse\n\t\t\tfprintf( err,\n_( \"  %d/%d character classes needed %d/%d words of storage, %d reused\\n\" ),\n\t\t\t\tlastccl, current_maxccls,\n\t\t\t\tcclmap[lastccl] + ccllen[lastccl],\n\t\t\t\tcurrent_max_ccl_tbl_size, cclreuse );\n\n\t\tfprintf( err, _( \"  %d state/nextstate pairs created\\n\" ),\n\t\t\tnumsnpairs );\n\t\tfprintf( err, _( \"  %d/%d unique/duplicate transitions\\n\" ),\n\t\t\tnumuniq, numdup );\n\n\t\tif ( fulltbl )\n\t\t\t{\n\t\t\ttblsiz = lastdfa * numecs;\n\t\t\tfprintf( err, _( \"  %d table entries\\n\" ), tblsiz );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\ttblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;\n\n\t\t\tfprintf( err,\n\t\t\t\t_( \"  %d/%d base-def entries created\\n\" ),\n\t\t\t\tlastdfa + numtemps, current_max_dfas );\n\t\t\tfprintf( err,\n\t\t\t_( \"  %d/%d (peak %d) nxt-chk entries created\\n\" ),\n\t\t\t\ttblend, current_max_xpairs, peakpairs );\n\t\t\tfprintf( err,\n\t\t_( \"  %d/%d (peak %d) template nxt-chk entries created\\n\" ),\n\t\t\t\tnumtemps * nummecs,\n\t\t\t\tcurrent_max_template_xpairs,\n\t\t\t\tnumtemps * numecs );\n\t\t\tfprintf( err, _( \"  %d empty table entries\\n\" ),\n\t\t\t\tnummt );\n\t\t\tfprintf( err, _( \"  %d protos created\\n\" ),\n\t\t\t\tnumprots );\n\t\t\tfprintf( err,\n\t\t\t\t_( \"  %d templates created, %d uses\\n\" ),\n\t\t\t\tnumtemps, tmpuses );\n\t\t\t}\n\n\t\tif ( useecs )\n\t\t\t{\n\t\t\ttblsiz = tblsiz + csize;\n\t\t\tfprintf( err,\n\t\t\t\t_( \"  %d/%d equivalence classes created\\n\" ),\n\t\t\t\tnumecs, csize );\n\t\t\t}\n\n\t\tif ( usemecs )\n\t\t\t{\n\t\t\ttblsiz = tblsiz + numecs;\n\t\t\tfprintf( err,\n\t\t\t_( \"  %d/%d meta-equivalence classes created\\n\" ),\n\t\t\t\tnummecs, csize );\n\t\t\t}\n\n\t\tfprintf( err,\n\t\t_( \"  %d (%d saved) hash collisions, %d DFAs equal\\n\" ),\n\t\t\thshcol, hshsave, dfaeql );\n\t\tfprintf( err, _( \"  %d sets of reallocations needed\\n\" ),\n\t\t\tnum_reallocs );\n\t\tfprintf( err, _( \"  %d total table entries needed\\n\" ),\n\t\t\ttblsiz );\n\t\t}\n\n\texit( exit_status );\n\t}\n\n\n/* flexinit - initialize flex */\n\nvoid flexinit( argc, argv )\nint argc;\nchar **argv;\n\t{\n\tint i, sawcmpflag;\n\tchar *arg;\n\n\tprintstats = syntaxerror = trace = spprdflt = caseins = false;\n\tlex_compat = C_plus_plus = backing_up_report = ddebug = fulltbl = false;\n\tfullspd = long_align = nowarn = yymore_used = continued_action = false;\n\tdo_yylineno = yytext_is_array = in_rule = reject = do_stdinit = false;\n\tyymore_really_used = reject_really_used = unspecified;\n\tinteractive = csize = unspecified;\n\tdo_yywrap = gen_line_dirs = usemecs = useecs = true;\n\tperformance_report = 0;\n\tdid_outfilename = 0;\n\tprefix = \"yy\";\n\tyyclass = 0;\n\tuse_read = use_stdout = false;\n\n\tsawcmpflag = false;\n\n\t/* Initialize dynamic array for holding the rule actions. */\n\taction_size = 2048;\t/* default size of action array in bytes */\n\taction_array = allocate_character_array( action_size );\n\tdefs1_offset = prolog_offset = action_offset = action_index = 0;\n\taction_array[0] = '\\0';\n\n/* Commented by Amit Goel on 5th September 2001 to remove nomdeterminism */\n/*\tprogram_name = argv[0];    */\n/* Added by Amit Goel on 5th September 2001 */\n        program_name = \"Executable\";\n\n\tif ( program_name[0] != '\\0' &&\n\t     program_name[strlen( program_name ) - 1] == '+' )\n\t\tC_plus_plus = true;\n\n/* ### add for testing ### */\n        ++argv;--argc;\n/* ####################### */\n\n\t/* read flags */\n\tfor ( --argc, ++argv; argc ; --argc, ++argv )\n\t\t{\n\t\targ = argv[0];\n\n\t\tif ( arg[0] != '-' || arg[1] == '\\0' )\n\t\t\tbreak;\n\n\t\tif ( arg[1] == '-' )\n\t\t\t{ /* --option */\n\t\t\tif ( ! strcmp( arg, \"--help\" ) )\n\t\t\t\targ = \"-h\";\n\n\t\t\telse if ( ! strcmp( arg, \"--version\" ) )\n\t\t\t\targ = \"-V\";\n\n\t\t\telse if ( ! strcmp( arg, \"--\" ) )\n\t\t\t\t{ /* end of options */\n\t\t\t\t--argc;\n\t\t\t\t++argv;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tfor ( i = 1; arg[i] != '\\0'; ++i )\n\t\t\tswitch ( arg[i] )\n\t\t\t\t{\n\t\t\t\tcase '+':\n\t\t\t\t\tC_plus_plus = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'B':\n\t\t\t\t\tinteractive = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'b':\n\t\t\t\t\tbacking_up_report = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'c':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'C':\n\t\t\t\t\tif ( i != 1 )\n\t\t\t\t\t\tflexerror(\n\t\t\t\t_( \"-C flag must be given separately\" ) );\n\n\t\t\t\t\tif ( ! sawcmpflag )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tuseecs = false;\n\t\t\t\t\t\tusemecs = false;\n\t\t\t\t\t\tfulltbl = false;\n\t\t\t\t\t\tsawcmpflag = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tfor ( ++i; arg[i] != '\\0'; ++i )\n\t\t\t\t\t\tswitch ( arg[i] )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\t\tlong_align =\n\t\t\t\t\t\t\t\t\ttrue;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'e':\n\t\t\t\t\t\t\t\tuseecs = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'F':\n\t\t\t\t\t\t\t\tfullspd = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\tfulltbl = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\t\tusemecs = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'r':\n\t\t\t\t\t\t\t\tuse_read = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tlerrif(\n\t\t\t\t\t\t_( \"unknown -C option '%c'\" ),\n\t\t\t\t\t\t\t\t(int) arg[i] );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\tgoto get_next_arg;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\tddebug = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'f':\n\t\t\t\t\tuseecs = usemecs = false;\n\t\t\t\t\tuse_read = fulltbl = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'F':\n\t\t\t\t\tuseecs = usemecs = false;\n\t\t\t\t\tuse_read = fullspd = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\t\tusage();\n\t\t\t\t\texit( 0 );\n\n\t\t\t\tcase 'I':\n\t\t\t\t\tinteractive = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'i':\n\t\t\t\t\tcaseins = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l':\n\t\t\t\t\tlex_compat = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'L':\n\t\t\t\t\tgen_line_dirs = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'n':\n\t\t\t\t\t/* Stupid do-nothing deprecated\n\t\t\t\t\t * option.\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'o':\n\t\t\t\t\tif ( i != 1 )\n\t\t\t\t\t\tflexerror(\n\t\t\t\t_( \"-o flag must be given separately\" ) );\n\n\t\t\t\t\toutfilename = arg + i + 1;\n\t\t\t\t\tdid_outfilename = 1;\n\t\t\t\t\tgoto get_next_arg;\n\n\t\t\t\tcase 'P':\n\t\t\t\t\tif ( i != 1 )\n\t\t\t\t\t\tflexerror(\n\t\t\t\t_( \"-P flag must be given separately\" ) );\n\n\t\t\t\t\tprefix = arg + i + 1;\n\t\t\t\t\tgoto get_next_arg;\n\n\t\t\t\tcase 'p':\n\t\t\t\t\t++performance_report;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tif ( i != 1 )\n\t\t\t\t\t\tflexerror(\n\t\t\t\t_( \"-S flag must be given separately\" ) );\n\n\t\t\t\t\tskelname = arg + i + 1;\n\t\t\t\t\tgoto get_next_arg;\n\n\t\t\t\tcase 's':\n\t\t\t\t\tspprdflt = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 't':\n\t\t\t\t\tuse_stdout = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'T':\n\t\t\t\t\ttrace = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'v':\n\t\t\t\t\tprintstats = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'V':\n\t\t\t\t\tprintf( _( \"%s version %s\\n\" ),\n\t\t\t\t\t\tprogram_name, flex_version );\n\t\t\t\t\texit( 0 );\n\n\t\t\t\tcase 'w':\n\t\t\t\t\tnowarn = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '7':\n\t\t\t\t\tcsize = 128;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '8':\n\t\t\t\t\tcsize = CSIZE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf( err,\n\t\t_( \"%s: unknown flag '%c'.  For usage, try\\n\\t%s --help\\n\" ),\n\t\t\t\t\t\tprogram_name, (int) arg[i],\n\t\t\t\t\t\tprogram_name );\n\t\t\t\t\texit( 1 );\n\t\t\t\t}\n\n\t\t/* Used by -C, -S, -o, and -P flags in lieu of a \"continue 2\"\n\t\t * control.\n\t\t */\n\t\tget_next_arg: ;\n\t\t}\n\n\tnum_input_files = argc;\n\tinput_files = argv;\n\tset_input_file( num_input_files > 0 ? input_files[0] : NULL );\n\n\tlastccl = lastsc = lastdfa = lastnfa = 0;\n\tnum_rules = num_eof_rules = default_rule = 0;\n\tnumas = numsnpairs = tmpuses = 0;\n\tnumecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;\n\tnumuniq = numdup = hshsave = eofseen = datapos = dataline = 0;\n\tnum_backing_up = onesp = numprots = 0;\n\tvariable_trailing_context_rules = bol_needed = false;\n\n\tout_linenum = linenum = sectnum = 1;\n\tfirstprot = NIL;\n\n\t/* Used in mkprot() so that the first proto goes in slot 1\n\t * of the proto queue.\n\t */\n\tlastprot = 1;\n\n\tset_up_initial_allocations();\n\t}\n\n\n/* readin - read in the rules section of the input file(s) */\n\nvoid readin()\n\t{\n\tstatic char yy_stdinit[] = \"FILE *yyin = stdin, *yyout = stdout;\";\n\tstatic char yy_nostdinit[] =\n\t\t\"FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;\";\n\n\tline_directive_out( (FILE *) 0, 1 );\n\n\tif ( yyparse() )\n\t\t{\n\t\tpinpoint_message( _( \"fatal parse error\" ) );\n\t\tflexend( 1 );\n\t\t}\n\n\tif ( syntaxerror )\n\t\tflexend( 1 );\n\n\tif ( backing_up_report )\n\t\t{\n\t\tbacking_up_file = fopen( backing_name, \"w\" );\n\t\tif ( backing_up_file == NULL )\n\t\t\tlerrsf(\n\t\t\t_( \"could not create backing-up info file %s\" ),\n\t\t\t\tbacking_name );\n\t\t}\n\n\telse\n\t\tbacking_up_file = NULL;\n\n\tif ( yymore_really_used == true )\n\t\tyymore_used = true;\n\telse if ( yymore_really_used == false )\n\t\tyymore_used = false;\n\n\tif ( reject_really_used == true )\n\t\treject = true;\n\telse if ( reject_really_used == false )\n\t\treject = false;\n\n\tif ( performance_report > 0 )\n\t\t{\n\t\tif ( lex_compat )\n\t\t\t{\n\t\t\tfprintf( err,\n_( \"-l AT&T lex compatibility option entails a large performance penalty\\n\" ) );\n\t\t\tfprintf( err,\n_( \" and may be the actual source of other reported performance penalties\\n\" ) );\n\t\t\t}\n\n\t\telse if ( do_yylineno )\n\t\t\t{\n\t\t\tfprintf( err,\n\t_( \"%%option yylineno entails a large performance penalty\\n\" ) );\n\t\t\t}\n\n\t\tif ( performance_report > 1 )\n\t\t\t{\n\t\t\tif ( interactive )\n\t\t\t\tfprintf( err,\n\t_( \"-I (interactive) entails a minor performance penalty\\n\" ) );\n\n\t\t\tif ( yymore_used )\n\t\t\t\tfprintf( err,\n\t\t_( \"yymore() entails a minor performance penalty\\n\" ) );\n\t\t\t}\n\n\t\tif ( reject )\n\t\t\tfprintf( err,\n\t\t\t_( \"REJECT entails a large performance penalty\\n\" ) );\n\n\t\tif ( variable_trailing_context_rules )\n\t\t\tfprintf( err,\n_( \"Variable trailing context rules entail a large performance penalty\\n\" ) );\n\t\t}\n\n\tif ( reject )\n\t\treal_reject = true;\n\n\tif ( variable_trailing_context_rules )\n\t\treject = true;\n\n\tif ( (fulltbl || fullspd) && reject )\n\t\t{\n\t\tif ( real_reject )\n\t\t\tflexerror(\n\t\t\t\t_( \"REJECT cannot be used with -f or -F\" ) );\n\t\telse if ( do_yylineno )\n\t\t\tflexerror(\n\t\t\t_( \"%option yylineno cannot be used with -f or -F\" ) );\n\t\telse\n\t\t\tflexerror(\n\t_( \"variable trailing context rules cannot be used with -f or -F\" ) );\n\t\t}\n\n\tif ( reject )\n\t\toutn( \"\\n#define YY_USES_REJECT\" );\n\n\tif ( ! do_yywrap )\n\t\t{\n\t\toutn( \"\\n#define yywrap() 1\" );\n\t\toutn( \"#define YY_SKIP_YYWRAP\" );\n\t\t}\n\n\tif ( ddebug )\n\t\toutn( \"\\n#define FLEX_DEBUG\" );\n\n\tif ( csize == 256 )\n\t\toutn( \"typedef unsigned char YY_CHAR;\" );\n\telse\n\t\toutn( \"typedef char YY_CHAR;\" );\n\n\tif ( C_plus_plus )\n\t\t{\n\t\toutn( \"#define yytext_ptr yytext\" );\n\n\t\tif ( interactive )\n\t\t\toutn( \"#define YY_INTERACTIVE\" );\n\t\t}\n\n\telse\n\t\t{\n\t\tif ( do_stdinit )\n\t\t\t{\n\t\t\toutn( \"#ifdef VMS\" );\n\t\t\toutn( \"#ifndef __VMS_POSIX\" );\n\t\t\toutn( yy_nostdinit );\n\t\t\toutn( \"#else\" );\n\t\t\toutn( yy_stdinit );\n\t\t\toutn( \"#endif\" );\n\t\t\toutn( \"#else\" );\n\t\t\toutn( yy_stdinit );\n\t\t\toutn( \"#endif\" );\n\t\t\t}\n\n\t\telse\n\t\t\toutn( yy_nostdinit );\n\t\t}\n\n\tif ( fullspd )\n\t\toutn( \"typedef yyconst struct yy_trans_info *yy_state_type;\" );\n\telse if ( ! C_plus_plus )\n\t\toutn( \"typedef int yy_state_type;\" );\n\n\tif ( ddebug )\n\t\toutn( \"\\n#define FLEX_DEBUG\" );\n\n\tif ( lex_compat )\n\t\toutn( \"#define YY_FLEX_LEX_COMPAT\" );\n\n\tif ( do_yylineno && ! C_plus_plus )\n\t\t{\n\t\toutn( \"extern int yylineno;\" );\n\t\toutn( \"int yylineno = 1;\" );\n\t\t}\n\n\tif ( C_plus_plus )\n\t\t{\n\t\toutn( \"\\n#include <FlexLexer.h>\" );\n\n\t\tif ( yyclass )\n\t\t\t{\n\t\t\toutn( \"int yyFlexLexer::yylex()\" );\n\t\t\toutn( \"\\t{\" );\n\t\t\toutn(\n\"\\tLexerError( \\\"yyFlexLexer::yylex invoked but %option yyclass used\\\" );\" );\n\t\t\toutn( \"\\treturn 0;\" );\n\t\t\toutn( \"\\t}\" );\n\t\n\t\t\tout_str( \"\\n#define YY_DECL int %s::yylex()\\n\",\n\t\t\t\tyyclass );\n\t\t\t}\n\t\t}\n\n\telse\n\t\t{\n\t\tif ( yytext_is_array )\n\t\t\toutn( \"extern char yytext[];\\n\" );\n\n\t\telse\n\t\t\t{\n\t\t\toutn( \"extern char *yytext;\" );\n\t\t\toutn( \"#define yytext_ptr yytext\" );\n\t\t\t}\n\n\t\tif ( yyclass )\n\t\t\tflexerror(\n\t\t_( \"%option yyclass only meaningful for C++ scanners\" ) );\n\t\t}\n\n\tif ( useecs )\n\t\tnumecs = cre8ecs( nextecm, ecgroup, csize );\n\telse\n\t\tnumecs = csize;\n\n\t/* Now map the equivalence class for NUL to its expected place. */\n\tecgroup[0] = ecgroup[csize];\n\tNUL_ec = ABS( ecgroup[0] );\n\n\tif ( useecs )\n\t\tccl2ecl();\n\t}\n\n\n/* set_up_initial_allocations - allocate memory for internal tables */\n\nvoid set_up_initial_allocations()\n\t{\n\tcurrent_mns = INITIAL_MNS;\n\tfirstst = allocate_integer_array( current_mns );\n\tlastst = allocate_integer_array( current_mns );\n\tfinalst = allocate_integer_array( current_mns );\n\ttranschar = allocate_integer_array( current_mns );\n\ttrans1 = allocate_integer_array( current_mns );\n\ttrans2 = allocate_integer_array( current_mns );\n\taccptnum = allocate_integer_array( current_mns );\n\tassoc_rule = allocate_integer_array( current_mns );\n\tstate_type = allocate_integer_array( current_mns );\n\n\tcurrent_max_rules = INITIAL_MAX_RULES;\n\trule_type = allocate_integer_array( current_max_rules );\n\trule_linenum = allocate_integer_array( current_max_rules );\n\trule_useful = allocate_integer_array( current_max_rules );\n\n\tcurrent_max_scs = INITIAL_MAX_SCS;\n\tscset = allocate_integer_array( current_max_scs );\n\tscbol = allocate_integer_array( current_max_scs );\n\tscxclu = allocate_integer_array( current_max_scs );\n\tsceof = allocate_integer_array( current_max_scs );\n\tscname = allocate_char_ptr_array( current_max_scs );\n\n\tcurrent_maxccls = INITIAL_MAX_CCLS;\n\tcclmap = allocate_integer_array( current_maxccls );\n\tccllen = allocate_integer_array( current_maxccls );\n\tcclng = allocate_integer_array( current_maxccls );\n\n\tcurrent_max_ccl_tbl_size = INITIAL_MAX_CCL_TBL_SIZE;\n\tccltbl = allocate_Character_array( current_max_ccl_tbl_size );\n\n\tcurrent_max_dfa_size = INITIAL_MAX_DFA_SIZE;\n\n\tcurrent_max_xpairs = INITIAL_MAX_XPAIRS;\n\tnxt = allocate_integer_array( current_max_xpairs );\n\tchk = allocate_integer_array( current_max_xpairs );\n\n\tcurrent_max_template_xpairs = INITIAL_MAX_TEMPLATE_XPAIRS;\n\ttnxt = allocate_integer_array( current_max_template_xpairs );\n\n\tcurrent_max_dfas = INITIAL_MAX_DFAS;\n\tbase = allocate_integer_array( current_max_dfas );\n\tdef = allocate_integer_array( current_max_dfas );\n\tdfasiz = allocate_integer_array( current_max_dfas );\n\taccsiz = allocate_integer_array( current_max_dfas );\n\tdhash = allocate_integer_array( current_max_dfas );\n\tdss = allocate_int_ptr_array( current_max_dfas );\n\tdfaacc = allocate_dfaacc_union( current_max_dfas );\n\n\tnultrans = (int *) 0;\n\t}\n\n\nvoid usage()\n\t{\n/*\tFILE *f = stdout;*/ /* #### f is replaced by err for testing. #### */\n\n\tfprintf( err,\n_( \"%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\\n\" ),\n\t\tprogram_name );\n\tfprintf( err, _( \"\\t[--help --version] [file ...]\\n\" ) );\n\n\tfprintf( err, _( \"\\t-b  generate backing-up information to %s\\n\" ),\n\t\tbacking_name );\n\tfprintf( err, _( \"\\t-c  do-nothing POSIX option\\n\" ) );\n\tfprintf( err, _( \"\\t-d  turn on debug mode in generated scanner\\n\" ) );\n\tfprintf( err, _( \"\\t-f  generate fast, large scanner\\n\" ) );\n\tfprintf( err, _( \"\\t-h  produce this help message\\n\" ) );\n\tfprintf( err, _( \"\\t-i  generate case-insensitive scanner\\n\" ) );\n\tfprintf( err, _( \"\\t-l  maximal compatibility with original lex\\n\" ) );\n\tfprintf( err, _( \"\\t-n  do-nothing POSIX option\\n\" ) );\n\tfprintf( err, _( \"\\t-p  generate performance report to err\\n\" ) );\n\tfprintf( err,\n\t\t_( \"\\t-s  suppress default rule to ECHO unmatched text\\n\" ) );\n\n\tif ( ! did_outfilename )\n\t\t{\n\t\tsprintf( outfile_path, outfile_template,\n\t\t\tprefix, C_plus_plus ? \"cc\" : \"c\" );\n\t\toutfilename = outfile_path;\n\t\t}\n\n\tfprintf( err,\n\t\t_( \"\\t-t  write generated scanner on stdout instead of %s\\n\" ),\n\t\toutfilename );\n\n\tfprintf( err,\n\t\t_( \"\\t-v  write summary of scanner statistics to f\\n\" ) );\n\tfprintf( err, _( \"\\t-w  do not generate warnings\\n\" ) );\n\tfprintf( err, _( \"\\t-B  generate batch scanner (opposite of -I)\\n\" ) );\n\tfprintf( err,\n\t\t_( \"\\t-F  use alternative fast scanner representation\\n\" ) );\n\tfprintf( err,\n\t\t_( \"\\t-I  generate interactive scanner (opposite of -B)\\n\" ) );\n\tfprintf( err, _( \"\\t-L  suppress #line directives in scanner\\n\" ) );\n\tfprintf( err, _( \"\\t-T  %s should run in trace mode\\n\" ), program_name );\n\tfprintf( err, _( \"\\t-V  report %s version\\n\" ), program_name );\n\tfprintf( err, _( \"\\t-7  generate 7-bit scanner\\n\" ) );\n\tfprintf( err, _( \"\\t-8  generate 8-bit scanner\\n\" ) );\n\tfprintf( err, _( \"\\t-+  generate C++ scanner class\\n\" ) );\n\tfprintf( err, _( \"\\t-?  produce this help message\\n\" ) );\n\tfprintf( err,\n_( \"\\t-C  specify degree of table compression (default is -Cem):\\n\" ) );\n\tfprintf( err,\n_( \"\\t\\t-Ca  trade off larger tables for better memory alignment\\n\" ) );\n\tfprintf( err, _( \"\\t\\t-Ce  construct equivalence classes\\n\" ) );\n\tfprintf( err,\n_( \"\\t\\t-Cf  do not compress scanner tables; use -f representation\\n\" ) );\n\tfprintf( err,\n_( \"\\t\\t-CF  do not compress scanner tables; use -F representation\\n\" ) );\n\tfprintf( err, _( \"\\t\\t-Cm  construct meta-equivalence classes\\n\" ) );\n\tfprintf( err,\n\t_( \"\\t\\t-Cr  use read() instead of stdio for scanner input\\n\" ) );\n\tfprintf( err, _( \"\\t-o  specify output filename\\n\" ) );\n\tfprintf( err, _( \"\\t-P  specify scanner prefix other than \\\"yy\\\"\\n\" ) );\n\tfprintf( err, _( \"\\t-S  specify skeleton file\\n\" ) );\n\tfprintf( err, _( \"\\t--help     produce this help message\\n\" ) );\n\tfprintf( err, _( \"\\t--version  report %s version\\n\" ), program_name );\n\t}\n/* ccl - routines for character classes */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n/* ccladd - add a single character to a ccl */\n\nvoid ccladd( cclp, ch )\nint cclp;\nint ch;\n\t{\n\tint ind, len, newpos, i;\n\n\tcheck_char( ch );\n\n\tlen = ccllen[cclp];\n\tind = cclmap[cclp];\n\n\t/* check to see if the character is already in the ccl */\n\n\tfor ( i = 0; i < len; ++i )\n\t\tif ( ccltbl[ind + i] == ch )\n\t\t\treturn;\n\n\tnewpos = ind + len;\n\n\tif ( newpos >= current_max_ccl_tbl_size )\n\t\t{\n\t\tcurrent_max_ccl_tbl_size += MAX_CCL_TBL_SIZE_INCREMENT;\n\n\t\t++num_reallocs;\n\n\t\tccltbl = reallocate_Character_array( ccltbl,\n\t\t\t\t\t\tcurrent_max_ccl_tbl_size );\n\t\t}\n\n\tccllen[cclp] = len + 1;\n\tccltbl[newpos] = ch;\n\t}\n\n\n/* cclinit - return an empty ccl */\n\nint cclinit()\n\t{\n\tif ( ++lastccl >= current_maxccls )\n\t\t{\n\t\tcurrent_maxccls += MAX_CCLS_INCREMENT;\n\n\t\t++num_reallocs;\n\n\t\tcclmap = reallocate_integer_array( cclmap, current_maxccls );\n\t\tccllen = reallocate_integer_array( ccllen, current_maxccls );\n\t\tcclng = reallocate_integer_array( cclng, current_maxccls );\n\t\t}\n\n\tif ( lastccl == 1 )\n\t\t/* we're making the first ccl */\n\t\tcclmap[lastccl] = 0;\n\n\telse\n\t\t/* The new pointer is just past the end of the last ccl.\n\t\t * Since the cclmap points to the \\first/ character of a\n\t\t * ccl, adding the length of the ccl to the cclmap pointer\n\t\t * will produce a cursor to the first free space.\n\t\t */\n\t\tcclmap[lastccl] = cclmap[lastccl - 1] + ccllen[lastccl - 1];\n\n\tccllen[lastccl] = 0;\n\tcclng[lastccl] = 0;\t/* ccl's start out life un-negated */\n\n\treturn lastccl;\n\t}\n\n\n/* cclnegate - negate the given ccl */\n\nvoid cclnegate( cclp )\nint cclp;\n\t{\n\tcclng[cclp] = 1;\n\t}\n\n\n/* list_character_set - list the members of a set of characters in CCL form\n *\n * Writes to the given file a character-class representation of those\n * characters present in the given CCL.  A character is present if it\n * has a non-zero value in the cset array.\n */\n\nvoid list_character_set( file, cset )\nFILE *file;\nint cset[];\n\t{\n\tregister int i;\n\n\tputc( '[', file );\n\n\tfor ( i = 0; i < csize; ++i )\n\t\t{\n\t\tif ( cset[i] )\n\t\t\t{\n\t\t\tregister int start_char = i;\n\n\t\t\tputc( ' ', file );\n\n\t\t\tfputs( readable_form( i ), file );\n\n\t\t\twhile ( ++i < csize && cset[i] )\n\t\t\t\t;\n\n\t\t\tif ( i - 1 > start_char )\n\t\t\t\t/* this was a run */\n\t\t\t\tfprintf( file, \"-%s\", readable_form( i - 1 ) );\n\n\t\t\tputc( ' ', file );\n\t\t\t}\n\t\t}\n\n\tputc( ']', file );\n\t}\n/* dfa - DFA construction routines */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n\n/* declare functions that have forward references */\n\nvoid dump_associated_rules PROTO((FILE*, int));\nvoid dump_transitions PROTO((FILE*, int[]));\nvoid sympartition PROTO((int[], int, int[], int[]));\nint symfollowset PROTO((int[], int, int, int[]));\n\n\n/* check_for_backing_up - check a DFA state for backing up\n *\n * synopsis\n *     void check_for_backing_up( int ds, int state[numecs] );\n *\n * ds is the number of the state to check and state[] is its out-transitions,\n * indexed by equivalence class.\n */\n\nvoid check_for_backing_up( ds, state )\nint ds;\nint state[];\n\t{\n\tif ( (reject && ! dfaacc[ds].dfaacc_set) ||\n\t     (! reject && ! dfaacc[ds].dfaacc_state) )\n\t\t{ /* state is non-accepting */\n\t\t++num_backing_up;\n\n\t\tif ( backing_up_report )\n\t\t\t{\n\t\t\tfprintf( backing_up_file,\n\t\t\t\t_( \"State #%d is non-accepting -\\n\" ), ds );\n\n\t\t\t/* identify the state */\n\t\t\tdump_associated_rules( backing_up_file, ds );\n\n\t\t\t/* Now identify it further using the out- and\n\t\t\t * jam-transitions.\n\t\t\t */\n\t\t\tdump_transitions( backing_up_file, state );\n\n\t\t\tputc( '\\n', backing_up_file );\n\t\t\t}\n\t\t}\n\t}\n\n\n/* check_trailing_context - check to see if NFA state set constitutes\n *                          \"dangerous\" trailing context\n *\n * synopsis\n *    void check_trailing_context( int nfa_states[num_states+1], int num_states,\n *\t\t\t\tint accset[nacc+1], int nacc );\n *\n * NOTES\n *  Trailing context is \"dangerous\" if both the head and the trailing\n *  part are of variable size \\and/ there's a DFA state which contains\n *  both an accepting state for the head part of the rule and NFA states\n *  which occur after the beginning of the trailing context.\n *\n *  When such a rule is matched, it's impossible to tell if having been\n *  in the DFA state indicates the beginning of the trailing context or\n *  further-along scanning of the pattern.  In these cases, a warning\n *  message is issued.\n *\n *    nfa_states[1 .. num_states] is the list of NFA states in the DFA.\n *    accset[1 .. nacc] is the list of accepting numbers for the DFA state.\n */\n\nvoid check_trailing_context( nfa_states, num_states, accset, nacc )\nint *nfa_states, num_states;\nint *accset;\nint nacc;\n\t{\n\tregister int i, j;\n\n\tfor ( i = 1; i <= num_states; ++i )\n\t\t{\n\t\tint ns = nfa_states[i];\n\t\tregister int type = state_type[ns];\n\t\tregister int ar = assoc_rule[ns];\n\n\t\tif ( type == STATE_NORMAL || rule_type[ar] != RULE_VARIABLE )\n\t\t\t{ /* do nothing */\n\t\t\t}\n\n\t\telse if ( type == STATE_TRAILING_CONTEXT )\n\t\t\t{\n\t\t\t/* Potential trouble.  Scan set of accepting numbers\n\t\t\t * for the one marking the end of the \"head\".  We\n\t\t\t * assume that this looping will be fairly cheap\n\t\t\t * since it's rare that an accepting number set\n\t\t\t * is large.\n\t\t\t */\n\t\t\tfor ( j = 1; j <= nacc; ++j )\n\t\t\t\tif ( accset[j] & YY_TRAILING_HEAD_MASK )\n\t\t\t\t\t{\n\t\t\t\t\tline_warning(\n\t\t\t\t\t_( \"dangerous trailing context\" ),\n\t\t\t\t\t\trule_linenum[ar] );\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n/* dump_associated_rules - list the rules associated with a DFA state\n *\n * Goes through the set of NFA states associated with the DFA and\n * extracts the first MAX_ASSOC_RULES unique rules, sorts them,\n * and writes a report to the given file.\n */\n\nvoid dump_associated_rules( file, ds )\nFILE *file;\nint ds;\n\t{\n\tregister int i, j;\n\tregister int num_associated_rules = 0;\n\tint rule_set[MAX_ASSOC_RULES + 1];\n\tint *dset = dss[ds];\n\tint size = dfasiz[ds];\n\n\tfor ( i = 1; i <= size; ++i )\n\t\t{\n\t\tregister int rule_num = rule_linenum[assoc_rule[dset[i]]];\n\n\t\tfor ( j = 1; j <= num_associated_rules; ++j )\n\t\t\tif ( rule_num == rule_set[j] )\n\t\t\t\tbreak;\n\n\t\tif ( j > num_associated_rules )\n\t\t\t{ /* new rule */\n\t\t\tif ( num_associated_rules < MAX_ASSOC_RULES )\n\t\t\t\trule_set[++num_associated_rules] = rule_num;\n\t\t\t}\n\t\t}\n\n\tbubble( rule_set, num_associated_rules );\n\n\tfprintf( file, _( \" associated rule line numbers:\" ) );\n\n\tfor ( i = 1; i <= num_associated_rules; ++i )\n\t\t{\n\t\tif ( i % 8 == 1 )\n\t\t\tputc( '\\n', file );\n\n\t\tfprintf( file, \"\\t%d\", rule_set[i] );\n\t\t}\n\n\tputc( '\\n', file );\n\t}\n\n\n/* dump_transitions - list the transitions associated with a DFA state\n *\n * synopsis\n *     dump_transitions( FILE *file, int state[numecs] );\n *\n * Goes through the set of out-transitions and lists them in human-readable\n * form (i.e., not as equivalence classes); also lists jam transitions\n * (i.e., all those which are not out-transitions, plus EOF).  The dump\n * is done to the given file.\n */\n\nvoid dump_transitions( file, state )\nFILE *file;\nint state[];\n\t{\n\tregister int i, ec;\n\tint out_char_set[CSIZE];\n\n\tfor ( i = 0; i < csize; ++i )\n\t\t{\n\t\tec = ABS( ecgroup[i] );\n\t\tout_char_set[i] = state[ec];\n\t\t}\n\n\tfprintf( file, _( \" out-transitions: \" ) );\n\n\tlist_character_set( file, out_char_set );\n\n\t/* now invert the members of the set to get the jam transitions */\n\tfor ( i = 0; i < csize; ++i )\n\t\tout_char_set[i] = ! out_char_set[i];\n\n\tfprintf( file, _( \"\\n jam-transitions: EOF \" ) );\n\n\tlist_character_set( file, out_char_set );\n\n\tputc( '\\n', file );\n\t}\n\n\n/* epsclosure - construct the epsilon closure of a set of ndfa states\n *\n * synopsis\n *    int *epsclosure( int t[num_states], int *numstates_addr,\n *\t\t\tint accset[num_rules+1], int *nacc_addr,\n *\t\t\tint *hashval_addr );\n *\n * NOTES\n *  The epsilon closure is the set of all states reachable by an arbitrary\n *  number of epsilon transitions, which themselves do not have epsilon\n *  transitions going out, unioned with the set of states which have non-null\n *  accepting numbers.  t is an array of size numstates of nfa state numbers.\n *  Upon return, t holds the epsilon closure and *numstates_addr is updated.\n *  accset holds a list of the accepting numbers, and the size of accset is\n *  given by *nacc_addr.  t may be subjected to reallocation if it is not\n *  large enough to hold the epsilon closure.\n *\n *  hashval is the hash value for the dfa corresponding to the state set.\n */\n\nint *epsclosure( t, ns_addr, accset, nacc_addr, hv_addr )\nint *t, *ns_addr, accset[], *nacc_addr, *hv_addr;\n\t{\n\tregister int stkpos, ns, tsp;\n\tint numstates = *ns_addr, nacc, hashval, transsym, nfaccnum;\n\tint stkend, nstate;\n\tstatic int did_stk_init = false, *stk; \n\n#define MARK_STATE(state) \\\ntrans1[state] = trans1[state] - MARKER_DIFFERENCE;\n\n#define IS_MARKED(state) (trans1[state] < 0)\n\n#define UNMARK_STATE(state) \\\ntrans1[state] = trans1[state] + MARKER_DIFFERENCE;\n\n#define CHECK_ACCEPT(state) \\\n{ \\\nnfaccnum = accptnum[state]; \\\nif ( nfaccnum != NIL ) \\\naccset[++nacc] = nfaccnum; \\\n}\n\n#define DO_REALLOCATION \\\n{ \\\ncurrent_max_dfa_size += MAX_DFA_SIZE_INCREMENT; \\\n++num_reallocs; \\\nt = reallocate_integer_array( t, current_max_dfa_size ); \\\nstk = reallocate_integer_array( stk, current_max_dfa_size ); \\\n} \\\n\n#define PUT_ON_STACK(state) \\\n{ \\\nif ( ++stkend >= current_max_dfa_size ) \\\nDO_REALLOCATION \\\nstk[stkend] = state; \\\nMARK_STATE(state) \\\n}\n\n#define ADD_STATE(state) \\\n{ \\\nif ( ++numstates >= current_max_dfa_size ) \\\nDO_REALLOCATION \\\nt[numstates] = state; \\\nhashval += state; \\\n}\n\n#define STACK_STATE(state) \\\n{ \\\nPUT_ON_STACK(state) \\\nCHECK_ACCEPT(state) \\\nif ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) \\\nADD_STATE(state) \\\n}\n\n\n\tif ( ! did_stk_init )\n\t\t{\n\t\tstk = allocate_integer_array( current_max_dfa_size );\n\t\tdid_stk_init = true;\n\t\t}\n\n\tnacc = stkend = hashval = 0;\n\n\tfor ( nstate = 1; nstate <= numstates; ++nstate )\n\t\t{\n\t\tns = t[nstate];\n\n\t\t/* The state could be marked if we've already pushed it onto\n\t\t * the stack.\n\t\t */\n\t\tif ( ! IS_MARKED(ns) )\n\t\t\t{\n\t\t\tPUT_ON_STACK(ns)\n\t\t\tCHECK_ACCEPT(ns)\n\t\t\thashval += ns;\n\t\t\t}\n\t\t}\n\n\tfor ( stkpos = 1; stkpos <= stkend; ++stkpos )\n\t\t{\n\t\tns = stk[stkpos];\n\t\ttranssym = transchar[ns];\n\n\t\tif ( transsym == SYM_EPSILON )\n\t\t\t{\n\t\t\ttsp = trans1[ns] + MARKER_DIFFERENCE;\n\n\t\t\tif ( tsp != NO_TRANSITION )\n\t\t\t\t{\n\t\t\t\tif ( ! IS_MARKED(tsp) )\n\t\t\t\t\tSTACK_STATE(tsp)\n\n\t\t\t\ttsp = trans2[ns];\n\n\t\t\t\tif ( tsp != NO_TRANSITION && ! IS_MARKED(tsp) )\n\t\t\t\t\tSTACK_STATE(tsp)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t/* Clear out \"visit\" markers. */\n\n\tfor ( stkpos = 1; stkpos <= stkend; ++stkpos )\n\t\t{\n\t\tif ( IS_MARKED(stk[stkpos]) )\n\t\t\tUNMARK_STATE(stk[stkpos])\n\t\telse\n\t\t\tflexfatal(\n\t\t\t_( \"consistency check failed in epsclosure()\" ) );\n\t\t}\n\n\t*ns_addr = numstates;\n\t*hv_addr = hashval;\n\t*nacc_addr = nacc;\n\n\treturn t;\n\t}\n\n\n/* increase_max_dfas - increase the maximum number of DFAs */\n\nvoid increase_max_dfas()\n\t{\n\tcurrent_max_dfas += MAX_DFAS_INCREMENT;\n\n\t++num_reallocs;\n\n\tbase = reallocate_integer_array( base, current_max_dfas );\n\tdef = reallocate_integer_array( def, current_max_dfas );\n\tdfasiz = reallocate_integer_array( dfasiz, current_max_dfas );\n\taccsiz = reallocate_integer_array( accsiz, current_max_dfas );\n\tdhash = reallocate_integer_array( dhash, current_max_dfas );\n\tdss = reallocate_int_ptr_array( dss, current_max_dfas );\n\tdfaacc = reallocate_dfaacc_union( dfaacc, current_max_dfas );\n\n\tif ( nultrans )\n\t\tnultrans =\n\t\t\treallocate_integer_array( nultrans, current_max_dfas );\n\t}\n\n\n/* ntod - convert an ndfa to a dfa\n *\n * Creates the dfa corresponding to the ndfa we've constructed.  The\n * dfa starts out in state #1.\n */\n\nvoid ntod()\n\t{\n\tint *accset, ds, nacc, newds;\n\tint sym, hashval, numstates, dsize;\n\tint num_full_table_rows;\t/* used only for -f */\n\tint *nset, *dset;\n\tint targptr, totaltrans, i, comstate, comfreq, targ;\n\tint symlist[CSIZE + 1];\n\tint num_start_states;\n\tint todo_head, todo_next;\n\n\t/* Note that the following are indexed by *equivalence classes*\n\t * and not by characters.  Since equivalence classes are indexed\n\t * beginning with 1, even if the scanner accepts NUL's, this\n\t * means that (since every character is potentially in its own\n\t * equivalence class) these arrays must have room for indices\n\t * from 1 to CSIZE, so their size must be CSIZE + 1.\n\t */\n\tint duplist[CSIZE + 1], state[CSIZE + 1];\n\tint targfreq[CSIZE + 1], targstate[CSIZE + 1];\n\n\taccset = allocate_integer_array( num_rules + 1 );\n\tnset = allocate_integer_array( current_max_dfa_size );\n\n\t/* The \"todo\" queue is represented by the head, which is the DFA\n\t * state currently being processed, and the \"next\", which is the\n\t * next DFA state number available (not in use).  We depend on the\n\t * fact that snstods() returns DFA's \\in increasing order/, and thus\n\t * need only know the bounds of the dfas to be processed.\n\t */\n\ttodo_head = todo_next = 0;\n\n\tfor ( i = 0; i <= csize; ++i )\n\t\t{\n\t\tduplist[i] = NIL;\n\t\tsymlist[i] = false;\n\t\t}\n\n\tfor ( i = 0; i <= num_rules; ++i )\n\t\taccset[i] = NIL;\n\n\tif ( trace )\n\t\t{\n\t\tdumpnfa( scset[1] );\n\t\tfputs( _( \"\\n\\nDFA Dump:\\n\\n\" ), err );\n\t\t}\n\n\tinittbl();\n\n\t/* Check to see whether we should build a separate table for\n\t * transitions on NUL characters.  We don't do this for full-speed\n\t * (-F) scanners, since for them we don't have a simple state\n\t * number lying around with which to index the table.  We also\n\t * don't bother doing it for scanners unless (1) NUL is in its own\n\t * equivalence class (indicated by a positive value of\n\t * ecgroup[NUL]), (2) NUL's equivalence class is the last\n\t * equivalence class, and (3) the number of equivalence classes is\n\t * the same as the number of characters.  This latter case comes\n\t * about when useecs is false or when it's true but every character\n\t * still manages to land in its own class (unlikely, but it's\n\t * cheap to check for).  If all these things are true then the\n\t * character code needed to represent NUL's equivalence class for\n\t * indexing the tables is going to take one more bit than the\n\t * number of characters, and therefore we won't be assured of\n\t * being able to fit it into a YY_CHAR variable.  This rules out\n\t * storing the transitions in a compressed table, since the code\n\t * for interpreting them uses a YY_CHAR variable (perhaps it\n\t * should just use an integer, though; this is worth pondering ...\n\t * ###).\n\t *\n\t * Finally, for full tables, we want the number of entries in the\n\t * table to be a power of two so the array references go fast (it\n\t * will just take a shift to compute the major index).  If\n\t * encoding NUL's transitions in the table will spoil this, we\n\t * give it its own table (note that this will be the case if we're\n\t * not using equivalence classes).\n\t */\n\n\t/* Note that the test for ecgroup[0] == numecs below accomplishes\n\t * both (1) and (2) above\n\t */\n\tif ( ! fullspd && ecgroup[0] == numecs )\n\t\t{\n\t\t/* NUL is alone in its equivalence class, which is the\n\t\t * last one.\n\t\t */\n\t\tint use_NUL_table = (numecs == csize);\n\n\t\tif ( fulltbl && ! use_NUL_table )\n\t\t\t{\n\t\t\t/* We still may want to use the table if numecs\n\t\t\t * is a power of 2.\n\t\t\t */\n\t\t\tint power_of_two;\n\n\t\t\tfor ( power_of_two = 1; power_of_two <= csize;\n\t\t\t      power_of_two *= 2 )\n\t\t\t\tif ( numecs == power_of_two )\n\t\t\t\t\t{\n\t\t\t\t\tuse_NUL_table = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\tif ( use_NUL_table )\n\t\t\tnultrans = allocate_integer_array( current_max_dfas );\n\n\t\t/* From now on, nultrans != nil indicates that we're\n\t\t * saving null transitions for later, separate encoding.\n\t\t */\n\t\t}\n\n\n\tif ( fullspd )\n\t\t{\n\t\tfor ( i = 0; i <= numecs; ++i )\n\t\t\tstate[i] = 0;\n\n\t\tplace_state( state, 0, 0 );\n\t\tdfaacc[0].dfaacc_state = 0;\n\t\t}\n\n\telse if ( fulltbl )\n\t\t{\n\t\tif ( nultrans )\n\t\t\t/* We won't be including NUL's transitions in the\n\t\t\t * table, so build it for entries from 0 .. numecs - 1.\n\t\t\t */\n\t\t\tnum_full_table_rows = numecs;\n\n\t\telse\n\t\t\t/* Take into account the fact that we'll be including\n\t\t\t * the NUL entries in the transition table.  Build it\n\t\t\t * from 0 .. numecs.\n\t\t\t */\n\t\t\tnum_full_table_rows = numecs + 1;\n\n\t\t/* Unless -Ca, declare it \"short\" because it's a real\n\t\t * long-shot that that won't be large enough.\n\t\t */\n\t\tout_str_dec( \"static yyconst %s yy_nxt[][%d] =\\n    {\\n\",\n\t\t\t/* '}' so vi doesn't get too confused */\n\t\t\tlong_align ? \"long\" : \"short\", num_full_table_rows );\n\n\t\toutn( \"    {\" );\n\n\t\t/* Generate 0 entries for state #0. */\n\t\tfor ( i = 0; i < num_full_table_rows; ++i )\n\t\t\tmk2data( 0 );\n\n\t\tdataflush();\n\t\toutn( \"    },\\n\" );\n\t\t}\n\n\t/* Create the first states. */\n\n\tnum_start_states = lastsc * 2;\n\n\tfor ( i = 1; i <= num_start_states; ++i )\n\t\t{\n\t\tnumstates = 1;\n\n\t\t/* For each start condition, make one state for the case when\n\t\t * we're at the beginning of the line (the '^' operator) and\n\t\t * one for the case when we're not.\n\t\t */\n\t\tif ( i % 2 == 1 )\n\t\t\tnset[numstates] = scset[(i / 2) + 1];\n\t\telse\n\t\t\tnset[numstates] =\n\t\t\t\tmkbranch( scbol[i / 2], scset[i / 2] );\n\n\t\tnset = epsclosure( nset, &numstates, accset, &nacc, &hashval );\n\n\t\tif ( snstods( nset, numstates, accset, nacc, hashval, &ds ) )\n\t\t\t{\n\t\t\tnumas += nacc;\n\t\t\ttotnst += numstates;\n\t\t\t++todo_next;\n\n\t\t\tif ( variable_trailing_context_rules && nacc > 0 )\n\t\t\t\tcheck_trailing_context( nset, numstates,\n\t\t\t\t\t\t\taccset, nacc );\n\t\t\t}\n\t\t}\n\n\tif ( ! fullspd )\n\t\t{\n\t\tif ( ! snstods( nset, 0, accset, 0, 0, &end_of_buffer_state ) )\n\t\t\tflexfatal(\n\t\t\t_( \"could not create unique end-of-buffer state\" ) );\n\n\t\t++numas;\n\t\t++num_start_states;\n\t\t++todo_next;\n\t\t}\n\n\twhile ( todo_head < todo_next )\n\t\t{\n\t\ttargptr = 0;\n\t\ttotaltrans = 0;\n\n\t\tfor ( i = 1; i <= numecs; ++i )\n\t\t\tstate[i] = 0;\n\n\t\tds = ++todo_head;\n\n\t\tdset = dss[ds];\n\t\tdsize = dfasiz[ds];\n\n\t\tif ( trace )\n\t\t\tfprintf( err, _( \"state # %d:\\n\" ), ds );\n\n\t\tsympartition( dset, dsize, symlist, duplist );\n\n\t\tfor ( sym = 1; sym <= numecs; ++sym )\n\t\t\t{\n\t\t\tif ( symlist[sym] )\n\t\t\t\t{\n\t\t\t\tsymlist[sym] = 0;\n\n\t\t\t\tif ( duplist[sym] == NIL )\n\t\t\t\t\t{\n\t\t\t\t\t/* Symbol has unique out-transitions. */\n\t\t\t\t\tnumstates = symfollowset( dset, dsize,\n\t\t\t\t\t\t\t\tsym, nset );\n\t\t\t\t\tnset = epsclosure( nset, &numstates,\n\t\t\t\t\t\taccset, &nacc, &hashval );\n\n\t\t\t\t\tif ( snstods( nset, numstates, accset,\n\t\t\t\t\t\tnacc, hashval, &newds ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttotnst = totnst + numstates;\n\t\t\t\t\t\t++todo_next;\n\t\t\t\t\t\tnumas += nacc;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\tvariable_trailing_context_rules &&\n\t\t\t\t\t\t\tnacc > 0 )\n\t\t\t\t\t\t\tcheck_trailing_context(\n\t\t\t\t\t\t\t\tnset, numstates,\n\t\t\t\t\t\t\t\taccset, nacc );\n\t\t\t\t\t\t}\n\n\t\t\t\t\tstate[sym] = newds;\n\n\t\t\t\t\tif ( trace )\n\t\t\t\t\t\tfprintf( err, \"\\t%d\\t%d\\n\",\n\t\t\t\t\t\t\tsym, newds );\n\n\t\t\t\t\ttargfreq[++targptr] = 1;\n\t\t\t\t\ttargstate[targptr] = newds;\n\t\t\t\t\t++numuniq;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t/* sym's equivalence class has the same\n\t\t\t\t\t * transitions as duplist(sym)'s\n\t\t\t\t\t * equivalence class.\n\t\t\t\t\t */\n\t\t\t\t\ttarg = state[duplist[sym]];\n\t\t\t\t\tstate[sym] = targ;\n\n\t\t\t\t\tif ( trace )\n\t\t\t\t\t\tfprintf( err, \"\\t%d\\t%d\\n\",\n\t\t\t\t\t\t\tsym, targ );\n\n\t\t\t\t\t/* Update frequency count for\n\t\t\t\t\t * destination state.\n\t\t\t\t\t */\n\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( targstate[++i] != targ )\n\t\t\t\t\t\t;\n\n\t\t\t\t\t++targfreq[i];\n\t\t\t\t\t++numdup;\n\t\t\t\t\t}\n\n\t\t\t\t++totaltrans;\n\t\t\t\tduplist[sym] = NIL;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ( caseins && ! useecs )\n\t\t\t{\n\t\t\tregister int j;\n\n\t\t\tfor ( i = 'A', j = 'a'; i <= 'Z'; ++i, ++j )\n\t\t\t\t{\n\t\t\t\tif ( state[i] == 0 && state[j] != 0 )\n\t\t\t\t\t/* We're adding a transition. */\n\t\t\t\t\t++totaltrans;\n\n\t\t\t\telse if ( state[i] != 0 && state[j] == 0 )\n\t\t\t\t\t/* We're taking away a transition. */\n\t\t\t\t\t--totaltrans;\n\n\t\t\t\tstate[i] = state[j];\n\t\t\t\t}\n\t\t\t}\n\n\t\tnumsnpairs += totaltrans;\n\n\t\tif ( ds > num_start_states )\n\t\t\tcheck_for_backing_up( ds, state );\n\n\t\tif ( nultrans )\n\t\t\t{\n\t\t\tnultrans[ds] = state[NUL_ec];\n\t\t\tstate[NUL_ec] = 0;\t/* remove transition */\n\t\t\t}\n\n\t\tif ( fulltbl )\n\t\t\t{\n\t\t\toutn( \"    {\" );\n\n\t\t\t/* Supply array's 0-element. */\n\t\t\tif ( ds == end_of_buffer_state )\n\t\t\t\tmk2data( -end_of_buffer_state );\n\t\t\telse\n\t\t\t\tmk2data( end_of_buffer_state );\n\n\t\t\tfor ( i = 1; i < num_full_table_rows; ++i )\n\t\t\t\t/* Jams are marked by negative of state\n\t\t\t\t * number.\n\t\t\t\t */\n\t\t\t\tmk2data( state[i] ? state[i] : -ds );\n\n\t\t\tdataflush();\n\t\t\toutn( \"    },\\n\" );\n\t\t\t}\n\n\t\telse if ( fullspd )\n\t\t\tplace_state( state, ds, totaltrans );\n\n\t\telse if ( ds == end_of_buffer_state )\n\t\t\t/* Special case this state to make sure it does what\n\t\t\t * it's supposed to, i.e., jam on end-of-buffer.\n\t\t\t */\n\t\t\tstack1( ds, 0, 0, JAMSTATE );\n\n\t\telse /* normal, compressed state */\n\t\t\t{\n\t\t\t/* Determine which destination state is the most\n\t\t\t * common, and how many transitions to it there are.\n\t\t\t */\n\n\t\t\tcomfreq = 0;\n\t\t\tcomstate = 0;\n\n\t\t\tfor ( i = 1; i <= targptr; ++i )\n\t\t\t\tif ( targfreq[i] > comfreq )\n\t\t\t\t\t{\n\t\t\t\t\tcomfreq = targfreq[i];\n\t\t\t\t\tcomstate = targstate[i];\n\t\t\t\t\t}\n\n\t\t\tbldtbl( state, ds, totaltrans, comstate, comfreq );\n\t\t\t}\n\t\t}\n\n\tif ( fulltbl )\n\t\tdataend();\n\n\telse if ( ! fullspd )\n\t\t{\n\t\tcmptmps();  /* create compressed template entries */\n\n\t\t/* Create tables for all the states with only one\n\t\t * out-transition.\n\t\t */\n\t\twhile ( onesp > 0 )\n\t\t\t{\n\t\t\tmk1tbl( onestate[onesp], onesym[onesp], onenext[onesp],\n\t\t\tonedef[onesp] );\n\t\t\t--onesp;\n\t\t\t}\n\n\t\tmkdeftbl();\n\t\t}\n\n\tflex_free( (void *) accset );\n\tflex_free( (void *) nset );\n\t}\n\n\n/* snstods - converts a set of ndfa states into a dfa state\n *\n * synopsis\n *    is_new_state = snstods( int sns[numstates], int numstates,\n *\t\t\t\tint accset[num_rules+1], int nacc,\n *\t\t\t\tint hashval, int *newds_addr );\n *\n * On return, the dfa state number is in newds.\n */\n\nint snstods( sns, numstates, accset, nacc, hashval, newds_addr )\nint sns[], numstates, accset[], nacc, hashval, *newds_addr;\n\t{\n\tint didsort = 0;\n\tregister int i, j;\n\tint newds, *oldsns;\n\n\tfor ( i = 1; i <= lastdfa; ++i )\n\t\tif ( hashval == dhash[i] )\n\t\t\t{\n\t\t\tif ( numstates == dfasiz[i] )\n\t\t\t\t{\n\t\t\t\toldsns = dss[i];\n\n\t\t\t\tif ( ! didsort )\n\t\t\t\t\t{\n\t\t\t\t\t/* We sort the states in sns so we\n\t\t\t\t\t * can compare it to oldsns quickly.\n\t\t\t\t\t * We use bubble because there probably\n\t\t\t\t\t * aren't very many states.\n\t\t\t\t\t */\n\t\t\t\t\tbubble( sns, numstates );\n\t\t\t\t\tdidsort = 1;\n\t\t\t\t\t}\n\n\t\t\t\tfor ( j = 1; j <= numstates; ++j )\n\t\t\t\t\tif ( sns[j] != oldsns[j] )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif ( j > numstates )\n\t\t\t\t\t{\n\t\t\t\t\t++dfaeql;\n\t\t\t\t\t*newds_addr = i;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t++hshcol;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t++hshsave;\n\t\t\t}\n\n\t/* Make a new dfa. */\n\n\tif ( ++lastdfa >= current_max_dfas )\n\t\tincrease_max_dfas();\n\n\tnewds = lastdfa;\n\n\tdss[newds] = allocate_integer_array( numstates + 1 );\n\n\t/* If we haven't already sorted the states in sns, we do so now,\n\t * so that future comparisons with it can be made quickly.\n\t */\n\n\tif ( ! didsort )\n\t\tbubble( sns, numstates );\n\n\tfor ( i = 1; i <= numstates; ++i )\n\t\tdss[newds][i] = sns[i];\n\n\tdfasiz[newds] = numstates;\n\tdhash[newds] = hashval;\n\n\tif ( nacc == 0 )\n\t\t{\n\t\tif ( reject )\n\t\t\tdfaacc[newds].dfaacc_set = (int *) 0;\n\t\telse\n\t\t\tdfaacc[newds].dfaacc_state = 0;\n\n\t\taccsiz[newds] = 0;\n\t\t}\n\n\telse if ( reject )\n\t\t{\n\t\t/* We sort the accepting set in increasing order so the\n\t\t * disambiguating rule that the first rule listed is considered\n\t\t * match in the event of ties will work.  We use a bubble\n\t\t * sort since the list is probably quite small.\n\t\t */\n\n\t\tbubble( accset, nacc );\n\n\t\tdfaacc[newds].dfaacc_set = allocate_integer_array( nacc + 1 );\n\n\t\t/* Save the accepting set for later */\n\t\tfor ( i = 1; i <= nacc; ++i )\n\t\t\t{\n\t\t\tdfaacc[newds].dfaacc_set[i] = accset[i];\n\n\t\t\tif ( accset[i] <= num_rules )\n\t\t\t\t/* Who knows, perhaps a REJECT can yield\n\t\t\t\t * this rule.\n\t\t\t\t */\n\t\t\t\trule_useful[accset[i]] = true;\n\t\t\t}\n\n\t\taccsiz[newds] = nacc;\n\t\t}\n\n\telse\n\t\t{\n\t\t/* Find lowest numbered rule so the disambiguating rule\n\t\t * will work.\n\t\t */\n\t\tj = num_rules + 1;\n\n\t\tfor ( i = 1; i <= nacc; ++i )\n\t\t\tif ( accset[i] < j )\n\t\t\t\tj = accset[i];\n\n\t\tdfaacc[newds].dfaacc_state = j;\n\n\t\tif ( j <= num_rules )\n\t\t\trule_useful[j] = true;\n\t\t}\n\n\t*newds_addr = newds;\n\n\treturn 1;\n\t}\n\n\n/* symfollowset - follow the symbol transitions one step\n *\n * synopsis\n *    numstates = symfollowset( int ds[current_max_dfa_size], int dsize,\n *\t\t\t\tint transsym, int nset[current_max_dfa_size] );\n */\n\nint symfollowset( ds, dsize, transsym, nset )\nint ds[], dsize, transsym, nset[];\n\t{\n\tint ns, tsp, sym, i, j, lenccl, ch, numstates, ccllist;\n\n\tnumstates = 0;\n\n\tfor ( i = 1; i <= dsize; ++i )\n\t\t{ /* for each nfa state ns in the state set of ds */\n\t\tns = ds[i];\n\t\tsym = transchar[ns];\n\t\ttsp = trans1[ns];\n\n\t\tif ( sym < 0 )\n\t\t\t{ /* it's a character class */\n\t\t\tsym = -sym;\n\t\t\tccllist = cclmap[sym];\n\t\t\tlenccl = ccllen[sym];\n\n\t\t\tif ( cclng[sym] )\n\t\t\t\t{\n\t\t\t\tfor ( j = 0; j < lenccl; ++j )\n\t\t\t\t\t{\n\t\t\t\t\t/* Loop through negated character\n\t\t\t\t\t * class.\n\t\t\t\t\t */\n\t\t\t\t\tch = ccltbl[ccllist + j];\n\n\t\t\t\t\tif ( ch == 0 )\n\t\t\t\t\t\tch = NUL_ec;\n\n\t\t\t\t\tif ( ch > transsym )\n\t\t\t\t\t\t/* Transsym isn't in negated\n\t\t\t\t\t\t * ccl.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\telse if ( ch == transsym )\n\t\t\t\t\t\t/* next 2 */ goto bottom;\n\t\t\t\t\t}\n\n\t\t\t\t/* Didn't find transsym in ccl. */\n\t\t\t\tnset[++numstates] = tsp;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\tfor ( j = 0; j < lenccl; ++j )\n\t\t\t\t\t{\n\t\t\t\t\tch = ccltbl[ccllist + j];\n\n\t\t\t\t\tif ( ch == 0 )\n\t\t\t\t\t\tch = NUL_ec;\n\n\t\t\t\t\tif ( ch > transsym )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse if ( ch == transsym )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tnset[++numstates] = tsp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( sym >= 'A' && sym <= 'Z' && caseins )\n\t\t\tflexfatal(\n\t\t\t_( \"consistency check failed in symfollowset\" ) );\n\n\t\telse if ( sym == SYM_EPSILON )\n\t\t\t{ /* do nothing */\n\t\t\t}\n\n\t\telse if ( ABS( ecgroup[sym] ) == transsym )\n\t\t\tnset[++numstates] = tsp;\n\n\t\tbottom: ;\n\t\t}\n\n\treturn numstates;\n\t}\n\n\n/* sympartition - partition characters with same out-transitions\n *\n * synopsis\n *    sympartition( int ds[current_max_dfa_size], int numstates,\n *\t\t\tint symlist[numecs], int duplist[numecs] );\n */\n\nvoid sympartition( ds, numstates, symlist, duplist )\nint ds[], numstates;\nint symlist[], duplist[];\n\t{\n\tint tch, i, j, k, ns, dupfwd[CSIZE + 1], lenccl, cclp, ich;\n\n\t/* Partitioning is done by creating equivalence classes for those\n\t * characters which have out-transitions from the given state.  Thus\n\t * we are really creating equivalence classes of equivalence classes.\n\t */\n\n\tfor ( i = 1; i <= numecs; ++i )\n\t\t{ /* initialize equivalence class list */\n\t\tduplist[i] = i - 1;\n\t\tdupfwd[i] = i + 1;\n\t\t}\n\n\tduplist[1] = NIL;\n\tdupfwd[numecs] = NIL;\n\n\tfor ( i = 1; i <= numstates; ++i )\n\t\t{\n\t\tns = ds[i];\n\t\ttch = transchar[ns];\n\n\t\tif ( tch != SYM_EPSILON )\n\t\t\t{\n\t\t\tif ( tch < -lastccl || tch >= csize )\n\t\t\t\t{\n\t\t\t\tflexfatal(\n\t\t_( \"bad transition character detected in sympartition()\" ) );\n\t\t\t\t}\n\n\t\t\tif ( tch >= 0 )\n\t\t\t\t{ /* character transition */\n\t\t\t\tint ec = ecgroup[tch];\n\n\t\t\t\tmkechar( ec, dupfwd, duplist );\n\t\t\t\tsymlist[ec] = 1;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{ /* character class */\n\t\t\t\ttch = -tch;\n\n\t\t\t\tlenccl = ccllen[tch];\n\t\t\t\tcclp = cclmap[tch];\n\t\t\t\tmkeccl( ccltbl + cclp, lenccl, dupfwd,\n\t\t\t\t\tduplist, numecs, NUL_ec );\n\n\t\t\t\tif ( cclng[tch] )\n\t\t\t\t\t{\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\tfor ( k = 0; k < lenccl; ++k )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tich = ccltbl[cclp + k];\n\n\t\t\t\t\t\tif ( ich == 0 )\n\t\t\t\t\t\t\tich = NUL_ec;\n\n\t\t\t\t\t\tfor ( ++j; j < ich; ++j )\n\t\t\t\t\t\t\tsymlist[j] = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tfor ( ++j; j <= numecs; ++j )\n\t\t\t\t\t\tsymlist[j] = 1;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\tfor ( k = 0; k < lenccl; ++k )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tich = ccltbl[cclp + k];\n\n\t\t\t\t\t\tif ( ich == 0 )\n\t\t\t\t\t\t\tich = NUL_ec;\n\n\t\t\t\t\t\tsymlist[ich] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/* ecs - equivalence class routines */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n/* ccl2ecl - convert character classes to set of equivalence classes */\n\nvoid ccl2ecl()\n\t{\n\tint i, ich, newlen, cclp, ccls, cclmec;\n\n\tfor ( i = 1; i <= lastccl; ++i )\n\t\t{\n\t\t/* We loop through each character class, and for each character\n\t\t * in the class, add the character's equivalence class to the\n\t\t * new \"character\" class we are creating.  Thus when we are all\n\t\t * done, character classes will really consist of collections\n\t\t * of equivalence classes\n\t\t */\n\n\t\tnewlen = 0;\n\t\tcclp = cclmap[i];\n\n\t\tfor ( ccls = 0; ccls < ccllen[i]; ++ccls )\n\t\t\t{\n\t\t\tich = ccltbl[cclp + ccls];\n\t\t\tcclmec = ecgroup[ich];\n\n\t\t\tif ( cclmec > 0 )\n\t\t\t\t{\n\t\t\t\tccltbl[cclp + newlen] = cclmec;\n\t\t\t\t++newlen;\n\t\t\t\t}\n\t\t\t}\n\n\t\tccllen[i] = newlen;\n\t\t}\n\t}\n\n\n/* cre8ecs - associate equivalence class numbers with class members\n *\n * fwd is the forward linked-list of equivalence class members.  bck\n * is the backward linked-list, and num is the number of class members.\n *\n * Returned is the number of classes.\n */\n\nint cre8ecs( fwd, bck, num )\nint fwd[], bck[], num;\n\t{\n\tint i, j, numcl;\n\n\tnumcl = 0;\n\n\t/* Create equivalence class numbers.  From now on, ABS( bck(x) )\n\t * is the equivalence class number for object x.  If bck(x)\n\t * is positive, then x is the representative of its equivalence\n\t * class.\n\t */\n\tfor ( i = 1; i <= num; ++i )\n\t\tif ( bck[i] == NIL )\n\t\t\t{\n\t\t\tbck[i] = ++numcl;\n\t\t\tfor ( j = fwd[i]; j != NIL; j = fwd[j] )\n\t\t\t\tbck[j] = -numcl;\n\t\t\t}\n\n\treturn numcl;\n\t}\n\n\n/* mkeccl - update equivalence classes based on character class xtions\n *\n * synopsis\n *    Char ccls[];\n *    int lenccl, fwd[llsiz], bck[llsiz], llsiz, NUL_mapping;\n *    void mkeccl( Char ccls[], int lenccl, int fwd[llsiz], int bck[llsiz],\n *\t\t\tint llsiz, int NUL_mapping );\n *\n * ccls contains the elements of the character class, lenccl is the\n * number of elements in the ccl, fwd is the forward link-list of equivalent\n * characters, bck is the backward link-list, and llsiz size of the link-list.\n *\n * NUL_mapping is the value which NUL (0) should be mapped to.\n */\n\nvoid mkeccl( ccls, lenccl, fwd, bck, llsiz, NUL_mapping )\nChar ccls[];\nint lenccl, fwd[], bck[], llsiz, NUL_mapping;\n\t{\n\tint cclp, oldec, newec;\n\tint cclm, i, j;\n\tstatic unsigned char cclflags[CSIZE];\t/* initialized to all '\\0' */\n\n\t/* Note that it doesn't matter whether or not the character class is\n\t * negated.  The same results will be obtained in either case.\n\t */\n\n\tcclp = 0;\n\n\twhile ( cclp < lenccl )\n\t\t{\n\t\tcclm = ccls[cclp];\n\n\t\tif ( NUL_mapping && cclm == 0 )\n\t\t\tcclm = NUL_mapping;\n\n\t\toldec = bck[cclm];\n\t\tnewec = cclm;\n\n\t\tj = cclp + 1;\n\n\t\tfor ( i = fwd[cclm]; i != NIL && i <= llsiz; i = fwd[i] )\n\t\t\t{ /* look for the symbol in the character class */\n\t\t\tfor ( ; j < lenccl; ++j )\n\t\t\t\t{\n\t\t\t\tregister int ccl_char;\n\n\t\t\t\tif ( NUL_mapping && ccls[j] == 0 )\n\t\t\t\t\tccl_char = NUL_mapping;\n\t\t\t\telse\n\t\t\t\t\tccl_char = ccls[j];\n\n\t\t\t\tif ( ccl_char > i )\n\t\t\t\t\tbreak;\n\n\t\t\t\tif ( ccl_char == i && ! cclflags[j] )\n\t\t\t\t\t{\n\t\t\t\t\t/* We found an old companion of cclm\n\t\t\t\t\t * in the ccl.  Link it into the new\n\t\t\t\t\t * equivalence class and flag it as\n\t\t\t\t\t * having been processed.\n\t\t\t\t\t */\n\n\t\t\t\t\tbck[i] = newec;\n\t\t\t\t\tfwd[newec] = i;\n\t\t\t\t\tnewec = i;\n\t\t\t\t\t/* Set flag so we don't reprocess. */\n\t\t\t\t\tcclflags[j] = 1;\n\n\t\t\t\t\t/* Get next equivalence class member. */\n\t\t\t\t\t/* continue 2 */\n\t\t\t\t\tgoto next_pt;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t/* Symbol isn't in character class.  Put it in the old\n\t\t\t * equivalence class.\n\t\t\t */\n\n\t\t\tbck[i] = oldec;\n\n\t\t\tif ( oldec != NIL )\n\t\t\t\tfwd[oldec] = i;\n\n\t\t\toldec = i;\n\n\t\t\tnext_pt: ;\n\t\t\t}\n\n\t\tif ( bck[cclm] != NIL || oldec != bck[cclm] )\n\t\t\t{\n\t\t\tbck[cclm] = NIL;\n\t\t\tfwd[oldec] = NIL;\n\t\t\t}\n\n\t\tfwd[newec] = NIL;\n\n\t\t/* Find next ccl member to process. */\n\n\t\tfor ( ++cclp; cclflags[cclp] && cclp < lenccl; ++cclp )\n\t\t\t{\n\t\t\t/* Reset \"doesn't need processing\" flag. */\n\t\t\tcclflags[cclp] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n/* mkechar - create equivalence class for single character */\n\nvoid mkechar( tch, fwd, bck )\nint tch, fwd[], bck[];\n\t{\n\t/* If until now the character has been a proper subset of\n\t * an equivalence class, break it away to create a new ec\n\t */\n\n\tif ( fwd[tch] != NIL )\n\t\tbck[fwd[tch]] = bck[tch];\n\n\tif ( bck[tch] != NIL )\n\t\tfwd[bck[tch]] = fwd[tch];\n\n\tfwd[tch] = NIL;\n\tbck[tch] = NIL;\n\t}\n/* gen - actual generation (writing) of flex scanners */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n\n/* declare functions that have forward references */\n\nvoid gen_next_state PROTO((int));\nvoid genecs PROTO((void));\nvoid indent_put2s PROTO((char [], char []));\nvoid indent_puts PROTO((char []));\n\n\nstatic int indent_level = 0; /* each level is 8 spaces */\n\n#define indent_up() (++indent_level)\n#define indent_down() (--indent_level)\n#define set_indent(indent_val) indent_level = indent_val\n\n/* Almost everything is done in terms of arrays starting at 1, so provide\n * a null entry for the zero element of all C arrays.  (The exception\n * to this is that the fast table representation generally uses the\n * 0 elements of its arrays, too.)\n */\nstatic char C_int_decl[] = \"static yyconst int %s[%d] =\\n    {   0,\\n\";\nstatic char C_short_decl[] = \"static yyconst short int %s[%d] =\\n    {   0,\\n\";\nstatic char C_long_decl[] = \"static yyconst long int %s[%d] =\\n    {   0,\\n\";\nstatic char C_state_decl[] =\n\t\"static yyconst yy_state_type %s[%d] =\\n    {   0,\\n\";\n\n\n/* Indent to the current level. */\n\nvoid do_indent()\n\t{\n\tregister int i = indent_level * 8;\n\n\twhile ( i >= 8 )\n\t\t{\n\t\toutc( '\\t' );\n\t\ti -= 8;\n\t\t}\n\n\twhile ( i > 0 )\n\t\t{\n\t\toutc( ' ' );\n\t\t--i;\n\t\t}\n\t}\n\n\n/* Generate the code to keep backing-up information. */\n\nvoid gen_backing_up()\n\t{\n\tif ( reject || num_backing_up == 0 )\n\t\treturn;\n\n\tif ( fullspd )\n\t\tindent_puts( \"if ( yy_current_state[-1].yy_nxt )\" );\n\telse\n\t\tindent_puts( \"if ( yy_accept[yy_current_state] )\" );\n\n\tindent_up();\n\tindent_puts( \"{\" );\n\tindent_puts( \"yy_last_accepting_state = yy_current_state;\" );\n\tindent_puts( \"yy_last_accepting_cpos = yy_cp;\" );\n\tindent_puts( \"}\" );\n\tindent_down();\n\t}\n\n\n/* Generate the code to perform the backing up. */\n\nvoid gen_bu_action()\n\t{\n\tif ( reject || num_backing_up == 0 )\n\t\treturn;\n\n\tset_indent( 3 );\n\n\tindent_puts( \"case 0: /* must back up */\" );\n\tindent_puts( \"/* undo the effects of YY_DO_BEFORE_ACTION */\" );\n\tindent_puts( \"*yy_cp = yy_hold_char;\" );\n\n\tif ( fullspd || fulltbl )\n\t\tindent_puts( \"yy_cp = yy_last_accepting_cpos + 1;\" );\n\telse\n\t\t/* Backing-up info for compressed tables is taken \\after/\n\t\t * yy_cp has been incremented for the next state.\n\t\t */\n\t\tindent_puts( \"yy_cp = yy_last_accepting_cpos;\" );\n\n\tindent_puts( \"yy_current_state = yy_last_accepting_state;\" );\n\tindent_puts( \"goto yy_find_action;\" );\n\toutc( '\\n' );\n\n\tset_indent( 0 );\n\t}\n\n\n/* genctbl - generates full speed compressed transition table */\n\nvoid genctbl()\n\t{\n\tregister int i;\n\tint end_of_buffer_action = num_rules + 1;\n\n\t/* Table of verify for transition and offset to next state. */\n\tout_dec( \"static yyconst struct yy_trans_info yy_transition[%d] =\\n\",\n\t\ttblend + numecs + 1 );\n\toutn( \"    {\" );\n\n\t/* We want the transition to be represented as the offset to the\n\t * next state, not the actual state number, which is what it currently\n\t * is.  The offset is base[nxt[i]] - (base of current state)].  That's\n\t * just the difference between the starting points of the two involved\n\t * states (to - from).\n\t *\n\t * First, though, we need to find some way to put in our end-of-buffer\n\t * flags and states.  We do this by making a state with absolutely no\n\t * transitions.  We put it at the end of the table.\n\t */\n\n\t/* We need to have room in nxt/chk for two more slots: One for the\n\t * action and one for the end-of-buffer transition.  We now *assume*\n\t * that we're guaranteed the only character we'll try to index this\n\t * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure\n\t * there's room for jam entries for other characters.\n\t */\n\n\twhile ( tblend + 2 >= current_max_xpairs )\n\t\texpand_nxt_chk();\n\n\twhile ( lastdfa + 1 >= current_max_dfas )\n\t\tincrease_max_dfas();\n\n\tbase[lastdfa + 1] = tblend + 2;\n\tnxt[tblend + 1] = end_of_buffer_action;\n\tchk[tblend + 1] = numecs + 1;\n\tchk[tblend + 2] = 1; /* anything but EOB */\n\n\t/* So that \"make test\" won't show arb. differences. */\n\tnxt[tblend + 2] = 0;\n\n\t/* Make sure every state has an end-of-buffer transition and an\n\t * action #.\n\t */\n\tfor ( i = 0; i <= lastdfa; ++i )\n\t\t{\n\t\tint anum = dfaacc[i].dfaacc_state;\n\t\tint offset = base[i];\n\n\t\tchk[offset] = EOB_POSITION;\n\t\tchk[offset - 1] = ACTION_POSITION;\n\t\tnxt[offset - 1] = anum;\t/* action number */\n\t\t}\n\n\tfor ( i = 0; i <= tblend; ++i )\n\t\t{\n\t\tif ( chk[i] == EOB_POSITION )\n\t\t\ttransition_struct_out( 0, base[lastdfa + 1] - i );\n\n\t\telse if ( chk[i] == ACTION_POSITION )\n\t\t\ttransition_struct_out( 0, nxt[i] );\n\n\t\telse if ( chk[i] > numecs || chk[i] == 0 )\n\t\t\ttransition_struct_out( 0, 0 );\t/* unused slot */\n\n\t\telse\t/* verify, transition */\n\t\t\ttransition_struct_out( chk[i],\n\t\t\t\t\t\tbase[nxt[i]] - (i - chk[i]) );\n\t\t}\n\n\n\t/* Here's the final, end-of-buffer state. */\n\ttransition_struct_out( chk[tblend + 1], nxt[tblend + 1] );\n\ttransition_struct_out( chk[tblend + 2], nxt[tblend + 2] );\n\n\toutn( \"    };\\n\" );\n\n\t/* Table of pointers to start states. */\n\tout_dec(\n\t\"static yyconst struct yy_trans_info *yy_start_state_list[%d] =\\n\",\n\t\tlastsc * 2 + 1 );\n\toutn( \"    {\" );\t/* } so vi doesn't get confused */\n\n\tfor ( i = 0; i <= lastsc * 2; ++i )\n\t\tout_dec( \"    &yy_transition[%d],\\n\", base[i] );\n\n\tdataend();\n\n\tif ( useecs )\n\t\tgenecs();\n\t}\n\n\n/* Generate equivalence-class tables. */\n\nvoid genecs()\n\t{\n\tregister int i, j;\n\tint numrows;\n\n\tout_str_dec( C_int_decl, \"yy_ec\", csize );\n\n\tfor ( i = 1; i < csize; ++i )\n\t\t{\n\t\tif ( caseins && (i >= 'A') && (i <= 'Z') )\n\t\t\tecgroup[i] = ecgroup[clower( i )];\n\n\t\tecgroup[i] = ABS( ecgroup[i] );\n\t\tmkdata( ecgroup[i] );\n\t\t}\n\n\tdataend();\n\n\tif ( trace )\n\t\t{\n\t\tfputs( _( \"\\n\\nEquivalence Classes:\\n\\n\" ), err );\n\n\t\tnumrows = csize / 8;\n\n\t\tfor ( j = 0; j < numrows; ++j )\n\t\t\t{\n\t\t\tfor ( i = j; i < csize; i = i + numrows )\n\t\t\t\t{\n\t\t\t\tfprintf( err, \"%4s = %-2d\",\n\t\t\t\t\treadable_form( i ), ecgroup[i] );\n\n\t\t\t\tputc( ' ', err );\n\t\t\t\t}\n\n\t\t\tputc( '\\n', err );\n\t\t\t}\n\t\t}\n\t}\n\n\n/* Generate the code to find the action number. */\n\nvoid gen_find_action()\n\t{\n\tif ( fullspd )\n\t\tindent_puts( \"yy_act = yy_current_state[-1].yy_nxt;\" );\n\n\telse if ( fulltbl )\n\t\tindent_puts( \"yy_act = yy_accept[yy_current_state];\" );\n\n\telse if ( reject )\n\t\t{\n\t\tindent_puts( \"yy_current_state = *--yy_state_ptr;\" );\n\t\tindent_puts( \"yy_lp = yy_accept[yy_current_state];\" );\n\n\t\toutn(\n\t\t\"find_rule: /* we branch to this label when backing up */\" );\n\n\t\tindent_puts(\n\t\t\"for ( ; ; ) /* until we find what rule we matched */\" );\n\n\t\tindent_up();\n\n\t\tindent_puts( \"{\" );\n\n\t\tindent_puts(\n\t\t\"if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )\" );\n\t\tindent_up();\n\t\tindent_puts( \"{\" );\n\t\tindent_puts( \"yy_act = yy_acclist[yy_lp];\" );\n\n\t\tif ( variable_trailing_context_rules )\n\t\t\t{\n\t\t\tindent_puts( \"if ( yy_act & YY_TRAILING_HEAD_MASK ||\" );\n\t\t\tindent_puts( \"     yy_looking_for_trail_begin )\" );\n\t\t\tindent_up();\n\t\t\tindent_puts( \"{\" );\n\n\t\t\tindent_puts(\n\t\t\t\t\"if ( yy_act == yy_looking_for_trail_begin )\" );\n\t\t\tindent_up();\n\t\t\tindent_puts( \"{\" );\n\t\t\tindent_puts( \"yy_looking_for_trail_begin = 0;\" );\n\t\t\tindent_puts( \"yy_act &= ~YY_TRAILING_HEAD_MASK;\" );\n\t\t\tindent_puts( \"break;\" );\n\t\t\tindent_puts( \"}\" );\n\t\t\tindent_down();\n\n\t\t\tindent_puts( \"}\" );\n\t\t\tindent_down();\n\n\t\t\tindent_puts( \"else if ( yy_act & YY_TRAILING_MASK )\" );\n\t\t\tindent_up();\n\t\t\tindent_puts( \"{\" );\n\t\t\tindent_puts(\n\t\t\"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;\" );\n\t\t\tindent_puts(\n\t\t\"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;\" );\n\n\t\t\tif ( real_reject )\n\t\t\t\t{\n\t\t\t\t/* Remember matched text in case we back up\n\t\t\t\t * due to REJECT.\n\t\t\t\t */\n\t\t\t\tindent_puts( \"yy_full_match = yy_cp;\" );\n\t\t\t\tindent_puts( \"yy_full_state = yy_state_ptr;\" );\n\t\t\t\tindent_puts( \"yy_full_lp = yy_lp;\" );\n\t\t\t\t}\n\n\t\t\tindent_puts( \"}\" );\n\t\t\tindent_down();\n\n\t\t\tindent_puts( \"else\" );\n\t\t\tindent_up();\n\t\t\tindent_puts( \"{\" );\n\t\t\tindent_puts( \"yy_full_match = yy_cp;\" );\n\t\t\tindent_puts( \"yy_full_state = yy_state_ptr;\" );\n\t\t\tindent_puts( \"yy_full_lp = yy_lp;\" );\n\t\t\tindent_puts( \"break;\" );\n\t\t\tindent_puts( \"}\" );\n\t\t\tindent_down();\n\n\t\t\tindent_puts( \"++yy_lp;\" );\n\t\t\tindent_puts( \"goto find_rule;\" );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* Remember matched text in case we back up due to\n\t\t\t * trailing context plus REJECT.\n\t\t\t */\n\t\t\tindent_up();\n\t\t\tindent_puts( \"{\" );\n\t\t\tindent_puts( \"yy_full_match = yy_cp;\" );\n\t\t\tindent_puts( \"break;\" );\n\t\t\tindent_puts( \"}\" );\n\t\t\tindent_down();\n\t\t\t}\n\n\t\tindent_puts( \"}\" );\n\t\tindent_down();\n\n\t\tindent_puts( \"--yy_cp;\" );\n\n\t\t/* We could consolidate the following two lines with those at\n\t\t * the beginning, but at the cost of complaints that we're\n\t\t * branching inside a loop.\n\t\t */\n\t\tindent_puts( \"yy_current_state = *--yy_state_ptr;\" );\n\t\tindent_puts( \"yy_lp = yy_accept[yy_current_state];\" );\n\n\t\tindent_puts( \"}\" );\n\n\t\tindent_down();\n\t\t}\n\n\telse\n\t\t{ /* compressed */\n\t\tindent_puts( \"yy_act = yy_accept[yy_current_state];\" );\n\n\t\tif ( interactive && ! reject )\n\t\t\t{\n\t\t\t/* Do the guaranteed-needed backing up to figure out\n\t\t\t * the match.\n\t\t\t */\n\t\t\tindent_puts( \"if ( yy_act == 0 )\" );\n\t\t\tindent_up();\n\t\t\tindent_puts( \"{ /* have to back up */\" );\n\t\t\tindent_puts( \"yy_cp = yy_last_accepting_cpos;\" );\n\t\t\tindent_puts(\n\t\t\t\t\"yy_current_state = yy_last_accepting_state;\" );\n\t\t\tindent_puts( \"yy_act = yy_accept[yy_current_state];\" );\n\t\t\tindent_puts( \"}\" );\n\t\t\tindent_down();\n\t\t\t}\n\t\t}\n\t}\n\n\n/* genftbl - generate full transition table */\n\nvoid genftbl()\n\t{\n\tregister int i;\n\tint end_of_buffer_action = num_rules + 1;\n\n\tout_str_dec( long_align ? C_long_decl : C_short_decl,\n\t\t\"yy_accept\", lastdfa + 1 );\n\n\tdfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;\n\n\tfor ( i = 1; i <= lastdfa; ++i )\n\t\t{\n\t\tregister int anum = dfaacc[i].dfaacc_state;\n\n\t\tmkdata( anum );\n\n\t\tif ( trace && anum )\n\t\t\tfprintf( err, _( \"state # %d accepts: [%d]\\n\" ),\n\t\t\t\ti, anum );\n\t\t}\n\n\tdataend();\n\n\tif ( useecs )\n\t\tgenecs();\n\n\t/* Don't have to dump the actual full table entries - they were\n\t * created on-the-fly.\n\t */\n\t}\n\n\n/* Generate the code to find the next compressed-table state. */\n\nvoid gen_next_compressed_state( char_map )\nchar *char_map;\n\t{\n\tindent_put2s( \"register YY_CHAR yy_c = %s;\", char_map );\n\n\t/* Save the backing-up info \\before/ computing the next state\n\t * because we always compute one more state than needed - we\n\t * always proceed until we reach a jam state\n\t */\n\tgen_backing_up();\n\n\tindent_puts(\n\"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\" );\n\tindent_up();\n\tindent_puts( \"{\" );\n\tindent_puts( \"yy_current_state = (int) yy_def[yy_current_state];\" );\n\n\tif ( usemecs )\n\t\t{\n\t\t/* We've arrange it so that templates are never chained\n\t\t * to one another.  This means we can afford to make a\n\t\t * very simple test to see if we need to convert to\n\t\t * yy_c's meta-equivalence class without worrying\n\t\t * about erroneously looking up the meta-equivalence\n\t\t * class twice\n\t\t */\n\t\tdo_indent();\n\n\t\t/* lastdfa + 2 is the beginning of the templates */\n\t\tout_dec( \"if ( yy_current_state >= %d )\\n\", lastdfa + 2 );\n\n\t\tindent_up();\n\t\tindent_puts( \"yy_c = yy_meta[(unsigned int) yy_c];\" );\n\t\tindent_down();\n\t\t}\n\n\tindent_puts( \"}\" );\n\tindent_down();\n\n\tindent_puts(\n\"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\" );\n\t}\n\n\n/* Generate the code to find the next match. */\n\nvoid gen_next_match()\n\t{\n\t/* NOTE - changes in here should be reflected in gen_next_state() and\n\t * gen_NUL_trans().\n\t */\n\tchar *char_map = useecs ?\n\t\t\t\t\"yy_ec[YY_SC_TO_UI(*yy_cp)]\" :\n\t\t\t\t\"YY_SC_TO_UI(*yy_cp)\";\n\n\tchar *char_map_2 = useecs ?\n\t\t\t\t\"yy_ec[YY_SC_TO_UI(*++yy_cp)]\" :\n\t\t\t\t\"YY_SC_TO_UI(*++yy_cp)\";\n\n\tif ( fulltbl )\n\t\t{\n\t\tindent_put2s(\n\t\"while ( (yy_current_state = yy_nxt[yy_current_state][%s]) > 0 )\",\n\t\t\t\tchar_map );\n\n\t\tindent_up();\n\n\t\tif ( num_backing_up > 0 )\n\t\t\t{\n\t\t\tindent_puts( \"{\" );\t/* } for vi */\n\t\t\tgen_backing_up();\n\t\t\toutc( '\\n' );\n\t\t\t}\n\n\t\tindent_puts( \"++yy_cp;\" );\n\n\t\tif ( num_backing_up > 0 )\n\t\t\t/* { for vi */\n\t\t\tindent_puts( \"}\" );\n\n\t\tindent_down();\n\n\t\toutc( '\\n' );\n\t\tindent_puts( \"yy_current_state = -yy_current_state;\" );\n\t\t}\n\n\telse if ( fullspd )\n\t\t{\n\t\tindent_puts( \"{\" );\t/* } for vi */\n\t\tindent_puts(\n\t\t\"register yyconst struct yy_trans_info *yy_trans_info;\\n\" );\n\t\tindent_puts( \"register YY_CHAR yy_c;\\n\" );\n\t\tindent_put2s( \"for ( yy_c = %s;\", char_map );\n\t\tindent_puts(\n\t\"      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->\" );\n\t\tindent_puts( \"yy_verify == yy_c;\" );\n\t\tindent_put2s( \"      yy_c = %s )\", char_map_2 );\n\n\t\tindent_up();\n\n\t\tif ( num_backing_up > 0 )\n\t\t\tindent_puts( \"{\" );\t/* } for vi */\n\n\t\tindent_puts( \"yy_current_state += yy_trans_info->yy_nxt;\" );\n\n\t\tif ( num_backing_up > 0 )\n\t\t\t{\n\t\t\toutc( '\\n' );\n\t\t\tgen_backing_up();\t/* { for vi */\n\t\t\tindent_puts( \"}\" );\n\t\t\t}\n\n\t\tindent_down();\t/* { for vi */\n\t\tindent_puts( \"}\" );\n\t\t}\n\n\telse\n\t\t{ /* compressed */\n\t\tindent_puts( \"do\" );\n\n\t\tindent_up();\n\t\tindent_puts( \"{\" );\t/* } for vi */\n\n\t\tgen_next_state( false );\n\n\t\tindent_puts( \"++yy_cp;\" );\n\n\t\t/* { for vi */\n\t\tindent_puts( \"}\" );\n\t\tindent_down();\n\n\t\tdo_indent();\n\n\t\tif ( interactive )\n\t\t\tout_dec( \"while ( yy_base[yy_current_state] != %d );\\n\",\n\t\t\t\tjambase );\n\t\telse\n\t\t\tout_dec( \"while ( yy_current_state != %d );\\n\",\n\t\t\t\tjamstate );\n\n\t\tif ( ! reject && ! interactive )\n\t\t\t{\n\t\t\t/* Do the guaranteed-needed backing up to figure out\n\t\t\t * the match.\n\t\t\t */\n\t\t\tindent_puts( \"yy_cp = yy_last_accepting_cpos;\" );\n\t\t\tindent_puts(\n\t\t\t\t\"yy_current_state = yy_last_accepting_state;\" );\n\t\t\t}\n\t\t}\n\t}\n\n\n/* Generate the code to find the next state. */\n\nvoid gen_next_state( worry_about_NULs )\nint worry_about_NULs;\n\t{ /* NOTE - changes in here should be reflected in gen_next_match() */\n\tchar char_map[256];\n\n\tif ( worry_about_NULs && ! nultrans )\n\t\t{\n\t\tif ( useecs )\n\t\t\t(void) sprintf( char_map,\n\t\t\t\t\"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)\",\n\t\t\t\t\tNUL_ec );\n\t\telse\n\t\t\t(void) sprintf( char_map,\n\t\t\t\t\"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)\", NUL_ec );\n\t\t}\n\n\telse\n\t\tstrcpy( char_map, useecs ?\n\t\t\t\"yy_ec[YY_SC_TO_UI(*yy_cp)]\" : \"YY_SC_TO_UI(*yy_cp)\" );\n\n\tif ( worry_about_NULs && nultrans )\n\t\t{\n\t\tif ( ! fulltbl && ! fullspd )\n\t\t\t/* Compressed tables back up *before* they match. */\n\t\t\tgen_backing_up();\n\n\t\tindent_puts( \"if ( *yy_cp )\" );\n\t\tindent_up();\n\t\tindent_puts( \"{\" );\t/* } for vi */\n\t\t}\n\n\tif ( fulltbl )\n\t\tindent_put2s(\n\t\t\t\"yy_current_state = yy_nxt[yy_current_state][%s];\", \n\t\t\t\tchar_map );\n\n\telse if ( fullspd )\n\t\tindent_put2s(\n\t\t\t\"yy_current_state += yy_current_state[%s].yy_nxt;\",\n\t\t\t\tchar_map );\n\n\telse\n\t\tgen_next_compressed_state( char_map );\n\n\tif ( worry_about_NULs && nultrans )\n\t\t{\n\t\t/* { for vi */\n\t\tindent_puts( \"}\" );\n\t\tindent_down();\n\t\tindent_puts( \"else\" );\n\t\tindent_up();\n\t\tindent_puts(\n\t\t\t\"yy_current_state = yy_NUL_trans[yy_current_state];\" );\n\t\tindent_down();\n\t\t}\n\n\tif ( fullspd || fulltbl )\n\t\tgen_backing_up();\n\n\tif ( reject )\n\t\tindent_puts( \"*yy_state_ptr++ = yy_current_state;\" );\n\t}\n\n\n/* Generate the code to make a NUL transition. */\n\nvoid gen_NUL_trans()\n\t{ /* NOTE - changes in here should be reflected in gen_next_match() */\n\t/* Only generate a definition for \"yy_cp\" if we'll generate code\n\t * that uses it.  Otherwise lint and the like complain.\n\t */\n\tint need_backing_up = (num_backing_up > 0 && ! reject);\n\n\tif ( need_backing_up && (! nultrans || fullspd || fulltbl) )\n\t\t/* We're going to need yy_cp lying around for the call\n\t\t * below to gen_backing_up().\n\t\t */\n\t\tindent_puts( \"register char *yy_cp = yy_c_buf_p;\" );\n\n\toutc( '\\n' );\n\n\tif ( nultrans )\n\t\t{\n\t\tindent_puts(\n\t\t\t\"yy_current_state = yy_NUL_trans[yy_current_state];\" );\n\t\tindent_puts( \"yy_is_jam = (yy_current_state == 0);\" );\n\t\t}\n\n\telse if ( fulltbl )\n\t\t{\n\t\tdo_indent();\n\t\tout_dec( \"yy_current_state = yy_nxt[yy_current_state][%d];\\n\",\n\t\t\tNUL_ec );\n\t\tindent_puts( \"yy_is_jam = (yy_current_state <= 0);\" );\n\t\t}\n\n\telse if ( fullspd )\n\t\t{\n\t\tdo_indent();\n\t\tout_dec( \"register int yy_c = %d;\\n\", NUL_ec );\n\n\t\tindent_puts(\n\t\t\"register yyconst struct yy_trans_info *yy_trans_info;\\n\" );\n\t\tindent_puts(\n\t\t\"yy_trans_info = &yy_current_state[(unsigned int) yy_c];\" );\n\t\tindent_puts( \"yy_current_state += yy_trans_info->yy_nxt;\" );\n\n\t\tindent_puts(\n\t\t\t\"yy_is_jam = (yy_trans_info->yy_verify != yy_c);\" );\n\t\t}\n\n\telse\n\t\t{\n\t\tchar NUL_ec_str[20];\n\n\t\t(void) sprintf( NUL_ec_str, \"%d\", NUL_ec );\n\t\tgen_next_compressed_state( NUL_ec_str );\n\n\t\tdo_indent();\n\t\tout_dec( \"yy_is_jam = (yy_current_state == %d);\\n\", jamstate );\n\n\t\tif ( reject )\n\t\t\t{\n\t\t\t/* Only stack this state if it's a transition we\n\t\t\t * actually make.  If we stack it on a jam, then\n\t\t\t * the state stack and yy_c_buf_p get out of sync.\n\t\t\t */\n\t\t\tindent_puts( \"if ( ! yy_is_jam )\" );\n\t\t\tindent_up();\n\t\t\tindent_puts( \"*yy_state_ptr++ = yy_current_state;\" );\n\t\t\tindent_down();\n\t\t\t}\n\t\t}\n\n\t/* If we've entered an accepting state, back up; note that\n\t * compressed tables have *already* done such backing up, so\n\t * we needn't bother with it again.\n\t */\n\tif ( need_backing_up && (fullspd || fulltbl) )\n\t\t{\n\t\toutc( '\\n' );\n\t\tindent_puts( \"if ( ! yy_is_jam )\" );\n\t\tindent_up();\n\t\tindent_puts( \"{\" );\n\t\tgen_backing_up();\n\t\tindent_puts( \"}\" );\n\t\tindent_down();\n\t\t}\n\t}\n\n\n/* Generate the code to find the start state. */\n\nvoid gen_start_state()\n\t{\n\tif ( fullspd )\n\t\t{\n\t\tif ( bol_needed )\n\t\t\t{\n\t\t\tindent_puts(\n\t\"yy_current_state = yy_start_state_list[yy_start + YY_AT_BOL()];\" );\n\t\t\t}\n\t\telse\n\t\t\tindent_puts(\n\t\t\t\"yy_current_state = yy_start_state_list[yy_start];\" );\n\t\t}\n\n\telse\n\t\t{\n\t\tindent_puts( \"yy_current_state = yy_start;\" );\n\n\t\tif ( bol_needed )\n\t\t\tindent_puts( \"yy_current_state += YY_AT_BOL();\" );\n\n\t\tif ( reject )\n\t\t\t{\n\t\t\t/* Set up for storing up states. */\n\t\t\tindent_puts( \"yy_state_ptr = yy_state_buf;\" );\n\t\t\tindent_puts( \"*yy_state_ptr++ = yy_current_state;\" );\n\t\t\t}\n\t\t}\n\t}\n\n\n/* gentabs - generate data statements for the transition tables */\n\nvoid gentabs()\n\t{\n\tint i, j, k, *accset, nacc, *acc_array, total_states;\n\tint end_of_buffer_action = num_rules + 1;\n\n\tacc_array = allocate_integer_array( current_max_dfas );\n\tnummt = 0;\n\n\t/* The compressed table format jams by entering the \"jam state\",\n\t * losing information about the previous state in the process.\n\t * In order to recover the previous state, we effectively need\n\t * to keep backing-up information.\n\t */\n\t++num_backing_up;\n\n\tif ( reject )\n\t\t{\n\t\t/* Write out accepting list and pointer list.\n\t\t *\n\t\t * First we generate the \"yy_acclist\" array.  In the process,\n\t\t * we compute the indices that will go into the \"yy_accept\"\n\t\t * array, and save the indices in the dfaacc array.\n\t\t */\n\t\tint EOB_accepting_list[2];\n\n\t\t/* Set up accepting structures for the End Of Buffer state. */\n\t\tEOB_accepting_list[0] = 0;\n\t\tEOB_accepting_list[1] = end_of_buffer_action;\n\t\taccsiz[end_of_buffer_state] = 1;\n\t\tdfaacc[end_of_buffer_state].dfaacc_set = EOB_accepting_list;\n\n\t\tout_str_dec( long_align ? C_long_decl : C_short_decl,\n\t\t\t\"yy_acclist\", MAX( numas, 1 ) + 1 );\n\n\t\tj = 1;\t/* index into \"yy_acclist\" array */\n\n\t\tfor ( i = 1; i <= lastdfa; ++i )\n\t\t\t{\n\t\t\tacc_array[i] = j;\n\n\t\t\tif ( accsiz[i] != 0 )\n\t\t\t\t{\n\t\t\t\taccset = dfaacc[i].dfaacc_set;\n\t\t\t\tnacc = accsiz[i];\n\n\t\t\t\tif ( trace )\n\t\t\t\t\tfprintf( err,\n\t\t\t\t\t\t_( \"state # %d accepts: \" ),\n\t\t\t\t\t\ti );\n\n\t\t\t\tfor ( k = 1; k <= nacc; ++k )\n\t\t\t\t\t{\n\t\t\t\t\tint accnum = accset[k];\n\n\t\t\t\t\t++j;\n\n\t\t\t\t\tif ( variable_trailing_context_rules &&\n\t\t\t\t\t  ! (accnum & YY_TRAILING_HEAD_MASK) &&\n\t\t\t\t\t   accnum > 0 && accnum <= num_rules &&\n\t\t\t\t\t  rule_type[accnum] == RULE_VARIABLE )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t/* Special hack to flag\n\t\t\t\t\t\t * accepting number as part\n\t\t\t\t\t\t * of trailing context rule.\n\t\t\t\t\t\t */\n\t\t\t\t\t\taccnum |= YY_TRAILING_MASK;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tmkdata( accnum );\n\n\t\t\t\t\tif ( trace )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tfprintf( err, \"[%d]\",\n\t\t\t\t\t\t\taccset[k] );\n\n\t\t\t\t\t\tif ( k < nacc )\n\t\t\t\t\t\t\tfputs( \", \", err );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tputc( '\\n', err );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* add accepting number for the \"jam\" state */\n\t\tacc_array[i] = j;\n\n\t\tdataend();\n\t\t}\n\n\telse\n\t\t{\n\t\tdfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;\n\n\t\tfor ( i = 1; i <= lastdfa; ++i )\n\t\t\tacc_array[i] = dfaacc[i].dfaacc_state;\n\n\t\t/* add accepting number for jam state */\n\t\tacc_array[i] = 0;\n\t\t}\n\n\t/* Spit out \"yy_accept\" array.  If we're doing \"reject\", it'll be\n\t * pointers into the \"yy_acclist\" array.  Otherwise it's actual\n\t * accepting numbers.  In either case, we just dump the numbers.\n\t */\n\n\t/* \"lastdfa + 2\" is the size of \"yy_accept\"; includes room for C arrays\n\t * beginning at 0 and for \"jam\" state.\n\t */\n\tk = lastdfa + 2;\n\n\tif ( reject )\n\t\t/* We put a \"cap\" on the table associating lists of accepting\n\t\t * numbers with state numbers.  This is needed because we tell\n\t\t * where the end of an accepting list is by looking at where\n\t\t * the list for the next state starts.\n\t\t */\n\t\t++k;\n\n\tout_str_dec( long_align ? C_long_decl : C_short_decl, \"yy_accept\", k );\n\n\tfor ( i = 1; i <= lastdfa; ++i )\n\t\t{\n\t\tmkdata( acc_array[i] );\n\n\t\tif ( ! reject && trace && acc_array[i] )\n\t\t\tfprintf( err, _( \"state # %d accepts: [%d]\\n\" ),\n\t\t\t\ti, acc_array[i] );\n\t\t}\n\n\t/* Add entry for \"jam\" state. */\n\tmkdata( acc_array[i] );\n\n\tif ( reject )\n\t\t/* Add \"cap\" for the list. */\n\t\tmkdata( acc_array[i] );\n\n\tdataend();\n\n\tif ( useecs )\n\t\tgenecs();\n\n\tif ( usemecs )\n\t\t{\n\t\t/* Write out meta-equivalence classes (used to index\n\t\t * templates with).\n\t\t */\n\n\t\tif ( trace )\n\t\t\tfputs( _( \"\\n\\nMeta-Equivalence Classes:\\n\" ),\n\t\t\t      err );\n\n\t\tout_str_dec( C_int_decl, \"yy_meta\", numecs + 1 );\n\n\t\tfor ( i = 1; i <= numecs; ++i )\n\t\t\t{\n\t\t\tif ( trace )\n\t\t\t\tfprintf( err, \"%d = %d\\n\",\n\t\t\t\t\ti, ABS( tecbck[i] ) );\n\n\t\t\tmkdata( ABS( tecbck[i] ) );\n\t\t\t}\n\n\t\tdataend();\n\t\t}\n\n\ttotal_states = lastdfa + numtemps;\n\n\tout_str_dec( (tblend >= MAX_SHORT || long_align) ?\n\t\t\tC_long_decl : C_short_decl,\n\t\t\"yy_base\", total_states + 1 );\n\n\tfor ( i = 1; i <= lastdfa; ++i )\n\t\t{\n\t\tregister int d = def[i];\n\n\t\tif ( base[i] == JAMSTATE )\n\t\t\tbase[i] = jambase;\n\n\t\tif ( d == JAMSTATE )\n\t\t\tdef[i] = jamstate;\n\n\t\telse if ( d < 0 )\n\t\t\t{\n\t\t\t/* Template reference. */\n\t\t\t++tmpuses;\n\t\t\tdef[i] = lastdfa - d + 1;\n\t\t\t}\n\n\t\tmkdata( base[i] );\n\t\t}\n\n\t/* Generate jam state's base index. */\n\tmkdata( base[i] );\n\n\tfor ( ++i /* skip jam state */; i <= total_states; ++i )\n\t\t{\n\t\tmkdata( base[i] );\n\t\tdef[i] = jamstate;\n\t\t}\n\n\tdataend();\n\n\tout_str_dec( (total_states >= MAX_SHORT || long_align) ?\n\t\t\tC_long_decl : C_short_decl,\n\t\t\"yy_def\", total_states + 1 );\n\n\tfor ( i = 1; i <= total_states; ++i )\n\t\tmkdata( def[i] );\n\n\tdataend();\n\n\tout_str_dec( (total_states >= MAX_SHORT || long_align) ?\n\t\t\tC_long_decl : C_short_decl,\n\t\t\"yy_nxt\", tblend + 1 );\n\n\tfor ( i = 1; i <= tblend; ++i )\n\t\t{\n\t\t/* Note, the order of the following test is important.\n\t\t * If chk[i] is 0, then nxt[i] is undefined.\n\t\t */\n\t\tif ( chk[i] == 0 || nxt[i] == 0 )\n\t\t\tnxt[i] = jamstate;\t/* new state is the JAM state */\n\n\t\tmkdata( nxt[i] );\n\t\t}\n\n\tdataend();\n\n\tout_str_dec( (total_states >= MAX_SHORT || long_align) ?\n\t\t\tC_long_decl : C_short_decl,\n\t\t\"yy_chk\", tblend + 1 );\n\n\tfor ( i = 1; i <= tblend; ++i )\n\t\t{\n\t\tif ( chk[i] == 0 )\n\t\t\t++nummt;\n\n\t\tmkdata( chk[i] );\n\t\t}\n\n\tdataend();\n\t}\n\n\n/* Write out a formatted string (with a secondary string argument) at the\n * current indentation level, adding a final newline.\n */\n\nvoid indent_put2s( fmt, arg )\nchar fmt[], arg[];\n\t{\n\tdo_indent();\n\tout_str( fmt, arg );\n\toutn( \"\" );\n\t}\n\n\n/* Write out a string at the current indentation level, adding a final\n * newline.\n */\n\nvoid indent_puts( str )\nchar str[];\n\t{\n\tdo_indent();\n\toutn( str );\n\t}\n\n\n/* make_tables - generate transition tables and finishes generating output file\n */\n\nvoid make_tables()\n\t{\n\tregister int i;\n\tint did_eof_rule = false;\n\n\tskelout();\n\n\t/* First, take care of YY_DO_BEFORE_ACTION depending on yymore\n\t * being used.\n\t */\n\tset_indent( 1 );\n\n\tif ( yymore_used && ! yytext_is_array )\n\t\t{\n\t\tindent_puts( \"yytext_ptr -= yy_more_len; \\\\\" );\n\t\tindent_puts( \"yyleng = (int) (yy_cp - yytext_ptr); \\\\\" );\n\t\t}\n\n\telse\n\t\tindent_puts( \"yyleng = (int) (yy_cp - yy_bp); \\\\\" );\n\n\t/* Now also deal with copying yytext_ptr to yytext if needed. */\n\tskelout();\n\tif ( yytext_is_array )\n\t\t{\n\t\tif ( yymore_used )\n\t\t\tindent_puts(\n\t\t\t\t\"if ( yyleng + yy_more_offset >= YYLMAX ) \\\\\" );\n\t\telse\n\t\t\tindent_puts( \"if ( yyleng >= YYLMAX ) \\\\\" );\n\n\t\tindent_up();\n\t\tindent_puts(\n\t\t\"YY_FATAL_ERROR( \\\"token too large, exceeds YYLMAX\\\" ); \\\\\" );\n\t\tindent_down();\n\n\t\tif ( yymore_used )\n\t\t\t{\n\t\t\tindent_puts(\n\"yy_flex_strncpy( &yytext[yy_more_offset], yytext_ptr, yyleng + 1 ); \\\\\" );\n\t\t\tindent_puts( \"yyleng += yy_more_offset; \\\\\" );\n\t\t\tindent_puts(\n\t\t\t\t\"yy_prev_more_offset = yy_more_offset; \\\\\" );\n\t\t\tindent_puts( \"yy_more_offset = 0; \\\\\" );\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tindent_puts(\n\t\t\"yy_flex_strncpy( yytext, yytext_ptr, yyleng + 1 ); \\\\\" );\n\t\t\t}\n\t\t}\n\n\tset_indent( 0 );\n\n\tskelout();\n\n\n\tout_dec( \"#define YY_NUM_RULES %d\\n\", num_rules );\n\tout_dec( \"#define YY_END_OF_BUFFER %d\\n\", num_rules + 1 );\n\n\tif ( fullspd )\n\t\t{\n\t\t/* Need to define the transet type as a size large\n\t\t * enough to hold the biggest offset.\n\t\t */\n\t\tint total_table_size = tblend + numecs + 1;\n\t\tchar *trans_offset_type =\n\t\t\t(total_table_size >= MAX_SHORT || long_align) ?\n\t\t\t\t\"long\" : \"short\";\n\n\t\tset_indent( 0 );\n\t\tindent_puts( \"struct yy_trans_info\" );\n\t\tindent_up();\n\t\tindent_puts( \"{\" ); \t/* } for vi */\n\n\t\tif ( long_align )\n\t\t\tindent_puts( \"long yy_verify;\" );\n\t\telse\n\t\t\tindent_puts( \"short yy_verify;\" );\n\n\t\t/* In cases where its sister yy_verify *is* a \"yes, there is\n\t\t * a transition\", yy_nxt is the offset (in records) to the\n\t\t * next state.  In most cases where there is no transition,\n\t\t * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th\n\t\t * record of a state, though, then yy_nxt is the action number\n\t\t * for that state.\n\t\t */\n\n\t\tindent_put2s( \"%s yy_nxt;\", trans_offset_type );\n\t\tindent_puts( \"};\" );\n\t\tindent_down();\n\t\t}\n\n\tif ( fullspd )\n\t\tgenctbl();\n\telse if ( fulltbl )\n\t\tgenftbl();\n\telse\n\t\tgentabs();\n\n\t/* Definitions for backing up.  We don't need them if REJECT\n\t * is being used because then we use an alternative backin-up\n\t * technique instead.\n\t */\n\tif ( num_backing_up > 0 && ! reject )\n\t\t{\n\t\tif ( ! C_plus_plus )\n\t\t\t{\n\t\t\tindent_puts(\n\t\t\t\"static yy_state_type yy_last_accepting_state;\" );\n\t\t\tindent_puts(\n\t\t\t\t\"static char *yy_last_accepting_cpos;\\n\" );\n\t\t\t}\n\t\t}\n\n\tif ( nultrans )\n\t\t{\n\t\tout_str_dec( C_state_decl, \"yy_NUL_trans\", lastdfa + 1 );\n\n\t\tfor ( i = 1; i <= lastdfa; ++i )\n\t\t\t{\n\t\t\tif ( fullspd )\n\t\t\t\tout_dec( \"    &yy_transition[%d],\\n\", base[i] );\n\t\t\telse\n\t\t\t\tmkdata( nultrans[i] );\n\t\t\t}\n\n\t\tdataend();\n\t\t}\n\n\tif ( ddebug )\n\t\t{ /* Spit out table mapping rules to line numbers. */\n\t\tif ( ! C_plus_plus )\n\t\t\t{\n\t\t\tindent_puts( \"extern int yy_flex_debug;\" );\n\t\t\tindent_puts( \"int yy_flex_debug = 1;\\n\" );\n\t\t\t}\n\n\t\tout_str_dec( long_align ? C_long_decl : C_short_decl,\n\t\t\t\"yy_rule_linenum\", num_rules );\n\t\tfor ( i = 1; i < num_rules; ++i )\n\t\t\tmkdata( rule_linenum[i] );\n\t\tdataend();\n\t\t}\n\n\tif ( reject )\n\t\t{\n\t\t/* Declare state buffer variables. */\n\t\tif ( ! C_plus_plus )\n\t\t\t{\n\t\t\toutn(\n\t\"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;\" );\n\t\t\toutn( \"static char *yy_full_match;\" );\n\t\t\toutn( \"static int yy_lp;\" );\n\t\t\t}\n\n\t\tif ( variable_trailing_context_rules )\n\t\t\t{\n\t\t\tif ( ! C_plus_plus )\n\t\t\t\t{\n\t\t\t\toutn(\n\t\t\t\t\"static int yy_looking_for_trail_begin = 0;\" );\n\t\t\t\toutn( \"static int yy_full_lp;\" );\n\t\t\t\toutn( \"static int *yy_full_state;\" );\n\t\t\t\t}\n\n\t\t\tout_hex( \"#define YY_TRAILING_MASK 0x%x\\n\",\n\t\t\t\t(unsigned int) YY_TRAILING_MASK );\n\t\t\tout_hex( \"#define YY_TRAILING_HEAD_MASK 0x%x\\n\",\n\t\t\t\t(unsigned int) YY_TRAILING_HEAD_MASK );\n\t\t\t}\n\n\t\toutn( \"#define REJECT \\\\\" );\n\t\toutn( \"{ \\\\\" );\t\t/* } for vi */\n\t\toutn(\n\t\"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\\\\" );\n\t\toutn(\n\t\"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\\\\" );\n\n\t\tif ( variable_trailing_context_rules )\n\t\t\t{\n\t\t\toutn(\n\t\t\"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\\\\" );\n\t\t\toutn(\n\t\t\"yy_state_ptr = yy_full_state; /* restore orig. state */ \\\\\" );\n\t\t\toutn(\n\t\"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\\\\" );\n\t\t\t}\n\n\t\toutn( \"++yy_lp; \\\\\" );\n\t\toutn( \"goto find_rule; \\\\\" );\n\t\t/* { for vi */\n\t\toutn( \"}\" );\n\t\t}\n\n\telse\n\t\t{\n\t\toutn(\n\t\t\"/* The intent behind this definition is that it'll catch\" );\n\t\toutn( \" * any uses of REJECT which flex missed.\" );\n\t\toutn( \" */\" );\n\t\toutn( \"#define REJECT reject_used_but_not_detected\" );\n\t\t}\n\n\tif ( yymore_used )\n\t\t{\n\t\tif ( ! C_plus_plus )\n\t\t\t{\n\t\t\tif ( yytext_is_array )\n\t\t\t\t{\n\t\t\t\tindent_puts( \"static int yy_more_offset = 0;\" );\n\t\t\t\tindent_puts(\n\t\t\t\t\t\"static int yy_prev_more_offset = 0;\" );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tindent_puts( \"static int yy_more_flag = 0;\" );\n\t\t\t\tindent_puts( \"static int yy_more_len = 0;\" );\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ( yytext_is_array )\n\t\t\t{\n\t\t\tindent_puts(\n\t\"#define yymore() (yy_more_offset = yy_flex_strlen( yytext ))\" );\n\t\t\tindent_puts( \"#define YY_NEED_STRLEN\" );\n\t\t\tindent_puts( \"#define YY_MORE_ADJ 0\" );\n\t\t\tindent_puts( \"#define YY_RESTORE_YY_MORE_OFFSET \\\\\" );\n\t\t\tindent_up();\n\t\t\tindent_puts( \"{ \\\\\" );\n\t\t\tindent_puts( \"yy_more_offset = yy_prev_more_offset; \\\\\" );\n\t\t\tindent_puts( \"yyleng -= yy_more_offset; \\\\\" );\n\t\t\tindent_puts( \"}\" );\n\t\t\tindent_down();\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tindent_puts( \"#define yymore() (yy_more_flag = 1)\" );\n\t\t\tindent_puts( \"#define YY_MORE_ADJ yy_more_len\" );\n\t\t\tindent_puts( \"#define YY_RESTORE_YY_MORE_OFFSET\" );\n\t\t\t}\n\t\t}\n\n\telse\n\t\t{\n\t\tindent_puts( \"#define yymore() yymore_used_but_not_detected\" );\n\t\tindent_puts( \"#define YY_MORE_ADJ 0\" );\n\t\tindent_puts( \"#define YY_RESTORE_YY_MORE_OFFSET\" );\n\t\t}\n\n\tif ( ! C_plus_plus )\n\t\t{\n\t\tif ( yytext_is_array )\n\t\t\t{\n\t\t\toutn( \"#ifndef YYLMAX\" );\n\t\t\toutn( \"#define YYLMAX 8192\" );\n\t\t\toutn( \"#endif\\n\" );\n\t\t\toutn( \"char yytext[YYLMAX];\" );\n\t\t\toutn( \"char *yytext_ptr;\" );\n\t\t\t}\n\n\t\telse\n\t\t\toutn( \"char *yytext;\" );\n\t\t}\n\n\tout( &action_array[defs1_offset] );\n\n\tline_directive_out( stdout, 0 );\n\n\tskelout();\n\n\tif ( ! C_plus_plus )\n\t\t{\n\t\tif ( use_read )\n\t\t\t{\n\t\t\toutn(\n\"\\tif ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\\\\" );\n\t\t\toutn(\n\t\t\"\\t\\tYY_FATAL_ERROR( \\\"input in flex scanner failed\\\" );\" );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\toutn(\n\t\t\t\"\\tif ( yy_current_buffer->yy_is_interactive ) \\\\\" );\n\t\t\toutn( \"\\t\\t{ \\\\\" );\n\t\t\toutn( \"\\t\\tint c = '*', n; \\\\\" );\n\t\t\toutn( \"\\t\\tfor ( n = 0; n < max_size && \\\\\" );\n\toutn( \"\\t\\t\\t     (c = getc( yyin )) != EOF && c != '\\\\n'; ++n ) \\\\\" );\n\t\t\toutn( \"\\t\\t\\tbuf[n] = (char) c; \\\\\" );\n\t\t\toutn( \"\\t\\tif ( c == '\\\\n' ) \\\\\" );\n\t\t\toutn( \"\\t\\t\\tbuf[n++] = (char) c; \\\\\" );\n\t\t\toutn( \"\\t\\tif ( c == EOF && ferror( yyin ) ) \\\\\" );\n\t\t\toutn(\n\t\"\\t\\t\\tYY_FATAL_ERROR( \\\"input in flex scanner failed\\\" ); \\\\\" );\n\t\t\toutn( \"\\t\\tresult = n; \\\\\" );\n\t\t\toutn( \"\\t\\t} \\\\\" );\n\t\t\toutn(\n\t\"\\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\\\\" );\n\t\t\toutn( \"\\t\\t  && ferror( yyin ) ) \\\\\" );\n\t\t\toutn(\n\t\t\"\\t\\tYY_FATAL_ERROR( \\\"input in flex scanner failed\\\" );\" );\n\t\t\t}\n\t\t}\n\n\tskelout();\n\n\tindent_puts( \"#define YY_RULE_SETUP \\\\\" );\n\tindent_up();\n\tif ( bol_needed )\n\t\t{\n\t\tindent_puts( \"if ( yyleng > 0 ) \\\\\" );\n\t\tindent_up();\n\t\tindent_puts( \"yy_current_buffer->yy_at_bol = \\\\\" );\n\t\tindent_puts( \"\\t\\t(yytext[yyleng - 1] == '\\\\n'); \\\\\" );\n\t\tindent_down();\n\t\t}\n\tindent_puts( \"YY_USER_ACTION\" );\n\tindent_down();\n\n\tskelout();\n\n\t/* Copy prolog to output file. */\n\tout( &action_array[prolog_offset] );\n\n\tline_directive_out( stdout, 0 );\n\n\tskelout();\n\n\tset_indent( 2 );\n\n\tif ( yymore_used && ! yytext_is_array )\n\t\t{\n\t\tindent_puts( \"yy_more_len = 0;\" );\n\t\tindent_puts( \"if ( yy_more_flag )\" );\n\t\tindent_up();\n\t\tindent_puts( \"{\" );\n\t\tindent_puts( \"yy_more_len = yy_c_buf_p - yytext_ptr;\" );\n\t\tindent_puts( \"yy_more_flag = 0;\" );\n\t\tindent_puts( \"}\" );\n\t\tindent_down();\n\t\t}\n\n\tskelout();\n\n\tgen_start_state();\n\n\t/* Note, don't use any indentation. */\n\toutn( \"yy_match:\" );\n\tgen_next_match();\n\n\tskelout();\n\tset_indent( 2 );\n\tgen_find_action();\n\n\tskelout();\n\tif ( do_yylineno )\n\t\t{\n\t\tindent_puts( \"if ( yy_act != YY_END_OF_BUFFER )\" );\n\t\tindent_up();\n\t\tindent_puts( \"{\" );\n\t\tindent_puts( \"int yyl;\" );\n\t\tindent_puts( \"for ( yyl = 0; yyl < yyleng; ++yyl )\" );\n\t\tindent_up();\n\t\tindent_puts( \"if ( yytext[yyl] == '\\\\n' )\" );\n\t\tindent_up();\n\t\tindent_puts( \"++yylineno;\" );\n\t\tindent_down();\n\t\tindent_down();\n\t\tindent_puts( \"}\" );\n\t\tindent_down();\n\t\t}\n\n\tskelout();\n\tif ( ddebug )\n\t\t{\n\t\tindent_puts( \"if ( yy_flex_debug )\" );\n\t\tindent_up();\n\n\t\tindent_puts( \"{\" );\n\t\tindent_puts( \"if ( yy_act == 0 )\" );\n\t\tindent_up();\n\t\tindent_puts( C_plus_plus ?\n\t\t\t\"cerr << \\\"--scanner backing up\\\\n\\\";\" :\n\t\t\t\"fprintf( err, \\\"--scanner backing up\\\\n\\\" );\" );\n\t\tindent_down();\n\n\t\tdo_indent();\n\t\tout_dec( \"else if ( yy_act < %d )\\n\", num_rules );\n\t\tindent_up();\n\n\t\tif ( C_plus_plus )\n\t\t\t{\n\t\t\tindent_puts(\n\t\"cerr << \\\"--accepting rule at line \\\" << yy_rule_linenum[yy_act] <<\" );\n\t\t\tindent_puts(\n\t\t\t\"         \\\"(\\\\\\\"\\\" << yytext << \\\"\\\\\\\")\\\\n\\\";\" );\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tindent_puts(\n\t\"fprintf( err, \\\"--accepting rule at line %d (\\\\\\\"%s\\\\\\\")\\\\n\\\",\" );\n\n\t\t\tindent_puts(\n\t\t\t\t\"         yy_rule_linenum[yy_act], yytext );\" );\n\t\t\t}\n\n\t\tindent_down();\n\n\t\tdo_indent();\n\t\tout_dec( \"else if ( yy_act == %d )\\n\", num_rules );\n\t\tindent_up();\n\n\t\tif ( C_plus_plus )\n\t\t\t{\n\t\t\tindent_puts(\n\"cerr << \\\"--accepting default rule (\\\\\\\"\\\" << yytext << \\\"\\\\\\\")\\\\n\\\";\" );\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tindent_puts(\n\t\"fprintf( err, \\\"--accepting default rule (\\\\\\\"%s\\\\\\\")\\\\n\\\",\" );\n\t\t\tindent_puts( \"         yytext );\" );\n\t\t\t}\n\n\t\tindent_down();\n\n\t\tdo_indent();\n\t\tout_dec( \"else if ( yy_act == %d )\\n\", num_rules + 1 );\n\t\tindent_up();\n\n\t\tindent_puts( C_plus_plus ?\n\t\t\t\"cerr << \\\"--(end of buffer or a NUL)\\\\n\\\";\" :\n\t\t\"fprintf( err, \\\"--(end of buffer or a NUL)\\\\n\\\" );\" );\n\n\t\tindent_down();\n\n\t\tdo_indent();\n\t\toutn( \"else\" );\n\t\tindent_up();\n\n\t\tif ( C_plus_plus )\n\t\t\t{\n\t\t\tindent_puts(\n\t\"cerr << \\\"--EOF (start condition \\\" << YY_START << \\\")\\\\n\\\";\" );\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tindent_puts(\n\t\"fprintf( err, \\\"--EOF (start condition %d)\\\\n\\\", YY_START );\" );\n\t\t\t}\n\n\t\tindent_down();\n\n\t\tindent_puts( \"}\" );\n\t\tindent_down();\n\t\t}\n\n\t/* Copy actions to output file. */\n\tskelout();\n\tindent_up();\n\tgen_bu_action();\n\tout( &action_array[action_offset] );\n\n\tline_directive_out( stdout, 0 );\n\n\t/* generate cases for any missing EOF rules */\n\tfor ( i = 1; i <= lastsc; ++i )\n\t\tif ( ! sceof[i] )\n\t\t\t{\n\t\t\tdo_indent();\n\t\t\tout_str( \"case YY_STATE_EOF(%s):\\n\", scname[i] );\n\t\t\tdid_eof_rule = true;\n\t\t\t}\n\n\tif ( did_eof_rule )\n\t\t{\n\t\tindent_up();\n\t\tindent_puts( \"yyterminate();\" );\n\t\tindent_down();\n\t\t}\n\n\n\t/* Generate code for handling NUL's, if needed. */\n\n\t/* First, deal with backing up and setting up yy_cp if the scanner\n\t * finds that it should JAM on the NUL.\n\t */\n\tskelout();\n\tset_indent( 4 );\n\n\tif ( fullspd || fulltbl )\n\t\tindent_puts( \"yy_cp = yy_c_buf_p;\" );\n\n\telse\n\t\t{ /* compressed table */\n\t\tif ( ! reject && ! interactive )\n\t\t\t{\n\t\t\t/* Do the guaranteed-needed backing up to figure\n\t\t\t * out the match.\n\t\t\t */\n\t\t\tindent_puts( \"yy_cp = yy_last_accepting_cpos;\" );\n\t\t\tindent_puts(\n\t\t\t\t\"yy_current_state = yy_last_accepting_state;\" );\n\t\t\t}\n\n\t\telse\n\t\t\t/* Still need to initialize yy_cp, though\n\t\t\t * yy_current_state was set up by\n\t\t\t * yy_get_previous_state().\n\t\t\t */\n\t\t\tindent_puts( \"yy_cp = yy_c_buf_p;\" );\n\t\t}\n\n\n\t/* Generate code for yy_get_previous_state(). */\n\tset_indent( 1 );\n\tskelout();\n\n\tgen_start_state();\n\n\tset_indent( 2 );\n\tskelout();\n\tgen_next_state( true );\n\n\tset_indent( 1 );\n\tskelout();\n\tgen_NUL_trans();\n\n\tskelout();\n\tif ( do_yylineno )\n\t\t{ /* update yylineno inside of unput() */\n\t\tindent_puts( \"if ( c == '\\\\n' )\" );\n\t\tindent_up();\n\t\tindent_puts( \"--yylineno;\" );\n\t\tindent_down();\n\t\t}\n\n\tskelout();\n\t/* Update BOL and yylineno inside of input(). */\n\tif ( bol_needed )\n\t\t{\n\t\tindent_puts( \"yy_current_buffer->yy_at_bol = (c == '\\\\n');\" );\n\t\tif ( do_yylineno )\n\t\t\t{\n\t\t\tindent_puts( \"if ( yy_current_buffer->yy_at_bol )\" );\n\t\t\tindent_up();\n\t\t\tindent_puts( \"++yylineno;\" );\n\t\t\tindent_down();\n\t\t\t}\n\t\t}\n\n\telse if ( do_yylineno )\n\t\t{\n\t\tindent_puts( \"if ( c == '\\\\n' )\" );\n\t\tindent_up();\n\t\tindent_puts( \"++yylineno;\" );\n\t\tindent_down();\n\t\t}\n\n\tskelout();\n\n\t/* Copy remainder of input to output. */\n\n\tline_directive_out( stdout, 1 );\n\n\tif ( sectnum == 3 )\n\t\t(void) flexscan(); /* copy remainder of input to output */\n\t}\n/* misc - miscellaneous flex routines */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n\nvoid action_define( defname, value )\nchar *defname;\nint value;\n\t{\n\tchar buf[MAXLINE];\n\n\tif ( (int) strlen( defname ) > MAXLINE / 2 )\n\t\t{\n\t\tformat_pinpoint_message( _( \"name \\\"%s\\\" ridiculously long\" ), \n\t\t\tdefname );\n\t\treturn;\n\t\t}\n\n\tsprintf( buf, \"#define %s %d\\n\", defname, value );\n\tadd_action( buf );\n\t}\n\n\nvoid add_action( new_text )\nchar *new_text;\n\t{\n\tint len = strlen( new_text );\n\n\twhile ( len + action_index >= action_size - 10 /* slop */ )\n\t\t{\n\t\tint new_size = action_size * 2;\n\n\t\tif ( new_size <= 0 )\n\t\t\t/* Increase just a little, to try to avoid overflow\n\t\t\t * on 16-bit machines.\n\t\t\t */\n\t\t\taction_size += action_size / 8;\n\t\telse\n\t\t\taction_size = new_size;\n\n\t\taction_array =\n\t\t\treallocate_character_array( action_array, action_size );\n\t\t}\n\n\tstrcpy( &action_array[action_index], new_text );\n\n\taction_index += len;\n\t}\n\n\n/* allocate_array - allocate memory for an integer array of the given size */\n\nvoid *allocate_array( size, element_size )\nint size;\nsize_t element_size;\n\t{\n\tregister void *mem;\n\tsize_t num_bytes = element_size * size;\n\n\tmem = flex_alloc( num_bytes );\n\tif ( ! mem )\n\t\tflexfatal(\n\t\t\t_( \"memory allocation failed in allocate_array()\" ) );\n\n\treturn mem;\n\t}\n\n\n/* all_lower - true if a string is all lower-case */\n\nint all_lower( str )\nregister char *str;\n\t{\n\twhile ( *str )\n\t\t{\n\t\tif ( ! isascii( (Char) *str ) || ! islower( *str ) )\n\t\t\treturn 0;\n\t\t++str;\n\t\t}\n\n\treturn 1;\n\t}\n\n\n/* all_upper - true if a string is all upper-case */\n\nint all_upper( str )\nregister char *str;\n\t{\n\twhile ( *str )\n\t\t{\n\t\tif ( ! isascii( (Char) *str ) || ! isupper( *str ) )\n\t\t\treturn 0;\n\t\t++str;\n\t\t}\n\n\treturn 1;\n\t}\n\n\n/* bubble - bubble sort an integer array in increasing order\n *\n * synopsis\n *   int v[n], n;\n *   void bubble( v, n );\n *\n * description\n *   sorts the first n elements of array v and replaces them in\n *   increasing order.\n *\n * passed\n *   v - the array to be sorted\n *   n - the number of elements of 'v' to be sorted\n */\n\nvoid bubble( v, n )\nint v[], n;\n\t{\n\tregister int i, j, k;\n\n\tfor ( i = n; i > 1; --i )\n\t\tfor ( j = 1; j < i; ++j )\n\t\t\tif ( v[j] > v[j + 1] )\t/* compare */\n\t\t\t\t{\n\t\t\t\tk = v[j];\t/* exchange */\n\t\t\t\tv[j] = v[j + 1];\n\t\t\t\tv[j + 1] = k;\n\t\t\t\t}\n\t}\n\n\n/* check_char - checks a character to make sure it's within the range\n *\t\twe're expecting.  If not, generates fatal error message\n *\t\tand exits.\n */\n\nvoid check_char( c )\nint c;\n\t{\n\tif ( c >= CSIZE )\n\t\tlerrsf( _( \"bad character '%s' detected in check_char()\" ),\n\t\t\treadable_form( c ) );\n\n\tif ( c >= csize )\n\t\tlerrsf(\n\t\t_( \"scanner requires -8 flag to use the character %s\" ),\n\t\t\treadable_form( c ) );\n\t}\n\n\n\n/* clower - replace upper-case letter to lower-case */\n\nChar clower( c )\nregister int c;\n\t{\n\treturn (Char) ((isascii( c ) && isupper( c )) ? tolower( c ) : c);\n\t}\n\n\n/* copy_string - returns a dynamically allocated copy of a string */\n\nchar *copy_string( str )\nregister const char *str;\n\t{\n\tregister const char *c1;\n\tregister char *c2;\n\tchar *copy;\n\tunsigned int size;\n\n\t/* find length */\n\tfor ( c1 = str; *c1; ++c1 )\n\t\t;\n\n\tsize = (c1 - str + 1) * sizeof( char );\n\tcopy = (char *) flex_alloc( size );\n\n\tif ( copy == NULL )\n\t\tflexfatal( _( \"dynamic memory failure in copy_string()\" ) );\n\n\tfor ( c2 = copy; (*c2++ = *str++) != 0; )\n\t\t;\n\n\treturn copy;\n\t}\n\n\n/* copy_unsigned_string -\n *    returns a dynamically allocated copy of a (potentially) unsigned string\n */\n\nChar *copy_unsigned_string( str )\nregister Char *str;\n\t{\n\tregister Char *c;\n\tChar *copy;\n\n\t/* find length */\n\tfor ( c = str; *c; ++c )\n\t\t;\n\n\tcopy = allocate_Character_array( c - str + 1 );\n\n\tfor ( c = copy; (*c++ = *str++) != 0; )\n\t\t;\n\n\treturn copy;\n\t}\n\n\n/* cshell - shell sort a character array in increasing order\n *\n * synopsis\n *\n *   Char v[n];\n *   int n, special_case_0;\n *   cshell( v, n, special_case_0 );\n *\n * description\n *   Does a shell sort of the first n elements of array v.\n *   If special_case_0 is true, then any element equal to 0\n *   is instead assumed to have infinite weight.\n *\n * passed\n *   v - array to be sorted\n *   n - number of elements of v to be sorted\n */\n\nvoid cshell( v, n, special_case_0 )\nChar v[];\nint n, special_case_0;\n\t{\n\tint gap, i, j, jg;\n\tChar k;\n\n\tfor ( gap = n / 2; gap > 0; gap = gap / 2 )\n\t\tfor ( i = gap; i < n; ++i )\n\t\t\tfor ( j = i - gap; j >= 0; j = j - gap )\n\t\t\t\t{\n\t\t\t\tjg = j + gap;\n\n\t\t\t\tif ( special_case_0 )\n\t\t\t\t\t{\n\t\t\t\t\tif ( v[jg] == 0 )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\telse if ( v[j] != 0 && v[j] <= v[jg] )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\telse if ( v[j] <= v[jg] )\n\t\t\t\t\tbreak;\n\n\t\t\t\tk = v[j];\n\t\t\t\tv[j] = v[jg];\n\t\t\t\tv[jg] = k;\n\t\t\t\t}\n\t}\n\n\n/* dataend - finish up a block of data declarations */\n\nvoid dataend()\n\t{\n\tif ( datapos > 0 )\n\t\tdataflush();\n\n\t/* add terminator for initialization; { for vi */\n\toutn( \"    } ;\\n\" );\n\n\tdataline = 0;\n\tdatapos = 0;\n\t}\n\n\n/* dataflush - flush generated data statements */\n\nvoid dataflush()\n\t{\n\toutc( '\\n' );\n\n\tif ( ++dataline >= NUMDATALINES )\n\t\t{\n\t\t/* Put out a blank line so that the table is grouped into\n\t\t * large blocks that enable the user to find elements easily.\n\t\t */\n\t\toutc( '\\n' );\n\t\tdataline = 0;\n\t\t}\n\n\t/* Reset the number of characters written on the current line. */\n\tdatapos = 0;\n\t}\n\n\n/* flexerror - report an error message and terminate */\n\nvoid flexerror( msg )\nconst char msg[];\n\t{\n\tfprintf( err, \"%s: %s\\n\", program_name, msg );\n\tflexend( 1 );\n\t}\n\n\n/* flexfatal - report a fatal error message and terminate */\n\nvoid flexfatal( msg )\nconst char msg[];\n\t{\n\tfprintf( err, _( \"%s: fatal internal error, %s\\n\" ),\n\t\tprogram_name, msg );\n\texit( 1 );\n\t}\n\n\n/* htoi - convert a hexadecimal digit string to an integer value */\n\nint htoi( str )\nChar str[];\n\t{\n\tunsigned int result;\n\n\t(void) sscanf( (char *) str, \"%x\", &result );\n\n\treturn result;\n\t}\n\n\n/* lerrif - report an error message formatted with one integer argument */\n\nvoid lerrif( msg, arg )\nconst char msg[];\nint arg;\n\t{\n\tchar errmsg[MAXLINE];\n\t(void) sprintf( errmsg, msg, arg );\n\tflexerror( errmsg );\n\t}\n\n\n/* lerrsf - report an error message formatted with one string argument */\n\nvoid lerrsf( msg, arg )\nconst char msg[], arg[];\n\t{\n\tchar errmsg[MAXLINE];\n\n\t(void) sprintf( errmsg, msg, arg );\n\tflexerror( errmsg );\n\t}\n\n\n/* line_directive_out - spit out a \"#line\" statement */\n\nvoid line_directive_out( output_file, do_infile )\nFILE *output_file;\nint do_infile;\n\t{\n\tchar directive[MAXLINE], filename[MAXLINE];\n\tchar *s1, *s2, *s3;\n\tstatic char line_fmt[] = \"#line %d \\\"%s\\\"\\n\";\n\n\tif ( ! gen_line_dirs )\n\t\treturn;\n\n\tif ( (do_infile && ! infilename) || (! do_infile && ! outfilename) )\n\t\t/* don't know the filename to use, skip */\n\t\treturn;\n\n\ts1 = do_infile ? infilename : outfilename;\n\ts2 = filename;\n\ts3 = &filename[sizeof( filename ) - 2];\n\n\twhile ( s2 < s3 && *s1 )\n\t\t{\n\t\tif ( *s1 == '\\\\' )\n\t\t\t/* Escape the '\\' */\n\t\t\t*s2++ = '\\\\';\n\n\t\t*s2++ = *s1++;\n\t\t}\n\n\t*s2 = '\\0';\n\n\tif ( do_infile )\n\t\tsprintf( directive, line_fmt, linenum, filename );\n\telse\n\t\t{\n\t\tif ( output_file == stdout )\n\t\t\t/* Account for the line directive itself. */\n\t\t\t++out_linenum;\n\n\t\tsprintf( directive, line_fmt, out_linenum, filename );\n\t\t}\n\n\t/* If output_file is nil then we should put the directive in\n\t * the accumulated actions.\n\t */\n\tif ( output_file )\n\t\t{\n\t\tfputs( directive, output_file );\n\t\t}\n\telse\n\t\tadd_action( directive );\n\t}\n\n\n/* mark_defs1 - mark the current position in the action array as\n *               representing where the user's section 1 definitions end\n *\t\t and the prolog begins\n */\nvoid mark_defs1()\n\t{\n\tdefs1_offset = 0;\n\taction_array[action_index++] = '\\0';\n\taction_offset = prolog_offset = action_index;\n\taction_array[action_index] = '\\0';\n\t}\n\n\n/* mark_prolog - mark the current position in the action array as\n *               representing the end of the action prolog\n */\nvoid mark_prolog()\n\t{\n\taction_array[action_index++] = '\\0';\n\taction_offset = action_index;\n\taction_array[action_index] = '\\0';\n\t}\n\n\n/* mk2data - generate a data statement for a two-dimensional array\n *\n * Generates a data statement initializing the current 2-D array to \"value\".\n */\nvoid mk2data( value )\nint value;\n\t{\n\tif ( datapos >= NUMDATAITEMS )\n\t\t{\n\t\toutc( ',' );\n\t\tdataflush();\n\t\t}\n\n\tif ( datapos == 0 )\n\t\t/* Indent. */\n\t\tout( \"    \" );\n\n\telse\n\t\toutc( ',' );\n\n\t++datapos;\n\n\tout_dec( \"%5d\", value );\n\t}\n\n\n/* mkdata - generate a data statement\n *\n * Generates a data statement initializing the current array element to\n * \"value\".\n */\nvoid mkdata( value )\nint value;\n\t{\n\tif ( datapos >= NUMDATAITEMS )\n\t\t{\n\t\toutc( ',' );\n\t\tdataflush();\n\t\t}\n\n\tif ( datapos == 0 )\n\t\t/* Indent. */\n\t\tout( \"    \" );\n\telse\n\t\toutc( ',' );\n\n\t++datapos;\n\n\tout_dec( \"%5d\", value );\n\t}\n\n\n/* myctoi - return the integer represented by a string of digits */\n\nint myctoi( array )\nchar array[];\n\t{\n\tint val = 0;\n\n\t(void) sscanf( array, \"%d\", &val );\n\n\treturn val;\n\t}\n\n\n/* myesc - return character corresponding to escape sequence */\n\nChar myesc( array )\nChar array[];\n\t{\n\tChar c, esc_char;\n\n\tswitch ( array[1] )\n\t\t{\n\t\tcase 'b': return '\\b';\n\t\tcase 'f': return '\\f';\n\t\tcase 'n': return '\\n';\n\t\tcase 'r': return '\\r';\n\t\tcase 't': return '\\t';\n\n#if __STDC__\n\t\tcase 'a': return '\\a';\n\t\tcase 'v': return '\\v';\n#else\n\t\tcase 'a': return '\\007';\n\t\tcase 'v': return '\\013';\n#endif\n\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\t\t{ /* \\<octal> */\n\t\t\tint sptr = 1;\n\n\t\t\twhile ( isascii( array[sptr] ) &&\n\t\t\t\tisdigit( array[sptr] ) )\n\t\t\t\t/* Don't increment inside loop control\n\t\t\t\t * because if isdigit() is a macro it might\n\t\t\t\t * expand into multiple increments ...\n\t\t\t\t */\n\t\t\t\t++sptr;\n\n\t\t\tc = array[sptr];\n\t\t\tarray[sptr] = '\\0';\n\n\t\t\tesc_char = otoi( array + 1 );\n\n\t\t\tarray[sptr] = c;\n\n\t\t\treturn esc_char;\n\t\t\t}\n\n\t\tcase 'x':\n\t\t\t{ /* \\x<hex> */\n\t\t\tint sptr = 2;\n\n\t\t\twhile ( isascii( array[sptr] ) &&\n\t\t\t\tisxdigit( (char) array[sptr] ) )\n\t\t\t\t/* Don't increment inside loop control\n\t\t\t\t * because if isdigit() is a macro it might\n\t\t\t\t * expand into multiple increments ...\n\t\t\t\t */\n\t\t\t\t++sptr;\n\n\t\t\tc = array[sptr];\n\t\t\tarray[sptr] = '\\0';\n\n\t\t\tesc_char = htoi( array + 2 );\n\n\t\t\tarray[sptr] = c;\n\n\t\t\treturn esc_char;\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn array[1];\n\t\t}\n\t}\n\n\n/* otoi - convert an octal digit string to an integer value */\n\nint otoi( str )\nChar str[];\n\t{\n\tunsigned int result;\n\n\t(void) sscanf( (char *) str, \"%o\", &result );\n\treturn result;\n\t}\n\n\n/* out - various flavors of outputing a (possibly formatted) string for the\n *\t generated scanner, keeping track of the line count.\n */\n\nvoid out( str )\nconst char str[];\n\t{\n\tfputs( str, stdout );\n\tout_line_count( str );\n\t}\n\nvoid out_dec( fmt, n )\nconst char fmt[];\nint n;\n\t{\n\tprintf( fmt, n );\n\tout_line_count( fmt );\n\t}\n\nvoid out_dec2( fmt, n1, n2 )\nconst char fmt[];\nint n1, n2;\n\t{\n\tprintf( fmt, n1, n2 );\n\tout_line_count( fmt );\n\t}\n\nvoid out_hex( fmt, x )\nconst char fmt[];\nunsigned int x;\n\t{\n\tprintf( fmt, x );\n\tout_line_count( fmt );\n\t}\n\nvoid out_line_count( str )\nconst char str[];\n\t{\n\tregister int i;\n\n\tfor ( i = 0; str[i]; ++i )\n\t\tif ( str[i] == '\\n' )\n\t\t\t++out_linenum;\n\t}\n\nvoid out_str( fmt, str )\nconst char fmt[], str[];\n\t{\n\tprintf( fmt, str );\n\tout_line_count( fmt );\n\tout_line_count( str );\n\t}\n\nvoid out_str3( fmt, s1, s2, s3 )\nconst char fmt[], s1[], s2[], s3[];\n\t{\n\tprintf( fmt, s1, s2, s3 );\n\tout_line_count( fmt );\n\tout_line_count( s1 );\n\tout_line_count( s2 );\n\tout_line_count( s3 );\n\t}\n\nvoid out_str_dec( fmt, str, n )\nconst char fmt[], str[];\nint n;\n\t{\n\tprintf( fmt, str, n );\n\tout_line_count( fmt );\n\tout_line_count( str );\n\t}\n\nvoid outc( c )\nint c;\n\t{\n\tputc( c, stdout );\n\n\tif ( c == '\\n' )\n\t\t++out_linenum;\n\t}\n\nvoid outn( str )\nconst char str[];\n\t{\n\tputs( str );\n\tout_line_count( str );\n\t++out_linenum;\n\t}\n\n\n/* readable_form - return the the human-readable form of a character\n *\n * The returned string is in static storage.\n */\n\nchar *readable_form( c )\nregister int c;\n\t{\n\tstatic char rform[10];\n\n\tif ( (c >= 0 && c < 32) || c >= 127 )\n\t\t{\n\t\tswitch ( c )\n\t\t\t{\n\t\t\tcase '\\b': return \"\\\\b\";\n\t\t\tcase '\\f': return \"\\\\f\";\n\t\t\tcase '\\n': return \"\\\\n\";\n\t\t\tcase '\\r': return \"\\\\r\";\n\t\t\tcase '\\t': return \"\\\\t\";\n\n#if __STDC__\n\t\t\tcase '\\a': return \"\\\\a\";\n\t\t\tcase '\\v': return \"\\\\v\";\n#endif\n\n\t\t\tdefault:\n\t\t\t\t(void) sprintf( rform, \"\\\\%.3o\",\n\t\t\t\t\t\t(unsigned int) c );\n\t\t\t\treturn rform;\n\t\t\t}\n\t\t}\n\n\telse if ( c == ' ' )\n\t\treturn \"' '\";\n\n\telse\n\t\t{\n\t\trform[0] = c;\n\t\trform[1] = '\\0';\n\n\t\treturn rform;\n\t\t}\n\t}\n\n\n/* reallocate_array - increase the size of a dynamic array */\n\nvoid *reallocate_array( array, size, element_size )\nvoid *array;\nint size;\nsize_t element_size;\n\t{\n\tregister void *new_array;\n\tsize_t num_bytes = element_size * size;\n\n\tnew_array = flex_realloc( array, num_bytes );\n\tif ( ! new_array )\n\t\tflexfatal( _( \"attempt to increase array size failed\" ) );\n\n\treturn new_array;\n\t}\n\n\n/* skelout - write out one section of the skeleton file\n *\n * Description\n *    Copies skelfile or skel array to stdout until a line beginning with\n *    \"%%\" or EOF is found.\n */\nvoid skelout()\n\t{\n\tchar buf_storage[MAXLINE];\n\tchar *buf = buf_storage;\n\tint do_copy = 1;\n\n\t/* Loop pulling lines either from the skelfile, if we're using\n\t * one, or from the skel[] array.\n\t */\n\twhile ( skelfile ?\n\t\t(fgets( buf, MAXLINE, skelfile ) != NULL) :\n\t\t((buf = (char *) skel[skel_ind++]) != 0) )\n\t\t{ /* copy from skel array */\n\t\tif ( buf[0] == '%' )\n\t\t\t{ /* control line */\n\t\t\tswitch ( buf[1] )\n\t\t\t\t{\n\t\t\t\tcase '%':\n\t\t\t\t\treturn;\n\n\t\t\t\tcase '+':\n\t\t\t\t\tdo_copy = C_plus_plus;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '-':\n\t\t\t\t\tdo_copy = ! C_plus_plus;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '*':\n\t\t\t\t\tdo_copy = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tflexfatal(\n\t\t\t\t\t_( \"bad line in skeleton file\" ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( do_copy )\n\t\t\t{\n\t\t\tif ( skelfile )\n\t\t\t\t/* Skeleton file reads include final\n\t\t\t\t * newline, skel[] array does not.\n\t\t\t\t */\n\t\t\t\tout( buf );\n\t\t\telse\n\t\t\t\toutn( buf );\n\t\t\t}\n\t\t}\n\t}\n\n\n/* transition_struct_out - output a yy_trans_info structure\n *\n * outputs the yy_trans_info structure with the two elements, element_v and\n * element_n.  Formats the output with spaces and carriage returns.\n */\n\nvoid transition_struct_out( element_v, element_n )\nint element_v, element_n;\n\t{\n\tout_dec2( \" {%4d,%4d },\", element_v, element_n );\n\n\tdatapos += TRANS_STRUCT_PRINT_LENGTH;\n\n\tif ( datapos >= 79 - TRANS_STRUCT_PRINT_LENGTH )\n\t\t{\n\t\toutc( '\\n' );\n\n\t\tif ( ++dataline % 10 == 0 )\n\t\t\toutc( '\\n' );\n\n\t\tdatapos = 0;\n\t\t}\n\t}\n\n\n/* The following is only needed when building flex's parser using certain\n * broken versions of bison.\n */\nvoid *yy_flex_xmalloc( size )\nint size;\n\t{\n\tvoid *result = flex_alloc( (size_t) size );\n\n\tif ( ! result  )\n\t\tflexfatal(\n\t\t\t_( \"memory allocation failed in yy_flex_xmalloc()\" ) );\n\n\treturn result;\n\t}\n\n\n/* zero_out - set a region of memory to 0\n *\n * Sets region_ptr[0] through region_ptr[size_in_bytes - 1] to zero.\n */\n\nvoid zero_out( region_ptr, size_in_bytes )\nchar *region_ptr;\nsize_t size_in_bytes;\n\t{\n\tregister char *rp, *rp_end;\n\n\trp = region_ptr;\n\trp_end = region_ptr + size_in_bytes;\n\n\twhile ( rp < rp_end )\n\t\t*rp++ = 0;\n\t}\n/* nfa - NFA construction routines */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n\n/* declare functions that have forward references */\n\nint dupmachine PROTO((int));\nvoid mkxtion PROTO((int, int));\n\n\n/* add_accept - add an accepting state to a machine\n *\n * accepting_number becomes mach's accepting number.\n */\n\nvoid add_accept( mach, accepting_number )\nint mach, accepting_number;\n\t{\n\t/* Hang the accepting number off an epsilon state.  if it is associated\n\t * with a state that has a non-epsilon out-transition, then the state\n\t * will accept BEFORE it makes that transition, i.e., one character\n\t * too soon.\n\t */\n\n\tif ( transchar[finalst[mach]] == SYM_EPSILON )\n\t\taccptnum[finalst[mach]] = accepting_number;\n\n\telse\n\t\t{\n\t\tint astate = mkstate( SYM_EPSILON );\n\t\taccptnum[astate] = accepting_number;\n\t\t(void) link_machines( mach, astate );\n\t\t}\n\t}\n\n\n/* copysingl - make a given number of copies of a singleton machine\n *\n * synopsis\n *\n *   newsng = copysingl( singl, num );\n *\n *     newsng - a new singleton composed of num copies of singl\n *     singl  - a singleton machine\n *     num    - the number of copies of singl to be present in newsng\n */\n\nint copysingl( singl, num )\nint singl, num;\n\t{\n\tint copy, i;\n\n\tcopy = mkstate( SYM_EPSILON );\n\n\tfor ( i = 1; i <= num; ++i )\n\t\tcopy = link_machines( copy, dupmachine( singl ) );\n\n\treturn copy;\n\t}\n\n\n/* dumpnfa - debugging routine to write out an nfa */\n\nvoid dumpnfa( state1 )\nint state1;\n\n\t{\n\tint sym, tsp1, tsp2, anum, ns;\n\n\tfprintf( err,\n\t_( \"\\n\\n********** beginning dump of nfa with start state %d\\n\" ),\n\t\tstate1 );\n\n\t/* We probably should loop starting at firstst[state1] and going to\n\t * lastst[state1], but they're not maintained properly when we \"or\"\n\t * all of the rules together.  So we use our knowledge that the machine\n\t * starts at state 1 and ends at lastnfa.\n\t */\n\n\t/* for ( ns = firstst[state1]; ns <= lastst[state1]; ++ns ) */\n\tfor ( ns = 1; ns <= lastnfa; ++ns )\n\t\t{\n\t\tfprintf( err, _( \"state # %4d\\t\" ), ns );\n\n\t\tsym = transchar[ns];\n\t\ttsp1 = trans1[ns];\n\t\ttsp2 = trans2[ns];\n\t\tanum = accptnum[ns];\n\n\t\tfprintf( err, \"%3d:  %4d, %4d\", sym, tsp1, tsp2 );\n\n\t\tif ( anum != NIL )\n\t\t\tfprintf( err, \"  [%d]\", anum );\n\n\t\tfprintf( err, \"\\n\" );\n\t\t}\n\n\tfprintf( err, _( \"********** end of dump\\n\" ) );\n\t}\n\n\n/* dupmachine - make a duplicate of a given machine\n *\n * synopsis\n *\n *   copy = dupmachine( mach );\n *\n *     copy - holds duplicate of mach\n *     mach - machine to be duplicated\n *\n * note that the copy of mach is NOT an exact duplicate; rather, all the\n * transition states values are adjusted so that the copy is self-contained,\n * as the original should have been.\n *\n * also note that the original MUST be contiguous, with its low and high\n * states accessible by the arrays firstst and lastst\n */\n\nint dupmachine( mach )\nint mach;\n\t{\n\tint i, init, state_offset;\n\tint state = 0;\n\tint last = lastst[mach];\n\n\tfor ( i = firstst[mach]; i <= last; ++i )\n\t\t{\n\t\tstate = mkstate( transchar[i] );\n\n\t\tif ( trans1[i] != NO_TRANSITION )\n\t\t\t{\n\t\t\tmkxtion( finalst[state], trans1[i] + state - i );\n\n\t\t\tif ( transchar[i] == SYM_EPSILON &&\n\t\t\t     trans2[i] != NO_TRANSITION )\n\t\t\t\tmkxtion( finalst[state],\n\t\t\t\t\ttrans2[i] + state - i );\n\t\t\t}\n\n\t\taccptnum[state] = accptnum[i];\n\t\t}\n\n\tif ( state == 0 )\n\t\tflexfatal( _( \"empty machine in dupmachine()\" ) );\n\n\tstate_offset = state - i + 1;\n\n\tinit = mach + state_offset;\n\tfirstst[init] = firstst[mach] + state_offset;\n\tfinalst[init] = finalst[mach] + state_offset;\n\tlastst[init] = lastst[mach] + state_offset;\n\n\treturn init;\n\t}\n\n\n/* finish_rule - finish up the processing for a rule\n *\n * An accepting number is added to the given machine.  If variable_trail_rule\n * is true then the rule has trailing context and both the head and trail\n * are variable size.  Otherwise if headcnt or trailcnt is non-zero then\n * the machine recognizes a pattern with trailing context and headcnt is\n * the number of characters in the matched part of the pattern, or zero\n * if the matched part has variable length.  trailcnt is the number of\n * trailing context characters in the pattern, or zero if the trailing\n * context has variable length.\n */\n\nvoid finish_rule( mach, variable_trail_rule, headcnt, trailcnt )\nint mach, variable_trail_rule, headcnt, trailcnt;\n\t{\n\tchar action_text[MAXLINE];\n\n\tadd_accept( mach, num_rules );\n\n\t/* We did this in new_rule(), but it often gets the wrong\n\t * number because we do it before we start parsing the current rule.\n\t */\n\trule_linenum[num_rules] = linenum;\n\n\t/* If this is a continued action, then the line-number has already\n\t * been updated, giving us the wrong number.\n\t */\n\tif ( continued_action )\n\t\t--rule_linenum[num_rules];\n\n\tsprintf( action_text, \"case %d:\\n\", num_rules );\n\tadd_action( action_text );\n\n\tif ( variable_trail_rule )\n\t\t{\n\t\trule_type[num_rules] = RULE_VARIABLE;\n\n\t\tif ( performance_report > 0 )\n\t\t\tfprintf( err,\n\t\t\t_( \"Variable trailing context rule at line %d\\n\" ),\n\t\t\t\trule_linenum[num_rules] );\n\n\t\tvariable_trailing_context_rules = true;\n\t\t}\n\n\telse\n\t\t{\n\t\trule_type[num_rules] = RULE_NORMAL;\n\n\t\tif ( headcnt > 0 || trailcnt > 0 )\n\t\t\t{\n\t\t\t/* Do trailing context magic to not match the trailing\n\t\t\t * characters.\n\t\t\t */\n\t\t\tchar *scanner_cp = \"yy_c_buf_p = yy_cp\";\n\t\t\tchar *scanner_bp = \"yy_bp\";\n\n\t\t\tadd_action(\n\t\"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\\n\" );\n\n\t\t\tif ( headcnt > 0 )\n\t\t\t\t{\n\t\t\t\tsprintf( action_text, \"%s = %s + %d;\\n\",\n\t\t\t\tscanner_cp, scanner_bp, headcnt );\n\t\t\t\tadd_action( action_text );\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tsprintf( action_text, \"%s -= %d;\\n\",\n\t\t\t\t\tscanner_cp, trailcnt );\n\t\t\t\tadd_action( action_text );\n\t\t\t\t}\n\n\t\t\tadd_action(\n\t\t\t\"YY_DO_BEFORE_ACTION; /* set up yytext again */\\n\" );\n\t\t\t}\n\t\t}\n\n\t/* Okay, in the action code at this point yytext and yyleng have\n\t * their proper final values for this rule, so here's the point\n\t * to do any user action.  But don't do it for continued actions,\n\t * as that'll result in multiple YY_RULE_SETUP's.\n\t */\n\tif ( ! continued_action )\n\t\tadd_action( \"YY_RULE_SETUP\\n\" );\n\n\tline_directive_out( (FILE *) 0, 1 );\n\t}\n\n\n/* link_machines - connect two machines together\n *\n * synopsis\n *\n *   new = link_machines( first, last );\n *\n *     new    - a machine constructed by connecting first to last\n *     first  - the machine whose successor is to be last\n *     last   - the machine whose predecessor is to be first\n *\n * note: this routine concatenates the machine first with the machine\n *  last to produce a machine new which will pattern-match first first\n *  and then last, and will fail if either of the sub-patterns fails.\n *  FIRST is set to new by the operation.  last is unmolested.\n */\n\nint link_machines( first, last )\nint first, last;\n\t{\n\tif ( first == NIL )\n\t\treturn last;\n\n\telse if ( last == NIL )\n\t\treturn first;\n\n\telse\n\t\t{\n\t\tmkxtion( finalst[first], last );\n\t\tfinalst[first] = finalst[last];\n\t\tlastst[first] = MAX( lastst[first], lastst[last] );\n\t\tfirstst[first] = MIN( firstst[first], firstst[last] );\n\n\t\treturn first;\n\t\t}\n\t}\n\n\n/* mark_beginning_as_normal - mark each \"beginning\" state in a machine\n *                            as being a \"normal\" (i.e., not trailing context-\n *                            associated) states\n *\n * The \"beginning\" states are the epsilon closure of the first state\n */\n\nvoid mark_beginning_as_normal( mach )\nregister int mach;\n\t{\n\tswitch ( state_type[mach] )\n\t\t{\n\t\tcase STATE_NORMAL:\n\t\t\t/* Oh, we've already visited here. */\n\t\t\treturn;\n\n\t\tcase STATE_TRAILING_CONTEXT:\n\t\t\tstate_type[mach] = STATE_NORMAL;\n\n\t\t\tif ( transchar[mach] == SYM_EPSILON )\n\t\t\t\t{\n\t\t\t\tif ( trans1[mach] != NO_TRANSITION )\n\t\t\t\t\tmark_beginning_as_normal(\n\t\t\t\t\t\ttrans1[mach] );\n\n\t\t\t\tif ( trans2[mach] != NO_TRANSITION )\n\t\t\t\t\tmark_beginning_as_normal(\n\t\t\t\t\t\ttrans2[mach] );\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tflexerror(\n\t\t\t_( \"bad state type in mark_beginning_as_normal()\" ) );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n/* mkbranch - make a machine that branches to two machines\n *\n * synopsis\n *\n *   branch = mkbranch( first, second );\n *\n *     branch - a machine which matches either first's pattern or second's\n *     first, second - machines whose patterns are to be or'ed (the | operator)\n *\n * Note that first and second are NEITHER destroyed by the operation.  Also,\n * the resulting machine CANNOT be used with any other \"mk\" operation except\n * more mkbranch's.  Compare with mkor()\n */\n\nint mkbranch( first, second )\nint first, second;\n\t{\n\tint eps;\n\n\tif ( first == NO_TRANSITION )\n\t\treturn second;\n\n\telse if ( second == NO_TRANSITION )\n\t\treturn first;\n\n\teps = mkstate( SYM_EPSILON );\n\n\tmkxtion( eps, first );\n\tmkxtion( eps, second );\n\n\treturn eps;\n\t}\n\n\n/* mkclos - convert a machine into a closure\n *\n * synopsis\n *   new = mkclos( state );\n *\n * new - a new state which matches the closure of \"state\"\n */\n\nint mkclos( state )\nint state;\n\t{\n\treturn mkopt( mkposcl( state ) );\n\t}\n\n\n/* mkopt - make a machine optional\n *\n * synopsis\n *\n *   new = mkopt( mach );\n *\n *     new  - a machine which optionally matches whatever mach matched\n *     mach - the machine to make optional\n *\n * notes:\n *     1. mach must be the last machine created\n *     2. mach is destroyed by the call\n */\n\nint mkopt( mach )\nint mach;\n\t{\n\tint eps;\n\n\tif ( ! SUPER_FREE_EPSILON(finalst[mach]) )\n\t\t{\n\t\teps = mkstate( SYM_EPSILON );\n\t\tmach = link_machines( mach, eps );\n\t\t}\n\n\t/* Can't skimp on the following if FREE_EPSILON(mach) is true because\n\t * some state interior to \"mach\" might point back to the beginning\n\t * for a closure.\n\t */\n\teps = mkstate( SYM_EPSILON );\n\tmach = link_machines( eps, mach );\n\n\tmkxtion( mach, finalst[mach] );\n\n\treturn mach;\n\t}\n\n\n/* mkor - make a machine that matches either one of two machines\n *\n * synopsis\n *\n *   new = mkor( first, second );\n *\n *     new - a machine which matches either first's pattern or second's\n *     first, second - machines whose patterns are to be or'ed (the | operator)\n *\n * note that first and second are both destroyed by the operation\n * the code is rather convoluted because an attempt is made to minimize\n * the number of epsilon states needed\n */\n\nint mkor( first, second )\nint first, second;\n\t{\n\tint eps, orend;\n\n\tif ( first == NIL )\n\t\treturn second;\n\n\telse if ( second == NIL )\n\t\treturn first;\n\n\telse\n\t\t{\n\t\t/* See comment in mkopt() about why we can't use the first\n\t\t * state of \"first\" or \"second\" if they satisfy \"FREE_EPSILON\".\n\t\t */\n\t\teps = mkstate( SYM_EPSILON );\n\n\t\tfirst = link_machines( eps, first );\n\n\t\tmkxtion( first, second );\n\n\t\tif ( SUPER_FREE_EPSILON(finalst[first]) &&\n\t\t     accptnum[finalst[first]] == NIL )\n\t\t\t{\n\t\t\torend = finalst[first];\n\t\t\tmkxtion( finalst[second], orend );\n\t\t\t}\n\n\t\telse if ( SUPER_FREE_EPSILON(finalst[second]) &&\n\t\t\t  accptnum[finalst[second]] == NIL )\n\t\t\t{\n\t\t\torend = finalst[second];\n\t\t\tmkxtion( finalst[first], orend );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\teps = mkstate( SYM_EPSILON );\n\n\t\t\tfirst = link_machines( first, eps );\n\t\t\torend = finalst[first];\n\n\t\t\tmkxtion( finalst[second], orend );\n\t\t\t}\n\t\t}\n\n\tfinalst[first] = orend;\n\treturn first;\n\t}\n\n\n/* mkposcl - convert a machine into a positive closure\n *\n * synopsis\n *   new = mkposcl( state );\n *\n *    new - a machine matching the positive closure of \"state\"\n */\n\nint mkposcl( state )\nint state;\n\t{\n\tint eps;\n\n\tif ( SUPER_FREE_EPSILON(finalst[state]) )\n\t\t{\n\t\tmkxtion( finalst[state], state );\n\t\treturn state;\n\t\t}\n\n\telse\n\t\t{\n\t\teps = mkstate( SYM_EPSILON );\n\t\tmkxtion( eps, state );\n\t\treturn link_machines( state, eps );\n\t\t}\n\t}\n\n\n/* mkrep - make a replicated machine\n *\n * synopsis\n *   new = mkrep( mach, lb, ub );\n *\n *    new - a machine that matches whatever \"mach\" matched from \"lb\"\n *          number of times to \"ub\" number of times\n *\n * note\n *   if \"ub\" is INFINITY then \"new\" matches \"lb\" or more occurrences of \"mach\"\n */\n\nint mkrep( mach, lb, ub )\nint mach, lb, ub;\n\t{\n\tint base_mach, tail, copy, i;\n\n\tbase_mach = copysingl( mach, lb - 1 );\n\n\tif ( ub == INFINITY )\n\t\t{\n\t\tcopy = dupmachine( mach );\n\t\tmach = link_machines( mach,\n\t\tlink_machines( base_mach, mkclos( copy ) ) );\n\t\t}\n\n\telse\n\t\t{\n\t\ttail = mkstate( SYM_EPSILON );\n\n\t\tfor ( i = lb; i < ub; ++i )\n\t\t\t{\n\t\t\tcopy = dupmachine( mach );\n\t\t\ttail = mkopt( link_machines( copy, tail ) );\n\t\t\t}\n\n\t\tmach = link_machines( mach, link_machines( base_mach, tail ) );\n\t\t}\n\n\treturn mach;\n\t}\n\n\n/* mkstate - create a state with a transition on a given symbol\n *\n * synopsis\n *\n *   state = mkstate( sym );\n *\n *     state - a new state matching sym\n *     sym   - the symbol the new state is to have an out-transition on\n *\n * note that this routine makes new states in ascending order through the\n * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE\n * relies on machines being made in ascending order and that they are\n * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge\n * that it admittedly is)\n */\n\nint mkstate( sym )\nint sym;\n\t{\n\tif ( ++lastnfa >= current_mns )\n\t\t{\n\t\tif ( (current_mns += MNS_INCREMENT) >= MAXIMUM_MNS )\n\t\t\tlerrif(\n\t\t_( \"input rules are too complicated (>= %d NFA states)\" ),\n\t\t\t\tcurrent_mns );\n\n\t\t++num_reallocs;\n\n\t\tfirstst = reallocate_integer_array( firstst, current_mns );\n\t\tlastst = reallocate_integer_array( lastst, current_mns );\n\t\tfinalst = reallocate_integer_array( finalst, current_mns );\n\t\ttranschar = reallocate_integer_array( transchar, current_mns );\n\t\ttrans1 = reallocate_integer_array( trans1, current_mns );\n\t\ttrans2 = reallocate_integer_array( trans2, current_mns );\n\t\taccptnum = reallocate_integer_array( accptnum, current_mns );\n\t\tassoc_rule =\n\t\t\treallocate_integer_array( assoc_rule, current_mns );\n\t\tstate_type =\n\t\t\treallocate_integer_array( state_type, current_mns );\n\t\t}\n\n\tfirstst[lastnfa] = lastnfa;\n\tfinalst[lastnfa] = lastnfa;\n\tlastst[lastnfa] = lastnfa;\n\ttranschar[lastnfa] = sym;\n\ttrans1[lastnfa] = NO_TRANSITION;\n\ttrans2[lastnfa] = NO_TRANSITION;\n\taccptnum[lastnfa] = NIL;\n\tassoc_rule[lastnfa] = num_rules;\n\tstate_type[lastnfa] = current_state_type;\n\n\t/* Fix up equivalence classes base on this transition.  Note that any\n\t * character which has its own transition gets its own equivalence\n\t * class.  Thus only characters which are only in character classes\n\t * have a chance at being in the same equivalence class.  E.g. \"a|b\"\n\t * puts 'a' and 'b' into two different equivalence classes.  \"[ab]\"\n\t * puts them in the same equivalence class (barring other differences\n\t * elsewhere in the input).\n\t */\n\n\tif ( sym < 0 )\n\t\t{\n\t\t/* We don't have to update the equivalence classes since\n\t\t * that was already done when the ccl was created for the\n\t\t * first time.\n\t\t */\n\t\t}\n\n\telse if ( sym == SYM_EPSILON )\n\t\t++numeps;\n\n\telse\n\t\t{\n\t\tcheck_char( sym );\n\n\t\tif ( useecs )\n\t\t\t/* Map NUL's to csize. */\n\t\t\tmkechar( sym ? sym : csize, nextecm, ecgroup );\n\t\t}\n\n\treturn lastnfa;\n\t}\n\n\n/* mkxtion - make a transition from one state to another\n *\n * synopsis\n *\n *   mkxtion( statefrom, stateto );\n *\n *     statefrom - the state from which the transition is to be made\n *     stateto   - the state to which the transition is to be made\n */\n\nvoid mkxtion( statefrom, stateto )\nint statefrom, stateto;\n\t{\n\tif ( trans1[statefrom] == NO_TRANSITION )\n\t\ttrans1[statefrom] = stateto;\n\n\telse if ( (transchar[statefrom] != SYM_EPSILON) ||\n\t\t  (trans2[statefrom] != NO_TRANSITION) )\n\t\tflexfatal( _( \"found too many transitions in mkxtion()\" ) );\n\n\telse\n\t\t{ /* second out-transition for an epsilon state */\n\t\t++eps2;\n\t\ttrans2[statefrom] = stateto;\n\t\t}\n\t}\n\n/* new_rule - initialize for a new rule */\n\nvoid new_rule()\n\t{\n\tif ( ++num_rules >= current_max_rules )\n\t\t{\n\t\t++num_reallocs;\n\t\tcurrent_max_rules += MAX_RULES_INCREMENT;\n\t\trule_type = reallocate_integer_array( rule_type,\n\t\t\t\t\t\t\tcurrent_max_rules );\n\t\trule_linenum = reallocate_integer_array( rule_linenum,\n\t\t\t\t\t\t\tcurrent_max_rules );\n\t\trule_useful = reallocate_integer_array( rule_useful,\n\t\t\t\t\t\t\tcurrent_max_rules );\n\t\t}\n\n\tif ( num_rules > MAX_RULE )\n\t\tlerrif( _( \"too many rules (> %d)!\" ), MAX_RULE );\n\n\trule_linenum[num_rules] = linenum;\n\trule_useful[num_rules] = false;\n\t}\n/* File created from flex.skl via mkskel.sh */\n\n\nconst char *skel[] = {\n  \"/* A lexical scanner generated by flex */\",\n  \"\",\n  \"/* Scanner skeleton version:\",\n  \" * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $\",\n  \" */\",\n  \"\",\n  \"#define FLEX_SCANNER\",\n  \"#define YY_FLEX_MAJOR_VERSION 2\",\n  \"#define YY_FLEX_MINOR_VERSION 5\",\n  \"\",\n  \"%-\",\n  \"#include <stdio.h>\",\n  \"%*\",\n  \"\",\n  \"\",\n  \"/* cfront 1.2 defines \\\"c_plusplus\\\" instead of \\\"__cplusplus\\\" */\",\n  \"#ifdef c_plusplus\",\n  \"#ifndef __cplusplus\",\n  \"#define __cplusplus\",\n  \"#endif\",\n  \"#endif\",\n  \"\",\n  \"\",\n  \"#ifdef __cplusplus\",\n  \"\",\n  \"#include <stdlib.h>\",\n  \"%+\",\n  \"class istream;\",\n  \"%*\",\n  \"#include <unistd.h>\",\n  \"\",\n  \"/* Use prototypes in function declarations. */\",\n  \"#define YY_USE_PROTOS\",\n  \"\",\n  \"/* The \\\"const\\\" storage-class-modifier is valid. */\",\n  \"#define YY_USE_CONST\",\n  \"\",\n  \"#else\t/* ! __cplusplus */\",\n  \"\",\n  \"#if __STDC__\",\n  \"\",\n  \"#define YY_USE_PROTOS\",\n  \"#define YY_USE_CONST\",\n  \"\",\n  \"#endif\t/* __STDC__ */\",\n  \"#endif\t/* ! __cplusplus */\",\n  \"\",\n  \"#ifdef __TURBOC__\",\n  \" #pragma warn -rch\",\n  \" #pragma warn -use\",\n  \"#include <io.h>\",\n  \"#include <stdlib.h>\",\n  \"#define YY_USE_CONST\",\n  \"#define YY_USE_PROTOS\",\n  \"#endif\",\n  \"\",\n  \"#ifdef YY_USE_CONST\",\n  \"#define yyconst const\",\n  \"#else\",\n  \"#define yyconst\",\n  \"#endif\",\n  \"\",\n  \"\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"#define YY_PROTO(proto) proto\",\n  \"#else\",\n  \"#define YY_PROTO(proto) ()\",\n  \"#endif\",\n  \"\",\n  \"/* Returned upon end-of-file. */\",\n  \"#define YY_NULL 0\",\n  \"\",\n  \"/* Promotes a possibly negative, possibly signed char to an unsigned\",\n  \" * integer for use as an array index.  If the signed char is negative,\",\n  \" * we want to instead treat it as an 8-bit unsigned char, hence the\",\n  \" * double cast.\",\n  \" */\",\n  \"#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\",\n  \"\",\n  \"/* Enter a start condition.  This macro really ought to take a parameter,\",\n  \" * but we do it the disgusting crufty way forced on us by the ()-less\",\n  \" * definition of BEGIN.\",\n  \" */\",\n  \"#define BEGIN yy_start = 1 + 2 *\",\n  \"\",\n  \"/* Translate the current start state into a value that can be later handed\",\n  \" * to BEGIN to return to the state.  The YYSTATE alias is for lex\",\n  \" * compatibility.\",\n  \" */\",\n  \"#define YY_START ((yy_start - 1) / 2)\",\n  \"#define YYSTATE YY_START\",\n  \"\",\n  \"/* Action number for EOF rule of a given start state. */\",\n  \"#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\",\n  \"\",\n  \"/* Special action meaning \\\"start processing a new file\\\". */\",\n  \"#define YY_NEW_FILE yyrestart( yyin )\",\n  \"\",\n  \"#define YY_END_OF_BUFFER_CHAR 0\",\n  \"\",\n  \"/* Size of default input buffer. */\",\n  \"#define YY_BUF_SIZE 16384\",\n  \"\",\n  \"typedef struct yy_buffer_state *YY_BUFFER_STATE;\",\n  \"\",\n  \"extern int yyleng;\",\n  \"%-\",\n  \"extern FILE *yyin, *yyout;\",\n  \"%*\",\n  \"\",\n  \"#define EOB_ACT_CONTINUE_SCAN 0\",\n  \"#define EOB_ACT_END_OF_FILE 1\",\n  \"#define EOB_ACT_LAST_MATCH 2\",\n  \"\",\n  \"/* The funky do-while in the following #define is used to turn the definition\",\n  \" * int a single C statement (which needs a semi-colon terminator).  This\",\n  \" * avoids problems with code like:\",\n  \" *\",\n  \" * \tif ( condition_holds )\",\n  \" *\t\tyyless( 5 );\",\n  \" *\telse\",\n  \" *\t\tdo_something_else();\",\n  \" *\",\n  \" * Prior to using the do-while the compiler would get upset at the\",\n  \" * \\\"else\\\" because it interpreted the \\\"if\\\" statement as being all\",\n  \" * done when it reached the ';' after the yyless() call.\",\n  \" */\",\n  \"\",\n  \"/* Return all but the first 'n' matched characters back to the input stream. */\",\n  \"\",\n  \"#define yyless(n) \\\\\",\n  \"\tdo \\\\\",\n  \"\t\t{ \\\\\",\n  \"\t\t/* Undo effects of setting up yytext. */ \\\\\",\n  \"\t\t*yy_cp = yy_hold_char; \\\\\",\n  \"\t\tYY_RESTORE_YY_MORE_OFFSET \\\\\",\n  \"\t\tyy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\\\\",\n  \"\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\\\",\n  \"\t\t} \\\\\",\n  \"\twhile ( 0 )\",\n  \"\",\n  \"#define unput(c) yyunput( c, yytext_ptr )\",\n  \"\",\n  \"/* The following is because we cannot portably get our hands on size_t\",\n  \" * (without autoconf's help, which isn't available because we want\",\n  \" * flex-generated scanners to compile on their own).\",\n  \" */\",\n  \"typedef unsigned int yy_size_t;\",\n  \"\",\n  \"\",\n  \"struct yy_buffer_state\",\n  \"\t{\",\n  \"%-\",\n  \"\tFILE *yy_input_file;\",\n  \"%+\",\n  \"\tistream* yy_input_file;\",\n  \"%*\",\n  \"\",\n  \"\tchar *yy_ch_buf;\t\t/* input buffer */\",\n  \"\tchar *yy_buf_pos;\t\t/* current position in input buffer */\",\n  \"\",\n  \"\t/* Size of input buffer in bytes, not including room for EOB\",\n  \"\t * characters.\",\n  \"\t */\",\n  \"\tyy_size_t yy_buf_size;\",\n  \"\",\n  \"\t/* Number of characters read into yy_ch_buf, not including EOB\",\n  \"\t * characters.\",\n  \"\t */\",\n  \"\tint yy_n_chars;\",\n  \"\",\n  \"\t/* Whether we \\\"own\\\" the buffer - i.e., we know we created it,\",\n  \"\t * and can realloc() it to grow it, and should free() it to\",\n  \"\t * delete it.\",\n  \"\t */\",\n  \"\tint yy_is_our_buffer;\",\n  \"\",\n  \"\t/* Whether this is an \\\"interactive\\\" input source; if so, and\",\n  \"\t * if we're using stdio for input, then we want to use getc()\",\n  \"\t * instead of fread(), to make sure we stop fetching input after\",\n  \"\t * each newline.\",\n  \"\t */\",\n  \"\tint yy_is_interactive;\",\n  \"\",\n  \"\t/* Whether we're considered to be at the beginning of a line.\",\n  \"\t * If so, '^' rules will be active on the next match, otherwise\",\n  \"\t * not.\",\n  \"\t */\",\n  \"\tint yy_at_bol;\",\n  \"\",\n  \"\t/* Whether to try to fill the input buffer when we reach the\",\n  \"\t * end of it.\",\n  \"\t */\",\n  \"\tint yy_fill_buffer;\",\n  \"\",\n  \"\tint yy_buffer_status;\",\n  \"#define YY_BUFFER_NEW 0\",\n  \"#define YY_BUFFER_NORMAL 1\",\n  \"\t/* When an EOF's been seen but there's still some text to process\",\n  \"\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we\",\n  \"\t * shouldn't try reading from the input source any more.  We might\",\n  \"\t * still have a bunch of tokens to match, though, because of\",\n  \"\t * possible backing-up.\",\n  \"\t *\",\n  \"\t * When we actually see the EOF, we change the status to \\\"new\\\"\",\n  \"\t * (via yyrestart()), so that the user can continue scanning by\",\n  \"\t * just pointing yyin at a new input file.\",\n  \"\t */\",\n  \"#define YY_BUFFER_EOF_PENDING 2\",\n  \"\t};\",\n  \"\",\n  \"%- Standard (non-C++) definition\",\n  \"static YY_BUFFER_STATE yy_current_buffer = 0;\",\n  \"%*\",\n  \"\",\n  \"/* We provide macros for accessing buffer states in case in the\",\n  \" * future we want to put the buffer states in a more general\",\n  \" * \\\"scanner state\\\".\",\n  \" */\",\n  \"#define YY_CURRENT_BUFFER yy_current_buffer\",\n  \"\",\n  \"\",\n  \"%- Standard (non-C++) definition\",\n  \"/* yy_hold_char holds the character lost when yytext is formed. */\",\n  \"static char yy_hold_char;\",\n  \"\",\n  \"static int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */\",\n  \"\",\n  \"\",\n  \"int yyleng;\",\n  \"\",\n  \"/* Points to current character in buffer. */\",\n  \"static char *yy_c_buf_p = (char *) 0;\",\n  \"static int yy_init = 1;\t\t/* whether we need to initialize */\",\n  \"static int yy_start = 0;\t/* start state number */\",\n  \"\",\n  \"/* Flag which is used to allow yywrap()'s to do buffer switches\",\n  \" * instead of setting up a fresh yyin.  A bit of a hack ...\",\n  \" */\",\n  \"static int yy_did_buffer_switch_on_eof;\",\n  \"\",\n  \"void yyrestart YY_PROTO(( FILE *input_file ));\",\n  \"\",\n  \"void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));\",\n  \"void yy_load_buffer_state YY_PROTO(( void ));\",\n  \"YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));\",\n  \"void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));\",\n  \"void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));\",\n  \"void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));\",\n  \"#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )\",\n  \"\",\n  \"YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));\",\n  \"YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));\",\n  \"YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));\",\n  \"%*\",\n  \"\",\n  \"static void *yy_flex_alloc YY_PROTO(( yy_size_t ));\",\n  \"static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));\",\n  \"static void yy_flex_free YY_PROTO(( void * ));\",\n  \"\",\n  \"#define yy_new_buffer yy_create_buffer\",\n  \"\",\n  \"#define yy_set_interactive(is_interactive) \\\\\",\n  \"\t{ \\\\\",\n  \"\tif ( ! yy_current_buffer ) \\\\\",\n  \"\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\\\",\n  \"\tyy_current_buffer->yy_is_interactive = is_interactive; \\\\\",\n  \"\t}\",\n  \"\",\n  \"#define yy_set_bol(at_bol) \\\\\",\n  \"\t{ \\\\\",\n  \"\tif ( ! yy_current_buffer ) \\\\\",\n  \"\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\\\",\n  \"\tyy_current_buffer->yy_at_bol = at_bol; \\\\\",\n  \"\t}\",\n  \"\",\n  \"#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)\",\n  \"\",\n  \"%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here\",\n  \"\",\n  \"%- Standard (non-C++) definition\",\n  \"static yy_state_type yy_get_previous_state YY_PROTO(( void ));\",\n  \"static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));\",\n  \"static int yy_get_next_buffer YY_PROTO(( void ));\",\n  \"static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));\",\n  \"%*\",\n  \"\",\n  \"/* Done after the current pattern has been matched and before the\",\n  \" * corresponding action - sets up yytext.\",\n  \" */\",\n  \"#define YY_DO_BEFORE_ACTION \\\\\",\n  \"\tyytext_ptr = yy_bp; \\\\\",\n  \"%% code to fiddle yytext and yyleng for yymore() goes here\",\n  \"\tyy_hold_char = *yy_cp; \\\\\",\n  \"\t*yy_cp = '\\\\0'; \\\\\",\n  \"%% code to copy yytext_ptr to yytext[] goes here, if %array\",\n  \"\tyy_c_buf_p = yy_cp;\",\n  \"\",\n  \"%% data tables for the DFA and the user's section 1 definitions go here\",\n  \"\",\n  \"/* Macros after this point can all be overridden by user definitions in\",\n  \" * section 1.\",\n  \" */\",\n  \"\",\n  \"#ifndef YY_SKIP_YYWRAP\",\n  \"#ifdef __cplusplus\",\n  \"extern \\\"C\\\" int yywrap YY_PROTO(( void ));\",\n  \"#else\",\n  \"extern int yywrap YY_PROTO(( void ));\",\n  \"#endif\",\n  \"#endif\",\n  \"\",\n  \"%-\",\n  \"#ifndef YY_NO_UNPUT\",\n  \"static void yyunput YY_PROTO(( int c, char *buf_ptr ));\",\n  \"#endif\",\n  \"%*\",\n  \"\",\n  \"#ifndef yytext_ptr\",\n  \"static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));\",\n  \"#endif\",\n  \"\",\n  \"#ifdef YY_NEED_STRLEN\",\n  \"static int yy_flex_strlen YY_PROTO(( yyconst char * ));\",\n  \"#endif\",\n  \"\",\n  \"#ifndef YY_NO_INPUT\",\n  \"%- Standard (non-C++) definition\",\n  \"#ifdef __cplusplus\",\n  \"static int yyinput YY_PROTO(( void ));\",\n  \"#else\",\n  \"static int input YY_PROTO(( void ));\",\n  \"#endif\",\n  \"%*\",\n  \"#endif\",\n  \"\",\n  \"#if YY_STACK_USED\",\n  \"static int yy_start_stack_ptr = 0;\",\n  \"static int yy_start_stack_depth = 0;\",\n  \"static int *yy_start_stack = 0;\",\n  \"#ifndef YY_NO_PUSH_STATE\",\n  \"static void yy_push_state YY_PROTO(( int new_state ));\",\n  \"#endif\",\n  \"#ifndef YY_NO_POP_STATE\",\n  \"static void yy_pop_state YY_PROTO(( void ));\",\n  \"#endif\",\n  \"#ifndef YY_NO_TOP_STATE\",\n  \"static int yy_top_state YY_PROTO(( void ));\",\n  \"#endif\",\n  \"\",\n  \"#else\",\n  \"#define YY_NO_PUSH_STATE 1\",\n  \"#define YY_NO_POP_STATE 1\",\n  \"#define YY_NO_TOP_STATE 1\",\n  \"#endif\",\n  \"\",\n  \"#ifdef YY_MALLOC_DECL\",\n  \"YY_MALLOC_DECL\",\n  \"#else\",\n  \"#if __STDC__\",\n  \"#ifndef __cplusplus\",\n  \"#include <stdlib.h>\",\n  \"#endif\",\n  \"#else\",\n  \"/* Just try to get by without declaring the routines.  This will fail\",\n  \" * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)\",\n  \" * or sizeof(void*) != sizeof(int).\",\n  \" */\",\n  \"#endif\",\n  \"#endif\",\n  \"\",\n  \"/* Amount of stuff to slurp up with each read. */\",\n  \"#ifndef YY_READ_BUF_SIZE\",\n  \"#define YY_READ_BUF_SIZE 8192\",\n  \"#endif\",\n  \"\",\n  \"/* Copy whatever the last rule matched to the standard output. */\",\n  \"\",\n  \"#ifndef ECHO\",\n  \"%- Standard (non-C++) definition\",\n  \"/* This used to be an fputs(), but since the string might contain NUL's,\",\n  \" * we now use fwrite().\",\n  \" */\",\n  \"#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )\",\n  \"%+ C++ definition\",\n  \"#define ECHO LexerOutput( yytext, yyleng )\",\n  \"%*\",\n  \"#endif\",\n  \"\",\n  \"/* Gets input and stuffs it into \\\"buf\\\".  number of characters read, or YY_NULL,\",\n  \" * is returned in \\\"result\\\".\",\n  \" */\",\n  \"#ifndef YY_INPUT\",\n  \"#define YY_INPUT(buf,result,max_size) \\\\\",\n  \"%% fread()/read() definition of YY_INPUT goes here unless we're doing C++\",\n  \"%+ C++ definition\",\n  \"\tif ( (result = LexerInput( (char *) buf, max_size )) < 0 ) \\\\\",\n  \"\t\tYY_FATAL_ERROR( \\\"input in flex scanner failed\\\" );\",\n  \"%*\",\n  \"#endif\",\n  \"\",\n  \"/* No semi-colon after return; correct usage is to write \\\"yyterminate();\\\" -\",\n  \" * we don't want an extra ';' after the \\\"return\\\" because that will cause\",\n  \" * some compilers to complain about unreachable statements.\",\n  \" */\",\n  \"#ifndef yyterminate\",\n  \"#define yyterminate() return YY_NULL\",\n  \"#endif\",\n  \"\",\n  \"/* Number of entries by which start-condition stack grows. */\",\n  \"#ifndef YY_START_STACK_INCR\",\n  \"#define YY_START_STACK_INCR 25\",\n  \"#endif\",\n  \"\",\n  \"/* Report a fatal error. */\",\n  \"#ifndef YY_FATAL_ERROR\",\n  \"%-\",\n  \"#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )\",\n  \"%+\",\n  \"#define YY_FATAL_ERROR(msg) LexerError( msg )\",\n  \"%*\",\n  \"#endif\",\n  \"\",\n  \"/* Default declaration of generated scanner - a define so the user can\",\n  \" * easily add parameters.\",\n  \" */\",\n  \"#ifndef YY_DECL\",\n  \"%- Standard (non-C++) definition\",\n  \"#define YY_DECL int yylex YY_PROTO(( void ))\",\n  \"%+ C++ definition\",\n  \"#define YY_DECL int yyFlexLexer::yylex()\",\n  \"%*\",\n  \"#endif\",\n  \"\",\n  \"/* Code executed at the beginning of each rule, after yytext and yyleng\",\n  \" * have been set up.\",\n  \" */\",\n  \"#ifndef YY_USER_ACTION\",\n  \"#define YY_USER_ACTION\",\n  \"#endif\",\n  \"\",\n  \"/* Code executed at the end of each rule. */\",\n  \"#ifndef YY_BREAK\",\n  \"#define YY_BREAK break;\",\n  \"#endif\",\n  \"\",\n  \"%% YY_RULE_SETUP definition goes here\",\n  \"\",\n  \"YY_DECL\",\n  \"\t{\",\n  \"\tregister yy_state_type yy_current_state;\",\n  \"\tregister char *yy_cp, *yy_bp;\",\n  \"\tregister int yy_act;\",\n  \"\",\n  \"%% user's declarations go here\",\n  \"\",\n  \"\tif ( yy_init )\",\n  \"\t\t{\",\n  \"\t\tyy_init = 0;\",\n  \"\",\n  \"#ifdef YY_USER_INIT\",\n  \"\t\tYY_USER_INIT;\",\n  \"#endif\",\n  \"\",\n  \"\t\tif ( ! yy_start )\",\n  \"\t\t\tyy_start = 1;\t/* first start state */\",\n  \"\",\n  \"\t\tif ( ! yyin )\",\n  \"%-\",\n  \"\t\t\tyyin = stdin;\",\n  \"%+\",\n  \"\t\t\tyyin = &cin;\",\n  \"%*\",\n  \"\",\n  \"\t\tif ( ! yyout )\",\n  \"%-\",\n  \"\t\t\tyyout = stdout;\",\n  \"%+\",\n  \"\t\t\tyyout = &cout;\",\n  \"%*\",\n  \"\",\n  \"\t\tif ( ! yy_current_buffer )\",\n  \"\t\t\tyy_current_buffer =\",\n  \"\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE );\",\n  \"\",\n  \"\t\tyy_load_buffer_state();\",\n  \"\t\t}\",\n  \"\",\n  \"\twhile ( 1 )\t\t/* loops until end-of-file is reached */\",\n  \"\t\t{\",\n  \"%% yymore()-related code goes here\",\n  \"\t\tyy_cp = yy_c_buf_p;\",\n  \"\",\n  \"\t\t/* Support of yytext. */\",\n  \"\t\t*yy_cp = yy_hold_char;\",\n  \"\",\n  \"\t\t/* yy_bp points to the position in yy_ch_buf of the start of\",\n  \"\t\t * the current run.\",\n  \"\t\t */\",\n  \"\t\tyy_bp = yy_cp;\",\n  \"\",\n  \"%% code to set up and find next match goes here\",\n  \"\",\n  \"yy_find_action:\",\n  \"%% code to find the action number goes here\",\n  \"\",\n  \"\t\tYY_DO_BEFORE_ACTION;\",\n  \"\",\n  \"%% code for yylineno update goes here\",\n  \"\",\n  \"do_action:\t/* This label is used only to access EOF actions. */\",\n  \"\",\n  \"%% debug code goes here\",\n  \"\",\n  \"\t\tswitch ( yy_act )\",\n  \"\t{ /* beginning of action switch */\",\n  \"%% actions go here\",\n  \"\",\n  \"\tcase YY_END_OF_BUFFER:\",\n  \"\t\t{\",\n  \"\t\t/* Amount of text matched not including the EOB char. */\",\n  \"\t\tint yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;\",\n  \"\",\n  \"\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\",\n  \"\t\t*yy_cp = yy_hold_char;\",\n  \"\t\tYY_RESTORE_YY_MORE_OFFSET\",\n  \"\",\n  \"\t\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )\",\n  \"\t\t\t{\",\n  \"\t\t\t/* We're scanning a new file or input source.  It's\",\n  \"\t\t\t * possible that this happened because the user\",\n  \"\t\t\t * just pointed yyin at a new source and called\",\n  \"\t\t\t * yylex().  If so, then we have to assure\",\n  \"\t\t\t * consistency between yy_current_buffer and our\",\n  \"\t\t\t * globals.  Here is the right place to do so, because\",\n  \"\t\t\t * this is the first action (other than possibly a\",\n  \"\t\t\t * back-up) that will match for the new input source.\",\n  \"\t\t\t */\",\n  \"\t\t\tyy_n_chars = yy_current_buffer->yy_n_chars;\",\n  \"\t\t\tyy_current_buffer->yy_input_file = yyin;\",\n  \"\t\t\tyy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;\",\n  \"\t\t\t}\",\n  \"\",\n  \"\t\t/* Note that here we test for yy_c_buf_p \\\"<=\\\" to the position\",\n  \"\t\t * of the first EOB in the buffer, since yy_c_buf_p will\",\n  \"\t\t * already have been incremented past the NUL character\",\n  \"\t\t * (since all states make transitions on EOB to the\",\n  \"\t\t * end-of-buffer state).  Contrast this with the test\",\n  \"\t\t * in input().\",\n  \"\t\t */\",\n  \"\t\tif ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )\",\n  \"\t\t\t{ /* This was really a NUL. */\",\n  \"\t\t\tyy_state_type yy_next_state;\",\n  \"\",\n  \"\t\t\tyy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;\",\n  \"\",\n  \"\t\t\tyy_current_state = yy_get_previous_state();\",\n  \"\",\n  \"\t\t\t/* Okay, we're now positioned to make the NUL\",\n  \"\t\t\t * transition.  We couldn't have\",\n  \"\t\t\t * yy_get_previous_state() go ahead and do it\",\n  \"\t\t\t * for us because it doesn't know how to deal\",\n  \"\t\t\t * with the possibility of jamming (and we don't\",\n  \"\t\t\t * want to build jamming into it because then it\",\n  \"\t\t\t * will run more slowly).\",\n  \"\t\t\t */\",\n  \"\",\n  \"\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state );\",\n  \"\",\n  \"\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\",\n  \"\",\n  \"\t\t\tif ( yy_next_state )\",\n  \"\t\t\t\t{\",\n  \"\t\t\t\t/* Consume the NUL. */\",\n  \"\t\t\t\tyy_cp = ++yy_c_buf_p;\",\n  \"\t\t\t\tyy_current_state = yy_next_state;\",\n  \"\t\t\t\tgoto yy_match;\",\n  \"\t\t\t\t}\",\n  \"\",\n  \"\t\t\telse\",\n  \"\t\t\t\t{\",\n  \"%% code to do back-up for compressed tables and set up yy_cp goes here\",\n  \"\t\t\t\tgoto yy_find_action;\",\n  \"\t\t\t\t}\",\n  \"\t\t\t}\",\n  \"\",\n  \"\t\telse switch ( yy_get_next_buffer() )\",\n  \"\t\t\t{\",\n  \"\t\t\tcase EOB_ACT_END_OF_FILE:\",\n  \"\t\t\t\t{\",\n  \"\t\t\t\tyy_did_buffer_switch_on_eof = 0;\",\n  \"\",\n  \"\t\t\t\tif ( yywrap() )\",\n  \"\t\t\t\t\t{\",\n  \"\t\t\t\t\t/* Note: because we've taken care in\",\n  \"\t\t\t\t\t * yy_get_next_buffer() to have set up\",\n  \"\t\t\t\t\t * yytext, we can now set up\",\n  \"\t\t\t\t\t * yy_c_buf_p so that if some total\",\n  \"\t\t\t\t\t * hoser (like flex itself) wants to\",\n  \"\t\t\t\t\t * call the scanner after we return the\",\n  \"\t\t\t\t\t * YY_NULL, it'll still work - another\",\n  \"\t\t\t\t\t * YY_NULL will get returned.\",\n  \"\t\t\t\t\t */\",\n  \"\t\t\t\t\tyy_c_buf_p = yytext_ptr + YY_MORE_ADJ;\",\n  \"\",\n  \"\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\",\n  \"\t\t\t\t\tgoto do_action;\",\n  \"\t\t\t\t\t}\",\n  \"\",\n  \"\t\t\t\telse\",\n  \"\t\t\t\t\t{\",\n  \"\t\t\t\t\tif ( ! yy_did_buffer_switch_on_eof )\",\n  \"\t\t\t\t\t\tYY_NEW_FILE;\",\n  \"\t\t\t\t\t}\",\n  \"\t\t\t\tbreak;\",\n  \"\t\t\t\t}\",\n  \"\",\n  \"\t\t\tcase EOB_ACT_CONTINUE_SCAN:\",\n  \"\t\t\t\tyy_c_buf_p =\",\n  \"\t\t\t\t\tyytext_ptr + yy_amount_of_matched_text;\",\n  \"\",\n  \"\t\t\t\tyy_current_state = yy_get_previous_state();\",\n  \"\",\n  \"\t\t\t\tyy_cp = yy_c_buf_p;\",\n  \"\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\",\n  \"\t\t\t\tgoto yy_match;\",\n  \"\",\n  \"\t\t\tcase EOB_ACT_LAST_MATCH:\",\n  \"\t\t\t\tyy_c_buf_p =\",\n  \"\t\t\t\t&yy_current_buffer->yy_ch_buf[yy_n_chars];\",\n  \"\",\n  \"\t\t\t\tyy_current_state = yy_get_previous_state();\",\n  \"\",\n  \"\t\t\t\tyy_cp = yy_c_buf_p;\",\n  \"\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\",\n  \"\t\t\t\tgoto yy_find_action;\",\n  \"\t\t\t}\",\n  \"\t\tbreak;\",\n  \"\t\t}\",\n  \"\",\n  \"\tdefault:\",\n  \"\t\tYY_FATAL_ERROR(\",\n  \"\t\t\t\\\"fatal flex scanner internal error--no action found\\\" );\",\n  \"\t} /* end of action switch */\",\n  \"\t\t} /* end of scanning one token */\",\n  \"\t} /* end of yylex */\",\n  \"\",\n  \"%+\",\n  \"yyFlexLexer::yyFlexLexer( istream* arg_yyin, ostream* arg_yyout )\",\n  \"\t{\",\n  \"\tyyin = arg_yyin;\",\n  \"\tyyout = arg_yyout;\",\n  \"\tyy_c_buf_p = 0;\",\n  \"\tyy_init = 1;\",\n  \"\tyy_start = 0;\",\n  \"\tyy_flex_debug = 0;\",\n  \"\tyylineno = 1;\t// this will only get updated if %option yylineno\",\n  \"\",\n  \"\tyy_did_buffer_switch_on_eof = 0;\",\n  \"\",\n  \"\tyy_looking_for_trail_begin = 0;\",\n  \"\tyy_more_flag = 0;\",\n  \"\tyy_more_len = 0;\",\n  \"\tyy_more_offset = yy_prev_more_offset = 0;\",\n  \"\",\n  \"\tyy_start_stack_ptr = yy_start_stack_depth = 0;\",\n  \"\tyy_start_stack = 0;\",\n  \"\",\n  \"\tyy_current_buffer = 0;\",\n  \"\",\n  \"#ifdef YY_USES_REJECT\",\n  \"\tyy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];\",\n  \"#else\",\n  \"\tyy_state_buf = 0;\",\n  \"#endif\",\n  \"\t}\",\n  \"\",\n  \"yyFlexLexer::~yyFlexLexer()\",\n  \"\t{\",\n  \"\tdelete yy_state_buf;\",\n  \"\tyy_delete_buffer( yy_current_buffer );\",\n  \"\t}\",\n  \"\",\n  \"void yyFlexLexer::switch_streams( istream* new_in, ostream* new_out )\",\n  \"\t{\",\n  \"\tif ( new_in )\",\n  \"\t\t{\",\n  \"\t\tyy_delete_buffer( yy_current_buffer );\",\n  \"\t\tyy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE ) );\",\n  \"\t\t}\",\n  \"\",\n  \"\tif ( new_out )\",\n  \"\t\tyyout = new_out;\",\n  \"\t}\",\n  \"\",\n  \"#ifdef YY_INTERACTIVE\",\n  \"int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )\",\n  \"#else\",\n  \"int yyFlexLexer::LexerInput( char* buf, int max_size )\",\n  \"#endif\",\n  \"\t{\",\n  \"\tif ( yyin->eof() || yyin->fail() )\",\n  \"\t\treturn 0;\",\n  \"\",\n  \"#ifdef YY_INTERACTIVE\",\n  \"\tyyin->get( buf[0] );\",\n  \"\",\n  \"\tif ( yyin->eof() )\",\n  \"\t\treturn 0;\",\n  \"\",\n  \"\tif ( yyin->bad() )\",\n  \"\t\treturn -1;\",\n  \"\",\n  \"\treturn 1;\",\n  \"\",\n  \"#else\",\n  \"\t(void) yyin->read( buf, max_size );\",\n  \"\",\n  \"\tif ( yyin->bad() )\",\n  \"\t\treturn -1;\",\n  \"\telse\",\n  \"\t\treturn yyin->gcount();\",\n  \"#endif\",\n  \"\t}\",\n  \"\",\n  \"void yyFlexLexer::LexerOutput( const char* buf, int size )\",\n  \"\t{\",\n  \"\t(void) yyout->write( buf, size );\",\n  \"\t}\",\n  \"%*\",\n  \"\",\n  \"/* yy_get_next_buffer - try to read in a new buffer\",\n  \" *\",\n  \" * Returns a code representing an action:\",\n  \" *\tEOB_ACT_LAST_MATCH -\",\n  \" *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\",\n  \" *\tEOB_ACT_END_OF_FILE - end of file\",\n  \" */\",\n  \"\",\n  \"%-\",\n  \"static int yy_get_next_buffer()\",\n  \"%+\",\n  \"int yyFlexLexer::yy_get_next_buffer()\",\n  \"%*\",\n  \"\t{\",\n  \"\tregister char *dest = yy_current_buffer->yy_ch_buf;\",\n  \"\tregister char *source = yytext_ptr;\",\n  \"\tregister int number_to_move, i;\",\n  \"\tint ret_val;\",\n  \"\",\n  \"\tif ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )\",\n  \"\t\tYY_FATAL_ERROR(\",\n  \"\t\t\\\"fatal flex scanner internal error--end of buffer missed\\\" );\",\n  \"\",\n  \"\tif ( yy_current_buffer->yy_fill_buffer == 0 )\",\n  \"\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\",\n  \"\t\tif ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )\",\n  \"\t\t\t{\",\n  \"\t\t\t/* We matched a single character, the EOB, so\",\n  \"\t\t\t * treat this as a final EOF.\",\n  \"\t\t\t */\",\n  \"\t\t\treturn EOB_ACT_END_OF_FILE;\",\n  \"\t\t\t}\",\n  \"\",\n  \"\t\telse\",\n  \"\t\t\t{\",\n  \"\t\t\t/* We matched some text prior to the EOB, first\",\n  \"\t\t\t * process it.\",\n  \"\t\t\t */\",\n  \"\t\t\treturn EOB_ACT_LAST_MATCH;\",\n  \"\t\t\t}\",\n  \"\t\t}\",\n  \"\",\n  \"\t/* Try to read more data. */\",\n  \"\",\n  \"\t/* First move last chars to start of buffer. */\",\n  \"\tnumber_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;\",\n  \"\",\n  \"\tfor ( i = 0; i < number_to_move; ++i )\",\n  \"\t\t*(dest++) = *(source++);\",\n  \"\",\n  \"\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )\",\n  \"\t\t/* don't do the read, it's not guaranteed to return an EOF,\",\n  \"\t\t * just force an EOF\",\n  \"\t\t */\",\n  \"\t\tyy_current_buffer->yy_n_chars = yy_n_chars = 0;\",\n  \"\",\n  \"\telse\",\n  \"\t\t{\",\n  \"\t\tint num_to_read =\",\n  \"\t\t\tyy_current_buffer->yy_buf_size - number_to_move - 1;\",\n  \"\",\n  \"\t\twhile ( num_to_read <= 0 )\",\n  \"\t\t\t{ /* Not enough room in the buffer - grow it. */\",\n  \"#ifdef YY_USES_REJECT\",\n  \"\t\t\tYY_FATAL_ERROR(\",\n  \"\\\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\\\" );\",\n  \"#else\",\n  \"\",\n  \"\t\t\t/* just a shorter name for the current buffer */\",\n  \"\t\t\tYY_BUFFER_STATE b = yy_current_buffer;\",\n  \"\",\n  \"\t\t\tint yy_c_buf_p_offset =\",\n  \"\t\t\t\t(int) (yy_c_buf_p - b->yy_ch_buf);\",\n  \"\",\n  \"\t\t\tif ( b->yy_is_our_buffer )\",\n  \"\t\t\t\t{\",\n  \"\t\t\t\tint new_size = b->yy_buf_size * 2;\",\n  \"\",\n  \"\t\t\t\tif ( new_size <= 0 )\",\n  \"\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\",\n  \"\t\t\t\telse\",\n  \"\t\t\t\t\tb->yy_buf_size *= 2;\",\n  \"\",\n  \"\t\t\t\tb->yy_ch_buf = (char *)\",\n  \"\t\t\t\t\t/* Include room in for 2 EOB chars. */\",\n  \"\t\t\t\t\tyy_flex_realloc( (void *) b->yy_ch_buf,\",\n  \"\t\t\t\t\t\t\t b->yy_buf_size + 2 );\",\n  \"\t\t\t\t}\",\n  \"\t\t\telse\",\n  \"\t\t\t\t/* Can't grow it, we don't own it. */\",\n  \"\t\t\t\tb->yy_ch_buf = 0;\",\n  \"\",\n  \"\t\t\tif ( ! b->yy_ch_buf )\",\n  \"\t\t\t\tYY_FATAL_ERROR(\",\n  \"\t\t\t\t\\\"fatal error - scanner input buffer overflow\\\" );\",\n  \"\",\n  \"\t\t\tyy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\",\n  \"\",\n  \"\t\t\tnum_to_read = yy_current_buffer->yy_buf_size -\",\n  \"\t\t\t\t\t\tnumber_to_move - 1;\",\n  \"#endif\",\n  \"\t\t\t}\",\n  \"\",\n  \"\t\tif ( num_to_read > YY_READ_BUF_SIZE )\",\n  \"\t\t\tnum_to_read = YY_READ_BUF_SIZE;\",\n  \"\",\n  \"\t\t/* Read in more data. */\",\n  \"\t\tYY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),\",\n  \"\t\t\tyy_n_chars, num_to_read );\",\n  \"\",\n  \"\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\",\n  \"\t\t}\",\n  \"\",\n  \"\tif ( yy_n_chars == 0 )\",\n  \"\t\t{\",\n  \"\t\tif ( number_to_move == YY_MORE_ADJ )\",\n  \"\t\t\t{\",\n  \"\t\t\tret_val = EOB_ACT_END_OF_FILE;\",\n  \"\t\t\tyyrestart( yyin );\",\n  \"\t\t\t}\",\n  \"\",\n  \"\t\telse\",\n  \"\t\t\t{\",\n  \"\t\t\tret_val = EOB_ACT_LAST_MATCH;\",\n  \"\t\t\tyy_current_buffer->yy_buffer_status =\",\n  \"\t\t\t\tYY_BUFFER_EOF_PENDING;\",\n  \"\t\t\t}\",\n  \"\t\t}\",\n  \"\",\n  \"\telse\",\n  \"\t\tret_val = EOB_ACT_CONTINUE_SCAN;\",\n  \"\",\n  \"\tyy_n_chars += number_to_move;\",\n  \"\tyy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;\",\n  \"\tyy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\",\n  \"\",\n  \"\tyytext_ptr = &yy_current_buffer->yy_ch_buf[0];\",\n  \"\",\n  \"\treturn ret_val;\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"/* yy_get_previous_state - get the state just before the EOB char was reached */\",\n  \"\",\n  \"%-\",\n  \"static yy_state_type yy_get_previous_state()\",\n  \"%+\",\n  \"yy_state_type yyFlexLexer::yy_get_previous_state()\",\n  \"%*\",\n  \"\t{\",\n  \"\tregister yy_state_type yy_current_state;\",\n  \"\tregister char *yy_cp;\",\n  \"\",\n  \"%% code to get the start state into yy_current_state goes here\",\n  \"\",\n  \"\tfor ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )\",\n  \"\t\t{\",\n  \"%% code to find the next state goes here\",\n  \"\t\t}\",\n  \"\",\n  \"\treturn yy_current_state;\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"/* yy_try_NUL_trans - try to make a transition on the NUL character\",\n  \" *\",\n  \" * synopsis\",\n  \" *\tnext_state = yy_try_NUL_trans( current_state );\",\n  \" */\",\n  \"\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )\",\n  \"#else\",\n  \"static yy_state_type yy_try_NUL_trans( yy_current_state )\",\n  \"yy_state_type yy_current_state;\",\n  \"#endif\",\n  \"%+\",\n  \"yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )\",\n  \"%*\",\n  \"\t{\",\n  \"\tregister int yy_is_jam;\",\n  \"%% code to find the next state, and perhaps do backing up, goes here\",\n  \"\",\n  \"\treturn yy_is_jam ? 0 : yy_current_state;\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifndef YY_NO_UNPUT\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static void yyunput( int c, register char *yy_bp )\",\n  \"#else\",\n  \"static void yyunput( c, yy_bp )\",\n  \"int c;\",\n  \"register char *yy_bp;\",\n  \"#endif\",\n  \"%+\",\n  \"void yyFlexLexer::yyunput( int c, register char* yy_bp )\",\n  \"%*\",\n  \"\t{\",\n  \"\tregister char *yy_cp = yy_c_buf_p;\",\n  \"\",\n  \"\t/* undo effects of setting up yytext */\",\n  \"\t*yy_cp = yy_hold_char;\",\n  \"\",\n  \"\tif ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\",\n  \"\t\t{ /* need to shift things up to make room */\",\n  \"\t\t/* +2 for EOB chars. */\",\n  \"\t\tregister int number_to_move = yy_n_chars + 2;\",\n  \"\t\tregister char *dest = &yy_current_buffer->yy_ch_buf[\",\n  \"\t\t\t\t\tyy_current_buffer->yy_buf_size + 2];\",\n  \"\t\tregister char *source =\",\n  \"\t\t\t\t&yy_current_buffer->yy_ch_buf[number_to_move];\",\n  \"\",\n  \"\t\twhile ( source > yy_current_buffer->yy_ch_buf )\",\n  \"\t\t\t*--dest = *--source;\",\n  \"\",\n  \"\t\tyy_cp += (int) (dest - source);\",\n  \"\t\tyy_bp += (int) (dest - source);\",\n  \"\t\tyy_current_buffer->yy_n_chars =\",\n  \"\t\t\tyy_n_chars = yy_current_buffer->yy_buf_size;\",\n  \"\",\n  \"\t\tif ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\",\n  \"\t\t\tYY_FATAL_ERROR( \\\"flex scanner push-back overflow\\\" );\",\n  \"\t\t}\",\n  \"\",\n  \"\t*--yy_cp = (char) c;\",\n  \"\",\n  \"%% update yylineno here\",\n  \"\",\n  \"\tyytext_ptr = yy_bp;\",\n  \"\tyy_hold_char = *yy_cp;\",\n  \"\tyy_c_buf_p = yy_cp;\",\n  \"\t}\",\n  \"%-\",\n  \"#endif\t/* ifndef YY_NO_UNPUT */\",\n  \"%*\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifdef __cplusplus\",\n  \"static int yyinput()\",\n  \"#else\",\n  \"static int input()\",\n  \"#endif\",\n  \"%+\",\n  \"int yyFlexLexer::yyinput()\",\n  \"%*\",\n  \"\t{\",\n  \"\tint c;\",\n  \"\",\n  \"\t*yy_c_buf_p = yy_hold_char;\",\n  \"\",\n  \"\tif ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\",\n  \"\t\t{\",\n  \"\t\t/* yy_c_buf_p now points to the character we want to return.\",\n  \"\t\t * If this occurs *before* the EOB characters, then it's a\",\n  \"\t\t * valid NUL; if not, then we've hit the end of the buffer.\",\n  \"\t\t */\",\n  \"\t\tif ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )\",\n  \"\t\t\t/* This was really a NUL. */\",\n  \"\t\t\t*yy_c_buf_p = '\\\\0';\",\n  \"\",\n  \"\t\telse\",\n  \"\t\t\t{ /* need more input */\",\n  \"\t\t\tint offset = yy_c_buf_p - yytext_ptr;\",\n  \"\t\t\t++yy_c_buf_p;\",\n  \"\",\n  \"\t\t\tswitch ( yy_get_next_buffer() )\",\n  \"\t\t\t\t{\",\n  \"\t\t\t\tcase EOB_ACT_LAST_MATCH:\",\n  \"\t\t\t\t\t/* This happens because yy_g_n_b()\",\n  \"\t\t\t\t\t * sees that we've accumulated a\",\n  \"\t\t\t\t\t * token and flags that we need to\",\n  \"\t\t\t\t\t * try matching the token before\",\n  \"\t\t\t\t\t * proceeding.  But for input(),\",\n  \"\t\t\t\t\t * there's no matching to consider.\",\n  \"\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\",\n  \"\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\",\n  \"\t\t\t\t\t */\",\n  \"\",\n  \"\t\t\t\t\t/* Reset buffer status. */\",\n  \"\t\t\t\t\tyyrestart( yyin );\",\n  \"\",\n  \"\t\t\t\t\t/* fall through */\",\n  \"\",\n  \"\t\t\t\tcase EOB_ACT_END_OF_FILE:\",\n  \"\t\t\t\t\t{\",\n  \"\t\t\t\t\tif ( yywrap() )\",\n  \"\t\t\t\t\t\treturn EOF;\",\n  \"\",\n  \"\t\t\t\t\tif ( ! yy_did_buffer_switch_on_eof )\",\n  \"\t\t\t\t\t\tYY_NEW_FILE;\",\n  \"#ifdef __cplusplus\",\n  \"\t\t\t\t\treturn yyinput();\",\n  \"#else\",\n  \"\t\t\t\t\treturn input();\",\n  \"#endif\",\n  \"\t\t\t\t\t}\",\n  \"\",\n  \"\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\",\n  \"\t\t\t\t\tyy_c_buf_p = yytext_ptr + offset;\",\n  \"\t\t\t\t\tbreak;\",\n  \"\t\t\t\t}\",\n  \"\t\t\t}\",\n  \"\t\t}\",\n  \"\",\n  \"\tc = *(unsigned char *) yy_c_buf_p;\t/* cast for 8-bit char's */\",\n  \"\t*yy_c_buf_p = '\\\\0';\t/* preserve yytext */\",\n  \"\tyy_hold_char = *++yy_c_buf_p;\",\n  \"\",\n  \"%% update BOL and yylineno\",\n  \"\",\n  \"\treturn c;\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"void yyrestart( FILE *input_file )\",\n  \"#else\",\n  \"void yyrestart( input_file )\",\n  \"FILE *input_file;\",\n  \"#endif\",\n  \"%+\",\n  \"void yyFlexLexer::yyrestart( istream* input_file )\",\n  \"%*\",\n  \"\t{\",\n  \"\tif ( ! yy_current_buffer )\",\n  \"\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );\",\n  \"\",\n  \"\tyy_init_buffer( yy_current_buffer, input_file );\",\n  \"\tyy_load_buffer_state();\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\",\n  \"#else\",\n  \"void yy_switch_to_buffer( new_buffer )\",\n  \"YY_BUFFER_STATE new_buffer;\",\n  \"#endif\",\n  \"%+\",\n  \"void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\",\n  \"%*\",\n  \"\t{\",\n  \"\tif ( yy_current_buffer == new_buffer )\",\n  \"\t\treturn;\",\n  \"\",\n  \"\tif ( yy_current_buffer )\",\n  \"\t\t{\",\n  \"\t\t/* Flush out information for old buffer. */\",\n  \"\t\t*yy_c_buf_p = yy_hold_char;\",\n  \"\t\tyy_current_buffer->yy_buf_pos = yy_c_buf_p;\",\n  \"\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\",\n  \"\t\t}\",\n  \"\",\n  \"\tyy_current_buffer = new_buffer;\",\n  \"\tyy_load_buffer_state();\",\n  \"\",\n  \"\t/* We don't actually know whether we did this switch during\",\n  \"\t * EOF (yywrap()) processing, but the only time this flag\",\n  \"\t * is looked at is after yywrap() is called, so it's safe\",\n  \"\t * to go ahead and always set it.\",\n  \"\t */\",\n  \"\tyy_did_buffer_switch_on_eof = 1;\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"void yy_load_buffer_state( void )\",\n  \"#else\",\n  \"void yy_load_buffer_state()\",\n  \"#endif\",\n  \"%+\",\n  \"void yyFlexLexer::yy_load_buffer_state()\",\n  \"%*\",\n  \"\t{\",\n  \"\tyy_n_chars = yy_current_buffer->yy_n_chars;\",\n  \"\tyytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;\",\n  \"\tyyin = yy_current_buffer->yy_input_file;\",\n  \"\tyy_hold_char = *yy_c_buf_p;\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )\",\n  \"#else\",\n  \"YY_BUFFER_STATE yy_create_buffer( file, size )\",\n  \"FILE *file;\",\n  \"int size;\",\n  \"#endif\",\n  \"%+\",\n  \"YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( istream* file, int size )\",\n  \"%*\",\n  \"\t{\",\n  \"\tYY_BUFFER_STATE b;\",\n  \"\",\n  \"\tb = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );\",\n  \"\tif ( ! b )\",\n  \"\t\tYY_FATAL_ERROR( \\\"out of dynamic memory in yy_create_buffer()\\\" );\",\n  \"\",\n  \"\tb->yy_buf_size = size;\",\n  \"\",\n  \"\t/* yy_ch_buf has to be 2 characters longer than the size given because\",\n  \"\t * we need to put in 2 end-of-buffer characters.\",\n  \"\t */\",\n  \"\tb->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );\",\n  \"\tif ( ! b->yy_ch_buf )\",\n  \"\t\tYY_FATAL_ERROR( \\\"out of dynamic memory in yy_create_buffer()\\\" );\",\n  \"\",\n  \"\tb->yy_is_our_buffer = 1;\",\n  \"\",\n  \"\tyy_init_buffer( b, file );\",\n  \"\",\n  \"\treturn b;\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"void yy_delete_buffer( YY_BUFFER_STATE b )\",\n  \"#else\",\n  \"void yy_delete_buffer( b )\",\n  \"YY_BUFFER_STATE b;\",\n  \"#endif\",\n  \"%+\",\n  \"void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )\",\n  \"%*\",\n  \"\t{\",\n  \"\tif ( ! b )\",\n  \"\t\treturn;\",\n  \"\",\n  \"\tif ( b == yy_current_buffer )\",\n  \"\t\tyy_current_buffer = (YY_BUFFER_STATE) 0;\",\n  \"\",\n  \"\tif ( b->yy_is_our_buffer )\",\n  \"\t\tyy_flex_free( (void *) b->yy_ch_buf );\",\n  \"\",\n  \"\tyy_flex_free( (void *) b );\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifndef YY_ALWAYS_INTERACTIVE\",\n  \"#ifndef YY_NEVER_INTERACTIVE\",\n  \"extern int isatty YY_PROTO(( int ));\",\n  \"#endif\",\n  \"#endif\",\n  \"\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )\",\n  \"#else\",\n  \"void yy_init_buffer( b, file )\",\n  \"YY_BUFFER_STATE b;\",\n  \"FILE *file;\",\n  \"#endif\",\n  \"\",\n  \"%+\",\n  \"extern \\\"C\\\" int isatty YY_PROTO(( int ));\",\n  \"void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, istream* file )\",\n  \"%*\",\n  \"\",\n  \"\t{\",\n  \"\tyy_flush_buffer( b );\",\n  \"\",\n  \"\tb->yy_input_file = file;\",\n  \"\tb->yy_fill_buffer = 1;\",\n  \"\",\n  \"%-\",\n  \"#if YY_ALWAYS_INTERACTIVE\",\n  \"\tb->yy_is_interactive = 1;\",\n  \"#else\",\n  \"#if YY_NEVER_INTERACTIVE\",\n  \"\tb->yy_is_interactive = 0;\",\n  \"#else\",\n  \"\tb->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\",\n  \"#endif\",\n  \"#endif\",\n  \"%+\",\n  \"\tb->yy_is_interactive = 0;\",\n  \"%*\",\n  \"\t}\",\n  \"\",\n  \"\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"void yy_flush_buffer( YY_BUFFER_STATE b )\",\n  \"#else\",\n  \"void yy_flush_buffer( b )\",\n  \"YY_BUFFER_STATE b;\",\n  \"#endif\",\n  \"\",\n  \"%+\",\n  \"void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )\",\n  \"%*\",\n  \"\t{\",\n  \"\tif ( ! b )\",\n  \"\t\treturn;\",\n  \"\",\n  \"\tb->yy_n_chars = 0;\",\n  \"\",\n  \"\t/* We always need two end-of-buffer characters.  The first causes\",\n  \"\t * a transition to the end-of-buffer state.  The second causes\",\n  \"\t * a jam in that state.\",\n  \"\t */\",\n  \"\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\",\n  \"\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\",\n  \"\",\n  \"\tb->yy_buf_pos = &b->yy_ch_buf[0];\",\n  \"\",\n  \"\tb->yy_at_bol = 1;\",\n  \"\tb->yy_buffer_status = YY_BUFFER_NEW;\",\n  \"\",\n  \"\tif ( b == yy_current_buffer )\",\n  \"\t\tyy_load_buffer_state();\",\n  \"\t}\",\n  \"%*\",\n  \"\",\n  \"\",\n  \"#ifndef YY_NO_SCAN_BUFFER\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )\",\n  \"#else\",\n  \"YY_BUFFER_STATE yy_scan_buffer( base, size )\",\n  \"char *base;\",\n  \"yy_size_t size;\",\n  \"#endif\",\n  \"\t{\",\n  \"\tYY_BUFFER_STATE b;\",\n  \"\",\n  \"\tif ( size < 2 ||\",\n  \"\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\",\n  \"\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\",\n  \"\t\t/* They forgot to leave room for the EOB's. */\",\n  \"\t\treturn 0;\",\n  \"\",\n  \"\tb = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );\",\n  \"\tif ( ! b )\",\n  \"\t\tYY_FATAL_ERROR( \\\"out of dynamic memory in yy_scan_buffer()\\\" );\",\n  \"\",\n  \"\tb->yy_buf_size = size - 2;\t/* \\\"- 2\\\" to take care of EOB's */\",\n  \"\tb->yy_buf_pos = b->yy_ch_buf = base;\",\n  \"\tb->yy_is_our_buffer = 0;\",\n  \"\tb->yy_input_file = 0;\",\n  \"\tb->yy_n_chars = b->yy_buf_size;\",\n  \"\tb->yy_is_interactive = 0;\",\n  \"\tb->yy_at_bol = 1;\",\n  \"\tb->yy_fill_buffer = 0;\",\n  \"\tb->yy_buffer_status = YY_BUFFER_NEW;\",\n  \"\",\n  \"\tyy_switch_to_buffer( b );\",\n  \"\",\n  \"\treturn b;\",\n  \"\t}\",\n  \"%*\",\n  \"#endif\",\n  \"\",\n  \"\",\n  \"#ifndef YY_NO_SCAN_STRING\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )\",\n  \"#else\",\n  \"YY_BUFFER_STATE yy_scan_string( yy_str )\",\n  \"yyconst char *yy_str;\",\n  \"#endif\",\n  \"\t{\",\n  \"\tint len;\",\n  \"\tfor ( len = 0; yy_str[len]; ++len )\",\n  \"\t\t;\",\n  \"\",\n  \"\treturn yy_scan_bytes( yy_str, len );\",\n  \"\t}\",\n  \"%*\",\n  \"#endif\",\n  \"\",\n  \"\",\n  \"#ifndef YY_NO_SCAN_BYTES\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )\",\n  \"#else\",\n  \"YY_BUFFER_STATE yy_scan_bytes( bytes, len )\",\n  \"yyconst char *bytes;\",\n  \"int len;\",\n  \"#endif\",\n  \"\t{\",\n  \"\tYY_BUFFER_STATE b;\",\n  \"\tchar *buf;\",\n  \"\tyy_size_t n;\",\n  \"\tint i;\",\n  \"\",\n  \"\t/* Get memory for full buffer, including space for trailing EOB's. */\",\n  \"\tn = len + 2;\",\n  \"\tbuf = (char *) yy_flex_alloc( n );\",\n  \"\tif ( ! buf )\",\n  \"\t\tYY_FATAL_ERROR( \\\"out of dynamic memory in yy_scan_bytes()\\\" );\",\n  \"\",\n  \"\tfor ( i = 0; i < len; ++i )\",\n  \"\t\tbuf[i] = bytes[i];\",\n  \"\",\n  \"\tbuf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;\",\n  \"\",\n  \"\tb = yy_scan_buffer( buf, n );\",\n  \"\tif ( ! b )\",\n  \"\t\tYY_FATAL_ERROR( \\\"bad buffer in yy_scan_bytes()\\\" );\",\n  \"\",\n  \"\t/* It's okay to grow etc. this buffer, and we should throw it\",\n  \"\t * away when we're done.\",\n  \"\t */\",\n  \"\tb->yy_is_our_buffer = 1;\",\n  \"\",\n  \"\treturn b;\",\n  \"\t}\",\n  \"%*\",\n  \"#endif\",\n  \"\",\n  \"\",\n  \"#ifndef YY_NO_PUSH_STATE\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static void yy_push_state( int new_state )\",\n  \"#else\",\n  \"static void yy_push_state( new_state )\",\n  \"int new_state;\",\n  \"#endif\",\n  \"%+\",\n  \"void yyFlexLexer::yy_push_state( int new_state )\",\n  \"%*\",\n  \"\t{\",\n  \"\tif ( yy_start_stack_ptr >= yy_start_stack_depth )\",\n  \"\t\t{\",\n  \"\t\tyy_size_t new_size;\",\n  \"\",\n  \"\t\tyy_start_stack_depth += YY_START_STACK_INCR;\",\n  \"\t\tnew_size = yy_start_stack_depth * sizeof( int );\",\n  \"\",\n  \"\t\tif ( ! yy_start_stack )\",\n  \"\t\t\tyy_start_stack = (int *) yy_flex_alloc( new_size );\",\n  \"\",\n  \"\t\telse\",\n  \"\t\t\tyy_start_stack = (int *) yy_flex_realloc(\",\n  \"\t\t\t\t\t(void *) yy_start_stack, new_size );\",\n  \"\",\n  \"\t\tif ( ! yy_start_stack )\",\n  \"\t\t\tYY_FATAL_ERROR(\",\n  \"\t\t\t\\\"out of memory expanding start-condition stack\\\" );\",\n  \"\t\t}\",\n  \"\",\n  \"\tyy_start_stack[yy_start_stack_ptr++] = YY_START;\",\n  \"\",\n  \"\tBEGIN(new_state);\",\n  \"\t}\",\n  \"#endif\",\n  \"\",\n  \"\",\n  \"#ifndef YY_NO_POP_STATE\",\n  \"%-\",\n  \"static void yy_pop_state()\",\n  \"%+\",\n  \"void yyFlexLexer::yy_pop_state()\",\n  \"%*\",\n  \"\t{\",\n  \"\tif ( --yy_start_stack_ptr < 0 )\",\n  \"\t\tYY_FATAL_ERROR( \\\"start-condition stack underflow\\\" );\",\n  \"\",\n  \"\tBEGIN(yy_start_stack[yy_start_stack_ptr]);\",\n  \"\t}\",\n  \"#endif\",\n  \"\",\n  \"\",\n  \"#ifndef YY_NO_TOP_STATE\",\n  \"%-\",\n  \"static int yy_top_state()\",\n  \"%+\",\n  \"int yyFlexLexer::yy_top_state()\",\n  \"%*\",\n  \"\t{\",\n  \"\treturn yy_start_stack[yy_start_stack_ptr - 1];\",\n  \"\t}\",\n  \"#endif\",\n  \"\",\n  \"#ifndef YY_EXIT_FAILURE\",\n  \"#define YY_EXIT_FAILURE 2\",\n  \"#endif\",\n  \"\",\n  \"%-\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static void yy_fatal_error( yyconst char msg[] )\",\n  \"#else\",\n  \"static void yy_fatal_error( msg )\",\n  \"char msg[];\",\n  \"#endif\",\n  \"\t{\",\n  \"FILE *err;\",  /* ### modified(Jan.24.2001) ### */\n  \"\t(void) fprintf( err, \\\"%s\\\\n\\\", msg );\",\n  \"\texit( YY_EXIT_FAILURE );\",\n  \"\t}\",\n  \"\",\n  \"%+\",\n  \"\",\n  \"void yyFlexLexer::LexerError( yyconst char msg[] )\",\n  \"\t{\",\n  \"\tcerr << msg << '\\\\n';\",\n  \"\texit( YY_EXIT_FAILURE );\",\n  \"\t}\",\n  \"%*\",\n  \"\",\n  \"\",\n  \"/* Redefine yyless() so it works in section 3 code. */\",\n  \"\",\n  \"#undef yyless\",\n  \"#define yyless(n) \\\\\",\n  \"\tdo \\\\\",\n  \"\t\t{ \\\\\",\n  \"\t\t/* Undo effects of setting up yytext. */ \\\\\",\n  \"\t\tyytext[yyleng] = yy_hold_char; \\\\\",\n  \"\t\tyy_c_buf_p = yytext + n; \\\\\",\n  \"\t\tyy_hold_char = *yy_c_buf_p; \\\\\",\n  \"\t\t*yy_c_buf_p = '\\\\0'; \\\\\",\n  \"\t\tyyleng = n; \\\\\",\n  \"\t\t} \\\\\",\n  \"\twhile ( 0 )\",\n  \"\",\n  \"\",\n  \"/* Internal utility routines. */\",\n  \"\",\n  \"#ifndef yytext_ptr\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )\",\n  \"#else\",\n  \"static void yy_flex_strncpy( s1, s2, n )\",\n  \"char *s1;\",\n  \"yyconst char *s2;\",\n  \"int n;\",\n  \"#endif\",\n  \"\t{\",\n  \"\tregister int i;\",\n  \"\tfor ( i = 0; i < n; ++i )\",\n  \"\t\ts1[i] = s2[i];\",\n  \"\t}\",\n  \"#endif\",\n  \"\",\n  \"#ifdef YY_NEED_STRLEN\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static int yy_flex_strlen( yyconst char *s )\",\n  \"#else\",\n  \"static int yy_flex_strlen( s )\",\n  \"yyconst char *s;\",\n  \"#endif\",\n  \"\t{\",\n  \"\tregister int n;\",\n  \"\tfor ( n = 0; s[n]; ++n )\",\n  \"\t\t;\",\n  \"\",\n  \"\treturn n;\",\n  \"\t}\",\n  \"#endif\",\n  \"\",\n  \"\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static void *yy_flex_alloc( yy_size_t size )\",\n  \"#else\",\n  \"static void *yy_flex_alloc( size )\",\n  \"yy_size_t size;\",\n  \"#endif\",\n  \"\t{\",\n  \"\treturn (void *) malloc( size );\",\n  \"\t}\",\n  \"\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static void *yy_flex_realloc( void *ptr, yy_size_t size )\",\n  \"#else\",\n  \"static void *yy_flex_realloc( ptr, size )\",\n  \"void *ptr;\",\n  \"yy_size_t size;\",\n  \"#endif\",\n  \"\t{\",\n  \"\t/* The cast to (char *) in the following accommodates both\",\n  \"\t * implementations that use char* generic pointers, and those\",\n  \"\t * that use void* generic pointers.  It works with the latter\",\n  \"\t * because both ANSI C and C++ allow castless assignment from\",\n  \"\t * any pointer type to void*, and deal with argument conversions\",\n  \"\t * as though doing an assignment.\",\n  \"\t */\",\n  \"\treturn (void *) realloc( (char *) ptr, size );\",\n  \"\t}\",\n  \"\",\n  \"#ifdef YY_USE_PROTOS\",\n  \"static void yy_flex_free( void *ptr )\",\n  \"#else\",\n  \"static void yy_flex_free( ptr )\",\n  \"void *ptr;\",\n  \"#endif\",\n  \"\t{\",\n  \"\tfree( ptr );\",\n  \"\t}\",\n  \"\",\n  \"#if YY_MAIN\",\n  \"int main()\",\n  \"\t{\",\n  \"\tyylex();\",\n  \"\treturn 0;\",\n  \"\t}\",\n  \"#endif\",\n  0\n};\n/* sym - symbol table routines */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n\n/* declare functions that have forward references */\n\nint hashfunct PROTO((register char[], int));\n\n\nstruct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];\nstruct hash_entry *sctbl[START_COND_HASH_SIZE];\nstruct hash_entry *ccltab[CCL_HASH_SIZE];\n\nstruct hash_entry *findsym();\n\n\n/* addsym - add symbol and definitions to symbol table\n *\n * -1 is returned if the symbol already exists, and the change not made.\n */\n\nint addsym( sym, str_def, int_def, table, table_size )\nregister char sym[];\nchar *str_def;\nint int_def;\nhash_table table;\nint table_size;\n\t{\n\tint hash_val = hashfunct( sym, table_size );\n\tregister struct hash_entry *sym_entry = table[hash_val];\n\tregister struct hash_entry *new_entry;\n\tregister struct hash_entry *successor;\n\n\twhile ( sym_entry )\n\t\t{\n\t\tif ( ! strcmp( sym, sym_entry->name ) )\n\t\t\t{ /* entry already exists */\n\t\t\treturn -1;\n\t\t\t}\n\n\t\tsym_entry = sym_entry->next;\n\t\t}\n\n\t/* create new entry */\n\tnew_entry = (struct hash_entry *)\n\t\tflex_alloc( sizeof( struct hash_entry ) );\n\n\tif ( new_entry == NULL )\n\t\tflexfatal( _( \"symbol table memory allocation failed\" ) );\n\n\tif ( (successor = table[hash_val]) != 0 )\n\t\t{\n\t\tnew_entry->next = successor;\n\t\tsuccessor->prev = new_entry;\n\t\t}\n\telse\n\t\tnew_entry->next = NULL;\n\n\tnew_entry->prev = NULL;\n\tnew_entry->name = sym;\n\tnew_entry->str_val = str_def;\n\tnew_entry->int_val = int_def;\n\n\ttable[hash_val] = new_entry;\n\n\treturn 0;\n\t}\n\n\n/* cclinstal - save the text of a character class */\n\nvoid cclinstal( ccltxt, cclnum )\nChar ccltxt[];\nint cclnum;\n\t{\n\t/* We don't bother checking the return status because we are not\n\t * called unless the symbol is new.\n\t */\n\tChar *copy_unsigned_string();\n\n\t(void) addsym( (char *) copy_unsigned_string( ccltxt ),\n\t\t\t(char *) 0, cclnum,\n\t\t\tccltab, CCL_HASH_SIZE );\n\t}\n\n\n/* ccllookup - lookup the number associated with character class text\n *\n * Returns 0 if there's no CCL associated with the text.\n */\n\nint ccllookup( ccltxt )\nChar ccltxt[];\n\t{\n\treturn findsym( (char *) ccltxt, ccltab, CCL_HASH_SIZE )->int_val;\n\t}\n\n\n/* findsym - find symbol in symbol table */\n\nstruct hash_entry *findsym( sym, table, table_size )\nregister char sym[];\nhash_table table;\nint table_size;\n\t{\n\tstatic struct hash_entry empty_entry =\n\t\t{\n\t\t(struct hash_entry *) 0, (struct hash_entry *) 0,\n\t\t(char *) 0, (char *) 0, 0,\n\t\t} ;\n\tregister struct hash_entry *sym_entry =\n\t\ttable[hashfunct( sym, table_size )];\n\n\twhile ( sym_entry )\n\t\t{\n\t\tif ( ! strcmp( sym, sym_entry->name ) )\n\t\t\treturn sym_entry;\n\t\tsym_entry = sym_entry->next;\n\t\t}\n\n\treturn &empty_entry;\n\t}\n\n\n/* hashfunct - compute the hash value for \"str\" and hash size \"hash_size\" */\n\nint hashfunct( str, hash_size )\nregister char str[];\nint hash_size;\n\t{\n\tregister int hashval;\n\tregister int locstr;\n\n\thashval = 0;\n\tlocstr = 0;\n\n\twhile ( str[locstr] )\n\t\t{\n\t\thashval = (hashval << 1) + (unsigned char) str[locstr++];\n\t\thashval %= hash_size;\n\t\t}\n\n\treturn hashval;\n\t}\n\n\n/* ndinstal - install a name definition */\n\nvoid ndinstal( name, definition )\nchar name[];\nChar definition[];\n\t{\n\tchar *copy_string();\n\tChar *copy_unsigned_string();\n\n\tif ( addsym( copy_string( name ),\n\t\t\t(char *) copy_unsigned_string( definition ), 0,\n\t\t\tndtbl, NAME_TABLE_HASH_SIZE ) )\n\t\tsynerr( _( \"name defined twice\" ) );\n\t}\n\n\n/* ndlookup - lookup a name definition\n *\n * Returns a nil pointer if the name definition does not exist.\n */\n\nChar *ndlookup( nd )\nchar nd[];\n\t{\n\treturn (Char *) findsym( nd, ndtbl, NAME_TABLE_HASH_SIZE )->str_val;\n\t}\n\n\n/* scextend - increase the maximum number of start conditions */\n\nvoid scextend()\n\t{\n\tcurrent_max_scs += MAX_SCS_INCREMENT;\n\n\t++num_reallocs;\n\n\tscset = reallocate_integer_array( scset, current_max_scs );\n\tscbol = reallocate_integer_array( scbol, current_max_scs );\n\tscxclu = reallocate_integer_array( scxclu, current_max_scs );\n\tsceof = reallocate_integer_array( sceof, current_max_scs );\n\tscname = reallocate_char_ptr_array( scname, current_max_scs );\n\t}\n\n\n/* scinstal - make a start condition\n *\n * NOTE\n *    The start condition is \"exclusive\" if xcluflg is true.\n */\n\nvoid scinstal( str, xcluflg )\nchar str[];\nint xcluflg;\n\t{\n\tchar *copy_string();\n\n\t/* Generate start condition definition, for use in BEGIN et al. */\n\taction_define( str, lastsc );\n\n\tif ( ++lastsc >= current_max_scs )\n\t\tscextend();\n\n\tscname[lastsc] = copy_string( str );\n\n\tif ( addsym( scname[lastsc], (char *) 0, lastsc,\n\t\t\tsctbl, START_COND_HASH_SIZE ) )\n\t\tformat_pinpoint_message(\n\t\t\t\t_( \"start condition %s declared twice\" ),\n\t\t\t\t\tstr );\n\n\tscset[lastsc] = mkstate( SYM_EPSILON );\n\tscbol[lastsc] = mkstate( SYM_EPSILON );\n\tscxclu[lastsc] = xcluflg;\n\tsceof[lastsc] = false;\n\t}\n\n\n/* sclookup - lookup the number associated with a start condition\n *\n * Returns 0 if no such start condition.\n */\n\nint sclookup( str )\nchar str[];\n\t{\n\treturn findsym( str, sctbl, START_COND_HASH_SIZE )->int_val;\n\t}\n/* tblcmp - table compression routines */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n\n/* declarations for functions that have forward references */\n\nvoid mkentry PROTO((register int*, int, int, int, int));\nvoid mkprot PROTO((int[], int, int));\nvoid mktemplate PROTO((int[], int, int));\nvoid mv2front PROTO((int));\nint tbldiff PROTO((int[], int, int[]));\n\n\n/* bldtbl - build table entries for dfa state\n *\n * synopsis\n *   int state[numecs], statenum, totaltrans, comstate, comfreq;\n *   bldtbl( state, statenum, totaltrans, comstate, comfreq );\n *\n * State is the statenum'th dfa state.  It is indexed by equivalence class and\n * gives the number of the state to enter for a given equivalence class.\n * totaltrans is the total number of transitions out of the state.  Comstate\n * is that state which is the destination of the most transitions out of State.\n * Comfreq is how many transitions there are out of State to Comstate.\n *\n * A note on terminology:\n *    \"protos\" are transition tables which have a high probability of\n * either being redundant (a state processed later will have an identical\n * transition table) or nearly redundant (a state processed later will have\n * many of the same out-transitions).  A \"most recently used\" queue of\n * protos is kept around with the hope that most states will find a proto\n * which is similar enough to be usable, and therefore compacting the\n * output tables.\n *    \"templates\" are a special type of proto.  If a transition table is\n * homogeneous or nearly homogeneous (all transitions go to the same\n * destination) then the odds are good that future states will also go\n * to the same destination state on basically the same character set.\n * These homogeneous states are so common when dealing with large rule\n * sets that they merit special attention.  If the transition table were\n * simply made into a proto, then (typically) each subsequent, similar\n * state will differ from the proto for two out-transitions.  One of these\n * out-transitions will be that character on which the proto does not go\n * to the common destination, and one will be that character on which the\n * state does not go to the common destination.  Templates, on the other\n * hand, go to the common state on EVERY transition character, and therefore\n * cost only one difference.\n */\n\nvoid bldtbl( state, statenum, totaltrans, comstate, comfreq )\nint state[], statenum, totaltrans, comstate, comfreq;\n\t{\n\tint extptr, extrct[2][CSIZE + 1];\n\tint mindiff, minprot, i, d;\n\n\t/* If extptr is 0 then the first array of extrct holds the result\n\t * of the \"best difference\" to date, which is those transitions\n\t * which occur in \"state\" but not in the proto which, to date,\n\t * has the fewest differences between itself and \"state\".  If\n\t * extptr is 1 then the second array of extrct hold the best\n\t * difference.  The two arrays are toggled between so that the\n\t * best difference to date can be kept around and also a difference\n\t * just created by checking against a candidate \"best\" proto.\n\t */\n\n\textptr = 0;\n\n\t/* If the state has too few out-transitions, don't bother trying to\n\t * compact its tables.\n\t */\n\n\tif ( (totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE) )\n\t\tmkentry( state, numecs, statenum, JAMSTATE, totaltrans );\n\n\telse\n\t\t{\n\t\t/* \"checkcom\" is true if we should only check \"state\" against\n\t\t * protos which have the same \"comstate\" value.\n\t\t */\n\t\tint checkcom =\n\t\t\tcomfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;\n\n\t\tminprot = firstprot;\n\t\tmindiff = totaltrans;\n\n\t\tif ( checkcom )\n\t\t\t{\n\t\t\t/* Find first proto which has the same \"comstate\". */\n\t\t\tfor ( i = firstprot; i != NIL; i = protnext[i] )\n\t\t\t\tif ( protcomst[i] == comstate )\n\t\t\t\t\t{\n\t\t\t\t\tminprot = i;\n\t\t\t\t\tmindiff = tbldiff( state, minprot,\n\t\t\t\t\t\t\textrct[extptr] );\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* Since we've decided that the most common destination\n\t\t\t * out of \"state\" does not occur with a high enough\n\t\t\t * frequency, we set the \"comstate\" to zero, assuring\n\t\t\t * that if this state is entered into the proto list,\n\t\t\t * it will not be considered a template.\n\t\t\t */\n\t\t\tcomstate = 0;\n\n\t\t\tif ( firstprot != NIL )\n\t\t\t\t{\n\t\t\t\tminprot = firstprot;\n\t\t\t\tmindiff = tbldiff( state, minprot,\n\t\t\t\t\t\textrct[extptr] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* We now have the first interesting proto in \"minprot\".  If\n\t\t * it matches within the tolerances set for the first proto,\n\t\t * we don't want to bother scanning the rest of the proto list\n\t\t * to see if we have any other reasonable matches.\n\t\t */\n\n\t\tif ( mindiff * 100 > totaltrans * FIRST_MATCH_DIFF_PERCENTAGE )\n\t\t\t{\n\t\t\t/* Not a good enough match.  Scan the rest of the\n\t\t\t * protos.\n\t\t\t */\n\t\t\tfor ( i = minprot; i != NIL; i = protnext[i] )\n\t\t\t\t{\n\t\t\t\td = tbldiff( state, i, extrct[1 - extptr] );\n\t\t\t\tif ( d < mindiff )\n\t\t\t\t\t{\n\t\t\t\t\textptr = 1 - extptr;\n\t\t\t\t\tmindiff = d;\n\t\t\t\t\tminprot = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* Check if the proto we've decided on as our best bet is close\n\t\t * enough to the state we want to match to be usable.\n\t\t */\n\n\t\tif ( mindiff * 100 > totaltrans * ACCEPTABLE_DIFF_PERCENTAGE )\n\t\t\t{\n\t\t\t/* No good.  If the state is homogeneous enough,\n\t\t\t * we make a template out of it.  Otherwise, we\n\t\t\t * make a proto.\n\t\t\t */\n\n\t\t\tif ( comfreq * 100 >=\n\t\t\t     totaltrans * TEMPLATE_SAME_PERCENTAGE )\n\t\t\t\tmktemplate( state, statenum, comstate );\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tmkprot( state, statenum, comstate );\n\t\t\t\tmkentry( state, numecs, statenum,\n\t\t\t\t\tJAMSTATE, totaltrans );\n\t\t\t\t}\n\t\t\t}\n\n\t\telse\n\t\t\t{ /* use the proto */\n\t\t\tmkentry( extrct[extptr], numecs, statenum,\n\t\t\t\tprottbl[minprot], mindiff );\n\n\t\t\t/* If this state was sufficiently different from the\n\t\t\t * proto we built it from, make it, too, a proto.\n\t\t\t */\n\n\t\t\tif ( mindiff * 100 >=\n\t\t\t     totaltrans * NEW_PROTO_DIFF_PERCENTAGE )\n\t\t\t\tmkprot( state, statenum, comstate );\n\n\t\t\t/* Since mkprot added a new proto to the proto queue,\n\t\t\t * it's possible that \"minprot\" is no longer on the\n\t\t\t * proto queue (if it happened to have been the last\n\t\t\t * entry, it would have been bumped off).  If it's\n\t\t\t * not there, then the new proto took its physical\n\t\t\t * place (though logically the new proto is at the\n\t\t\t * beginning of the queue), so in that case the\n\t\t\t * following call will do nothing.\n\t\t\t */\n\n\t\t\tmv2front( minprot );\n\t\t\t}\n\t\t}\n\t}\n\n\n/* cmptmps - compress template table entries\n *\n * Template tables are compressed by using the 'template equivalence\n * classes', which are collections of transition character equivalence\n * classes which always appear together in templates - really meta-equivalence\n * classes.\n */\n\nvoid cmptmps()\n\t{\n\tint tmpstorage[CSIZE + 1];\n\tregister int *tmp = tmpstorage, i, j;\n\tint totaltrans, trans;\n\n\tpeakpairs = numtemps * numecs + tblend;\n\n\tif ( usemecs )\n\t\t{\n\t\t/* Create equivalence classes based on data gathered on\n\t\t * template transitions.\n\t\t */\n\t\tnummecs = cre8ecs( tecfwd, tecbck, numecs );\n\t\t}\n\n\telse\n\t\tnummecs = numecs;\n\n\twhile ( lastdfa + numtemps + 1 >= current_max_dfas )\n\t\tincrease_max_dfas();\n\n\t/* Loop through each template. */\n\n\tfor ( i = 1; i <= numtemps; ++i )\n\t\t{\n\t\t/* Number of non-jam transitions out of this template. */\n\t\ttotaltrans = 0;\n\n\t\tfor ( j = 1; j <= numecs; ++j )\n\t\t\t{\n\t\t\ttrans = tnxt[numecs * i + j];\n\n\t\t\tif ( usemecs )\n\t\t\t\t{\n\t\t\t\t/* The absolute value of tecbck is the\n\t\t\t\t * meta-equivalence class of a given\n\t\t\t\t * equivalence class, as set up by cre8ecs().\n\t\t\t\t */\n\t\t\t\tif ( tecbck[j] > 0 )\n\t\t\t\t\t{\n\t\t\t\t\ttmp[tecbck[j]] = trans;\n\n\t\t\t\t\tif ( trans > 0 )\n\t\t\t\t\t\t++totaltrans;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ttmp[j] = trans;\n\n\t\t\t\tif ( trans > 0 )\n\t\t\t\t\t++totaltrans;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* It is assumed (in a rather subtle way) in the skeleton\n\t\t * that if we're using meta-equivalence classes, the def[]\n\t\t * entry for all templates is the jam template, i.e.,\n\t\t * templates never default to other non-jam table entries\n\t\t * (e.g., another template)\n\t\t */\n\n\t\t/* Leave room for the jam-state after the last real state. */\n\t\tmkentry( tmp, nummecs, lastdfa + i + 1, JAMSTATE, totaltrans );\n\t\t}\n\t}\n\n\n\n/* expand_nxt_chk - expand the next check arrays */\n\nvoid expand_nxt_chk()\n\t{\n\tregister int old_max = current_max_xpairs;\n\n\tcurrent_max_xpairs += MAX_XPAIRS_INCREMENT;\n\n\t++num_reallocs;\n\n\tnxt = reallocate_integer_array( nxt, current_max_xpairs );\n\tchk = reallocate_integer_array( chk, current_max_xpairs );\n\n\tzero_out( (char *) (chk + old_max),\n\t\t(size_t) (MAX_XPAIRS_INCREMENT * sizeof( int )) );\n\t}\n\n\n/* find_table_space - finds a space in the table for a state to be placed\n *\n * synopsis\n *     int *state, numtrans, block_start;\n *     int find_table_space();\n *\n *     block_start = find_table_space( state, numtrans );\n *\n * State is the state to be added to the full speed transition table.\n * Numtrans is the number of out-transitions for the state.\n *\n * find_table_space() returns the position of the start of the first block (in\n * chk) able to accommodate the state\n *\n * In determining if a state will or will not fit, find_table_space() must take\n * into account the fact that an end-of-buffer state will be added at [0],\n * and an action number will be added in [-1].\n */\n\nint find_table_space( state, numtrans )\nint *state, numtrans;\n\t{\n\t/* Firstfree is the position of the first possible occurrence of two\n\t * consecutive unused records in the chk and nxt arrays.\n\t */\n\tregister int i;\n\tregister int *state_ptr, *chk_ptr;\n\tregister int *ptr_to_last_entry_in_state;\n\n\t/* If there are too many out-transitions, put the state at the end of\n\t * nxt and chk.\n\t */\n\tif ( numtrans > MAX_XTIONS_FULL_INTERIOR_FIT )\n\t\t{\n\t\t/* If table is empty, return the first available spot in\n\t\t * chk/nxt, which should be 1.\n\t\t */\n\t\tif ( tblend < 2 )\n\t\t\treturn 1;\n\n\t\t/* Start searching for table space near the end of\n\t\t * chk/nxt arrays.\n\t\t */\n\t\ti = tblend - numecs;\n\t\t}\n\n\telse\n\t\t/* Start searching for table space from the beginning\n\t\t * (skipping only the elements which will definitely not\n\t\t * hold the new state).\n\t\t */\n\t\ti = firstfree;\n\n\twhile ( 1 )\t/* loops until a space is found */\n\t\t{\n\t\twhile ( i + numecs >= current_max_xpairs )\n\t\t\texpand_nxt_chk();\n\n\t\t/* Loops until space for end-of-buffer and action number\n\t\t * are found.\n\t\t */\n\t\twhile ( 1 )\n\t\t\t{\n\t\t\t/* Check for action number space. */\n\t\t\tif ( chk[i - 1] == 0 )\n\t\t\t\t{\n\t\t\t\t/* Check for end-of-buffer space. */\n\t\t\t\tif ( chk[i] == 0 )\n\t\t\t\t\tbreak;\n\n\t\t\t\telse\n\t\t\t\t\t/* Since i != 0, there is no use\n\t\t\t\t\t * checking to see if (++i) - 1 == 0,\n\t\t\t\t\t * because that's the same as i == 0,\n\t\t\t\t\t * so we skip a space.\n\t\t\t\t\t */\n\t\t\t\t\ti += 2;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t++i;\n\n\t\t\twhile ( i + numecs >= current_max_xpairs )\n\t\t\t\texpand_nxt_chk();\n\t\t\t}\n\n\t\t/* If we started search from the beginning, store the new\n\t\t * firstfree for the next call of find_table_space().\n\t\t */\n\t\tif ( numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT )\n\t\t\tfirstfree = i + 1;\n\n\t\t/* Check to see if all elements in chk (and therefore nxt)\n\t\t * that are needed for the new state have not yet been taken.\n\t\t */\n\n\t\tstate_ptr = &state[1];\n\t\tptr_to_last_entry_in_state = &chk[i + numecs + 1];\n\n\t\tfor ( chk_ptr = &chk[i + 1];\n\t\t      chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr )\n\t\t\tif ( *(state_ptr++) != 0 && *chk_ptr != 0 )\n\t\t\t\tbreak;\n\n\t\tif ( chk_ptr == ptr_to_last_entry_in_state )\n\t\t\treturn i;\n\n\t\telse\n\t\t++i;\n\t\t}\n\t}\n\n\n/* inittbl - initialize transition tables\n *\n * Initializes \"firstfree\" to be one beyond the end of the table.  Initializes\n * all \"chk\" entries to be zero.\n */\nvoid inittbl()\n\t{\n\tregister int i;\n\n\tzero_out( (char *) chk, (size_t) (current_max_xpairs * sizeof( int )) );\n\n\ttblend = 0;\n\tfirstfree = tblend + 1;\n\tnumtemps = 0;\n\n\tif ( usemecs )\n\t\t{\n\t\t/* Set up doubly-linked meta-equivalence classes; these\n\t\t * are sets of equivalence classes which all have identical\n\t\t * transitions out of TEMPLATES.\n\t\t */\n\n\t\ttecbck[1] = NIL;\n\n\t\tfor ( i = 2; i <= numecs; ++i )\n\t\t\t{\n\t\t\ttecbck[i] = i - 1;\n\t\t\ttecfwd[i - 1] = i;\n\t\t\t}\n\n\t\ttecfwd[numecs] = NIL;\n\t\t}\n\t}\n\n\n/* mkdeftbl - make the default, \"jam\" table entries */\n\nvoid mkdeftbl()\n\t{\n\tint i;\n\n\tjamstate = lastdfa + 1;\n\n\t++tblend; /* room for transition on end-of-buffer character */\n\n\twhile ( tblend + numecs >= current_max_xpairs )\n\t\texpand_nxt_chk();\n\n\t/* Add in default end-of-buffer transition. */\n\tnxt[tblend] = end_of_buffer_state;\n\tchk[tblend] = jamstate;\n\n\tfor ( i = 1; i <= numecs; ++i )\n\t\t{\n\t\tnxt[tblend + i] = 0;\n\t\tchk[tblend + i] = jamstate;\n\t\t}\n\n\tjambase = tblend;\n\n\tbase[jamstate] = jambase;\n\tdef[jamstate] = 0;\n\n\ttblend += numecs;\n\t++numtemps;\n\t}\n\n\n/* mkentry - create base/def and nxt/chk entries for transition array\n *\n * synopsis\n *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;\n *   mkentry( state, numchars, statenum, deflink, totaltrans );\n *\n * \"state\" is a transition array \"numchars\" characters in size, \"statenum\"\n * is the offset to be used into the base/def tables, and \"deflink\" is the\n * entry to put in the \"def\" table entry.  If \"deflink\" is equal to\n * \"JAMSTATE\", then no attempt will be made to fit zero entries of \"state\"\n * (i.e., jam entries) into the table.  It is assumed that by linking to\n * \"JAMSTATE\" they will be taken care of.  In any case, entries in \"state\"\n * marking transitions to \"SAME_TRANS\" are treated as though they will be\n * taken care of by whereever \"deflink\" points.  \"totaltrans\" is the total\n * number of transitions out of the state.  If it is below a certain threshold,\n * the tables are searched for an interior spot that will accommodate the\n * state array.\n */\n\nvoid mkentry( state, numchars, statenum, deflink, totaltrans )\nregister int *state;\nint numchars, statenum, deflink, totaltrans;\n\t{\n\tregister int minec, maxec, i, baseaddr;\n\tint tblbase, tbllast;\n\n\tif ( totaltrans == 0 )\n\t\t{ /* there are no out-transitions */\n\t\tif ( deflink == JAMSTATE )\n\t\t\tbase[statenum] = JAMSTATE;\n\t\telse\n\t\t\tbase[statenum] = 0;\n\n\t\tdef[statenum] = deflink;\n\t\treturn;\n\t\t}\n\n\tfor ( minec = 1; minec <= numchars; ++minec )\n\t\t{\n\t\tif ( state[minec] != SAME_TRANS )\n\t\t\tif ( state[minec] != 0 || deflink != JAMSTATE )\n\t\t\t\tbreak;\n\t\t}\n\n\tif ( totaltrans == 1 )\n\t\t{\n\t\t/* There's only one out-transition.  Save it for later to fill\n\t\t * in holes in the tables.\n\t\t */\n\t\tstack1( statenum, minec, state[minec], deflink );\n\t\treturn;\n\t\t}\n\n\tfor ( maxec = numchars; maxec > 0; --maxec )\n\t\t{\n\t\tif ( state[maxec] != SAME_TRANS )\n\t\t\tif ( state[maxec] != 0 || deflink != JAMSTATE )\n\t\t\t\tbreak;\n\t\t}\n\n\t/* Whether we try to fit the state table in the middle of the table\n\t * entries we have already generated, or if we just take the state\n\t * table at the end of the nxt/chk tables, we must make sure that we\n\t * have a valid base address (i.e., non-negative).  Note that\n\t * negative base addresses dangerous at run-time (because indexing\n\t * the nxt array with one and a low-valued character will access\n\t * memory before the start of the array.\n\t */\n\n\t/* Find the first transition of state that we need to worry about. */\n\tif ( totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE )\n\t\t{\n\t\t/* Attempt to squeeze it into the middle of the tables. */\n\t\tbaseaddr = firstfree;\n\n\t\twhile ( baseaddr < minec )\n\t\t\t{\n\t\t\t/* Using baseaddr would result in a negative base\n\t\t\t * address below; find the next free slot.\n\t\t\t */\n\t\t\tfor ( ++baseaddr; chk[baseaddr] != 0; ++baseaddr )\n\t\t\t\t;\n\t\t\t}\n\n\t\twhile ( baseaddr + maxec - minec + 1 >= current_max_xpairs )\n\t\t\texpand_nxt_chk();\n\n\t\tfor ( i = minec; i <= maxec; ++i )\n\t\t\tif ( state[i] != SAME_TRANS &&\n\t\t\t     (state[i] != 0 || deflink != JAMSTATE) &&\n\t\t\t     chk[baseaddr + i - minec] != 0 )\n\t\t\t\t{ /* baseaddr unsuitable - find another */\n\t\t\t\tfor ( ++baseaddr;\n\t\t\t\t      baseaddr < current_max_xpairs &&\n\t\t\t\t      chk[baseaddr] != 0; ++baseaddr )\n\t\t\t\t\t;\n\n\t\t\t\twhile ( baseaddr + maxec - minec + 1 >=\n\t\t\t\t\tcurrent_max_xpairs )\n\t\t\t\t\texpand_nxt_chk();\n\n\t\t\t\t/* Reset the loop counter so we'll start all\n\t\t\t\t * over again next time it's incremented.\n\t\t\t\t */\n\n\t\t\t\ti = minec - 1;\n\t\t\t\t}\n\t\t}\n\n\telse\n\t\t{\n\t\t/* Ensure that the base address we eventually generate is\n\t\t * non-negative.\n\t\t */\n\t\tbaseaddr = MAX( tblend + 1, minec );\n\t\t}\n\n\ttblbase = baseaddr - minec;\n\ttbllast = tblbase + maxec;\n\n\twhile ( tbllast + 1 >= current_max_xpairs )\n\t\texpand_nxt_chk();\n\n\tbase[statenum] = tblbase;\n\tdef[statenum] = deflink;\n\n\tfor ( i = minec; i <= maxec; ++i )\n\t\tif ( state[i] != SAME_TRANS )\n\t\t\tif ( state[i] != 0 || deflink != JAMSTATE )\n\t\t\t\t{\n\t\t\t\tnxt[tblbase + i] = state[i];\n\t\t\t\tchk[tblbase + i] = statenum;\n\t\t\t\t}\n\n\tif ( baseaddr == firstfree )\n\t\t/* Find next free slot in tables. */\n\t\tfor ( ++firstfree; chk[firstfree] != 0; ++firstfree )\n\t\t\t;\n\n\ttblend = MAX( tblend, tbllast );\n\t}\n\n\n/* mk1tbl - create table entries for a state (or state fragment) which\n *            has only one out-transition\n */\n\nvoid mk1tbl( state, sym, onenxt, onedef )\nint state, sym, onenxt, onedef;\n\t{\n\tif ( firstfree < sym )\n\t\tfirstfree = sym;\n\n\twhile ( chk[firstfree] != 0 )\n\t\tif ( ++firstfree >= current_max_xpairs )\n\t\t\texpand_nxt_chk();\n\n\tbase[state] = firstfree - sym;\n\tdef[state] = onedef;\n\tchk[firstfree] = state;\n\tnxt[firstfree] = onenxt;\n\n\tif ( firstfree > tblend )\n\t\t{\n\t\ttblend = firstfree++;\n\n\t\tif ( firstfree >= current_max_xpairs )\n\t\t\texpand_nxt_chk();\n\t\t}\n\t}\n\n\n/* mkprot - create new proto entry */\n\nvoid mkprot( state, statenum, comstate )\nint state[], statenum, comstate;\n\t{\n\tint i, slot, tblbase;\n\n\tif ( ++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE )\n\t\t{\n\t\t/* Gotta make room for the new proto by dropping last entry in\n\t\t * the queue.\n\t\t */\n\t\tslot = lastprot;\n\t\tlastprot = protprev[lastprot];\n\t\tprotnext[lastprot] = NIL;\n\t\t}\n\n\telse\n\t\tslot = numprots;\n\n\tprotnext[slot] = firstprot;\n\n\tif ( firstprot != NIL )\n\t\tprotprev[firstprot] = slot;\n\n\tfirstprot = slot;\n\tprottbl[slot] = statenum;\n\tprotcomst[slot] = comstate;\n\n\t/* Copy state into save area so it can be compared with rapidly. */\n\ttblbase = numecs * (slot - 1);\n\n\tfor ( i = 1; i <= numecs; ++i )\n\t\tprotsave[tblbase + i] = state[i];\n\t}\n\n\n/* mktemplate - create a template entry based on a state, and connect the state\n *              to it\n */\n\nvoid mktemplate( state, statenum, comstate )\nint state[], statenum, comstate;\n\t{\n\tint i, numdiff, tmpbase, tmp[CSIZE + 1];\n\tChar transset[CSIZE + 1];\n\tint tsptr;\n\n\t++numtemps;\n\n\ttsptr = 0;\n\n\t/* Calculate where we will temporarily store the transition table\n\t * of the template in the tnxt[] array.  The final transition table\n\t * gets created by cmptmps().\n\t */\n\n\ttmpbase = numtemps * numecs;\n\n\tif ( tmpbase + numecs >= current_max_template_xpairs )\n\t\t{\n\t\tcurrent_max_template_xpairs += MAX_TEMPLATE_XPAIRS_INCREMENT;\n\n\t\t++num_reallocs;\n\n\t\ttnxt = reallocate_integer_array( tnxt,\n\t\t\tcurrent_max_template_xpairs );\n\t\t}\n\n\tfor ( i = 1; i <= numecs; ++i )\n\t\tif ( state[i] == 0 )\n\t\t\ttnxt[tmpbase + i] = 0;\n\t\telse\n\t\t\t{\n\t\t\ttransset[tsptr++] = i;\n\t\t\ttnxt[tmpbase + i] = comstate;\n\t\t\t}\n\n\tif ( usemecs )\n\t\tmkeccl( transset, tsptr, tecfwd, tecbck, numecs, 0 );\n\n\tmkprot( tnxt + tmpbase, -numtemps, comstate );\n\n\t/* We rely on the fact that mkprot adds things to the beginning\n\t * of the proto queue.\n\t */\n\n\tnumdiff = tbldiff( state, firstprot, tmp );\n\tmkentry( tmp, numecs, statenum, -numtemps, numdiff );\n\t}\n\n\n/* mv2front - move proto queue element to front of queue */\n\nvoid mv2front( qelm )\nint qelm;\n\t{\n\tif ( firstprot != qelm )\n\t\t{\n\t\tif ( qelm == lastprot )\n\t\t\tlastprot = protprev[lastprot];\n\n\t\tprotnext[protprev[qelm]] = protnext[qelm];\n\n\t\tif ( protnext[qelm] != NIL )\n\t\t\tprotprev[protnext[qelm]] = protprev[qelm];\n\n\t\tprotprev[qelm] = NIL;\n\t\tprotnext[qelm] = firstprot;\n\t\tprotprev[firstprot] = qelm;\n\t\tfirstprot = qelm;\n\t\t}\n\t}\n\n\n/* place_state - place a state into full speed transition table\n *\n * State is the statenum'th state.  It is indexed by equivalence class and\n * gives the number of the state to enter for a given equivalence class.\n * Transnum is the number of out-transitions for the state.\n */\n\nvoid place_state( state, statenum, transnum )\nint *state, statenum, transnum;\n\t{\n\tregister int i;\n\tregister int *state_ptr;\n\tint position = find_table_space( state, transnum );\n\n\t/* \"base\" is the table of start positions. */\n\tbase[statenum] = position;\n\n\t/* Put in action number marker; this non-zero number makes sure that\n\t * find_table_space() knows that this position in chk/nxt is taken\n\t * and should not be used for another accepting number in another\n\t * state.\n\t */\n\tchk[position - 1] = 1;\n\n\t/* Put in end-of-buffer marker; this is for the same purposes as\n\t * above.\n\t */\n\tchk[position] = 1;\n\n\t/* Place the state into chk and nxt. */\n\tstate_ptr = &state[1];\n\n\tfor ( i = 1; i <= numecs; ++i, ++state_ptr )\n\t\tif ( *state_ptr != 0 )\n\t\t\t{\n\t\t\tchk[position + i] = i;\n\t\t\tnxt[position + i] = *state_ptr;\n\t\t\t}\n\n\tif ( position + numecs > tblend )\n\t\ttblend = position + numecs;\n\t}\n\n\n/* stack1 - save states with only one out-transition to be processed later\n *\n * If there's room for another state on the \"one-transition\" stack, the\n * state is pushed onto it, to be processed later by mk1tbl.  If there's\n * no room, we process the sucker right now.\n */\n\nvoid stack1( statenum, sym, nextstate, deflink )\nint statenum, sym, nextstate, deflink;\n\t{\n\tif ( onesp >= ONE_STACK_SIZE - 1 )\n\t\tmk1tbl( statenum, sym, nextstate, deflink );\n\n\telse\n\t\t{\n\t\t++onesp;\n\t\tonestate[onesp] = statenum;\n\t\tonesym[onesp] = sym;\n\t\tonenext[onesp] = nextstate;\n\t\tonedef[onesp] = deflink;\n\t\t}\n\t}\n\n\n/* tbldiff - compute differences between two state tables\n *\n * \"state\" is the state array which is to be extracted from the pr'th\n * proto.  \"pr\" is both the number of the proto we are extracting from\n * and an index into the save area where we can find the proto's complete\n * state table.  Each entry in \"state\" which differs from the corresponding\n * entry of \"pr\" will appear in \"ext\".\n *\n * Entries which are the same in both \"state\" and \"pr\" will be marked\n * as transitions to \"SAME_TRANS\" in \"ext\".  The total number of differences\n * between \"state\" and \"pr\" is returned as function value.  Note that this\n * number is \"numecs\" minus the number of \"SAME_TRANS\" entries in \"ext\".\n */\n\nint tbldiff( state, pr, ext )\nint state[], pr, ext[];\n\t{\n\tregister int i, *sp = state, *ep = ext, *protp;\n\tregister int numdiff = 0;\n\n\tprotp = &protsave[numecs * (pr - 1)];\n\n\tfor ( i = numecs; i > 0; --i )\n\t\t{\n\t\tif ( *++protp == *++sp )\n\t\t\t*++ep = SAME_TRANS;\n\t\telse\n\t\t\t{\n\t\t\t*++ep = *sp;\n\t\t\t++numdiff;\n\t\t\t}\n\t\t}\n\n\treturn numdiff;\n\t}\n/* yylex - scanner front-end for flex */\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n\n/* yylex - scan for a regular expression token */\n\nint yylex()\n\t{\n\tint toktype;\n\tstatic int beglin = false;\n\textern char *yytext;\n\n\tif ( eofseen )\n\t\ttoktype = EOF;\n\telse\n\t\ttoktype = flexscan();\n\n\tif ( toktype == EOF || toktype == 0 )\n\t\t{\n\t\teofseen = 1;\n\n\t\tif ( sectnum == 1 )\n\t\t\t{\n\t\t\tsynerr( _( \"premature EOF\" ) );\n\t\t\tsectnum = 2;\n\t\t\ttoktype = SECTEND;\n\t\t\t}\n\n\t\telse\n\t\t\ttoktype = 0;\n\t\t}\n\n\tif ( trace )\n\t\t{\n\t\tif ( beglin )\n\t\t\t{\n\t\t\tfprintf( err, \"%d\\t\", num_rules + 1 );\n\t\t\tbeglin = 0;\n\t\t\t}\n\n\t\tswitch ( toktype )\n\t\t\t{\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '$':\n\t\t\tcase '\"':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '|':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '-':\n\t\t\tcase '/':\n\t\t\tcase '\\\\':\n\t\t\tcase '?':\n\t\t\tcase '.':\n\t\t\tcase '*':\n\t\t\tcase '+':\n\t\t\tcase ',':\n\t\t\t\t(void) putc( toktype, err );\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\t\t(void) putc( '\\n', err );\n\n\t\t\t\tif ( sectnum == 2 )\n\t\t\t\tbeglin = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase SCDECL:\n\t\t\t\tfputs( \"%s\", err );\n\t\t\t\tbreak;\n\n\t\t\tcase XSCDECL:\n\t\t\t\tfputs( \"%x\", err );\n\t\t\t\tbreak;\n\n\t\t\tcase SECTEND:\n\t\t\t\tfputs( \"%%\\n\", err );\n\n\t\t\t\t/* We set beglin to be true so we'll start\n\t\t\t\t * writing out numbers as we echo rules.\n\t\t\t\t * flexscan() has already assigned sectnum.\n\t\t\t\t */\n\t\t\t\tif ( sectnum == 2 )\n\t\t\t\t\tbeglin = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase NAME:\n\t\t\t\tfprintf( err, \"'%s'\", nmstr );\n\t\t\t\tbreak;\n\n\t\t\tcase CHAR:\n\t\t\t\tswitch ( yylval )\n\t\t\t\t\t{\n\t\t\t\t\tcase '<':\n\t\t\t\t\tcase '>':\n\t\t\t\t\tcase '^':\n\t\t\t\t\tcase '$':\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\tcase '{':\n\t\t\t\t\tcase '}':\n\t\t\t\t\tcase '|':\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase '-':\n\t\t\t\t\tcase '/':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '?':\n\t\t\t\t\tcase '.':\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase ',':\n\t\t\t\t\t\tfprintf( err, \"\\\\%c\",\n\t\t\t\t\t\t\tyylval );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ( ! isascii( yylval ) ||\n\t\t\t\t\t\t     ! isprint( yylval ) )\n\t\t\t\t\t\t\tfprintf( err,\n\t\t\t\t\t\t\t\t\"\\\\%.3o\",\n\t\t\t\t\t\t\t(unsigned int) yylval );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t(void) putc( yylval,\n\t\t\t\t\t\t\t\terr );\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase NUMBER:\n\t\t\t\tfprintf( err, \"%d\", yylval );\n\t\t\t\tbreak;\n\n\t\t\tcase PREVCCL:\n\t\t\t\tfprintf( err, \"[%d]\", yylval );\n\t\t\t\tbreak;\n\n\t\t\tcase EOF_OP:\n\t\t\t\tfprintf( err, \"<<EOF>>\" );\n\t\t\t\tbreak;\n\n\t\t\tcase OPTION_OP:\n\t\t\t\tfprintf( err, \"%s \", yytext );\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_OUTFILE:\n\t\t\tcase OPT_PREFIX:\n\t\t\tcase CCE_ALNUM:\n\t\t\tcase CCE_ALPHA:\n\t\t\tcase CCE_BLANK:\n\t\t\tcase CCE_CNTRL:\n\t\t\tcase CCE_DIGIT:\n\t\t\tcase CCE_GRAPH:\n\t\t\tcase CCE_LOWER:\n\t\t\tcase CCE_PRINT:\n\t\t\tcase CCE_PUNCT:\n\t\t\tcase CCE_SPACE:\n\t\t\tcase CCE_UPPER:\n\t\t\tcase CCE_XDIGIT:\n\t\t\t\tfprintf( err, \"%s\", yytext );\n\t\t\t\tbreak;\n\n\t\t\tcase 0:\n\t\t\t\tfprintf( err, _( \"End Marker\\n\" ) );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfprintf( err,\n\t\t\t\t_( \"*Something Weird* - tok: %d val: %d\\n\" ),\n\t\t\t\t\ttoktype, yylval );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\treturn toktype;\n\t}\n\n/*  A Bison parser, made from ./parse.y\n    by GNU Bison version 1.28  */\n\n#define YYBISON 1  /* Identify Bison output.  */\n\n#define\tCHAR\t257\n#define\tNUMBER\t258\n#define\tSECTEND\t259\n#define\tSCDECL\t260\n#define\tXSCDECL\t261\n#define\tNAME\t262\n#define\tPREVCCL\t263\n#define\tEOF_OP\t264\n#define\tOPTION_OP\t265\n#define\tOPT_OUTFILE\t266\n#define\tOPT_PREFIX\t267\n#define\tOPT_YYCLASS\t268\n#define\tCCE_ALNUM\t269\n#define\tCCE_ALPHA\t270\n#define\tCCE_BLANK\t271\n#define\tCCE_CNTRL\t272\n#define\tCCE_DIGIT\t273\n#define\tCCE_GRAPH\t274\n#define\tCCE_LOWER\t275\n#define\tCCE_PRINT\t276\n#define\tCCE_PUNCT\t277\n#define\tCCE_SPACE\t278\n#define\tCCE_UPPER\t279\n#define\tCCE_XDIGIT\t280\n\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n/* Some versions of bison are broken in that they use alloca() but don't\n * declare it properly.  The following is the patented (just kidding!)\n * #ifdef chud to fix the problem, courtesy of Francois Pinard.\n */\n#ifdef YYBISON\n/* AIX requires this to be the first thing in the file.  What a piece.  */\n# ifdef _AIX\n #pragma alloca\n# endif\n#endif\n\n\n/* The remainder of the alloca() cruft has to come after including flexdef.h,\n * so HAVE_ALLOCA_H is (possibly) defined.\n */\n#ifdef YYBISON\n# ifdef __GNUC__\n#  ifndef alloca\n#   define alloca __builtin_alloca\n#  endif\n# else\n#  if HAVE_ALLOCA_H\n#   include <alloca.h>\n#  else\n#   ifdef __hpux\nvoid *alloca ();\n#   else\n#    ifdef __TURBOC__\n#     include <malloc.h>\n#    else\nchar *alloca ();\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n\n/* Bletch, ^^^^ that was ugly! */\n\n\nint pat, scnum, eps, headcnt, trailcnt, anyccl, lastchar, i, rulelen;\nint trlcontxt, xcluflg, currccl, cclsorted, varlength, variable_trail_rule;\n\nint *scon_stk;\nint scon_stk_ptr;\n\nstatic int madeany = false;  /* whether we've made the '.' character class */\nint previous_continued_action;\t/* whether the previous rule's action was '|' */\n\n/* Expand a POSIX character class expression. */\n#define CCL_EXPR(func) \\\n\t{ \\\n\tint c; \\\n\tfor ( c = 0; c < csize; ++c ) \\\n\t\tif ( isascii(c) && func(c) ) \\\n\t\t\tccladd( currccl, c ); \\\n\t}\n\n/* While POSIX defines isblank(), it's not ANSI C. */\n#define IS_BLANK(c) ((c) == ' ' || (c) == '\\t')\n\n/* On some over-ambitious machines, such as DEC Alpha's, the default\n * token type is \"long\" instead of \"int\"; this leads to problems with\n * declaring yylval in flexdef.h.  But so far, all the yacc's I've seen\n * wrap their definitions of YYSTYPE with \"#ifndef YYSTYPE\"'s, so the\n * following should ensure that the default token type is \"int\".\n */\n#define YYSTYPE int\n\n#ifndef YYSTYPE\n#define YYSTYPE int\n#endif\n#include <stdio.h>\n\n#ifndef __cplusplus\n#ifndef __STDC__\n#define const\n#endif\n#endif\n\n\n\n#define\tYYFINAL\t\t107\n#define\tYYFLAG\t\t-32768\n#define\tYYNTBASE\t48\n\n#define YYTRANSLATE(x) ((unsigned)(x) <= 280 ? yytranslate[x] : 73)\n\nstatic const char yytranslate[] = {     0,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,    28,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,    42,     2,    36,     2,     2,     2,    43,\n    44,    34,    39,    35,    47,    41,    38,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,    32,\n    27,    33,    40,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n    45,     2,    46,    31,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,    29,    37,    30,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,\n     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,\n    17,    18,    19,    20,    21,    22,    23,    24,    25,    26\n};\n\n#if YYDEBUG != 0\nstatic const short yyprhs[] = {     0,\n     0,     6,     7,    11,    14,    15,    17,    19,    21,    23,\n    26,    28,    30,    33,    36,    37,    41,    45,    49,    55,\n    61,    62,    63,    66,    68,    70,    72,    73,    78,    82,\n    83,    87,    89,    91,    93,    96,   100,   103,   105,   109,\n   111,   114,   117,   119,   122,   125,   128,   135,   141,   146,\n   148,   150,   152,   156,   160,   162,   166,   171,   176,   179,\n   182,   183,   185,   187,   189,   191,   193,   195,   197,   199,\n   201,   203,   205,   207,   210\n};\n\nstatic const short yyrhs[] = {    49,\n    50,    51,    57,    58,     0,     0,    50,    52,    53,     0,\n    50,    54,     0,     0,     1,     0,     5,     0,     6,     0,\n     7,     0,    53,     8,     0,     8,     0,     1,     0,    11,\n    55,     0,    55,    56,     0,     0,    12,    27,     8,     0,\n    13,    27,     8,     0,    14,    27,     8,     0,    57,    61,\n    58,    59,    28,     0,    57,    61,    29,    57,    30,     0,\n     0,     0,    31,    64,     0,    64,     0,    10,     0,     1,\n     0,     0,    32,    60,    62,    33,     0,    32,    34,    33,\n     0,     0,    62,    35,    63,     0,    63,     0,     1,     0,\n     8,     0,    66,    65,     0,    66,    65,    36,     0,    65,\n    36,     0,    65,     0,    65,    37,    67,     0,    67,     0,\n    65,    38,     0,    67,    68,     0,    68,     0,    68,    34,\n     0,    68,    39,     0,    68,    40,     0,    68,    29,     4,\n    35,     4,    30,     0,    68,    29,     4,    35,    30,     0,\n    68,    29,     4,    30,     0,    41,     0,    69,     0,     9,\n     0,    42,    72,    42,     0,    43,    65,    44,     0,     3,\n     0,    45,    70,    46,     0,    45,    31,    70,    46,     0,\n    70,     3,    47,     3,     0,    70,     3,     0,    70,    71,\n     0,     0,    15,     0,    16,     0,    17,     0,    18,     0,\n    19,     0,    20,     0,    21,     0,    22,     0,    23,     0,\n    24,     0,    25,     0,    26,     0,    72,     3,     0,     0\n};\n\n#endif\n\n#if YYDEBUG != 0\nstatic const short yyrline[] = { 0,\n   112,   141,   149,   150,   151,   152,   156,   164,   167,   171,\n   174,   177,   181,   184,   185,   188,   193,   195,   199,   201,\n   203,   206,   219,   255,   279,   302,   306,   310,   313,   330,\n   334,   336,   338,   342,   365,   420,   423,   466,   484,   490,\n   495,   522,   530,   534,   541,   547,   553,   581,   595,   614,\n   636,   654,   661,   664,   667,   678,   681,   688,   716,   727,\n   734,   742,   743,   744,   745,   746,   747,   748,   749,   750,\n   751,   752,   758,   761,   771\n};\n#endif\n\n\n#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)\n\nstatic const char * const yytname[] = {   \"$\",\"error\",\"$undefined.\",\"CHAR\",\"NUMBER\",\n\"SECTEND\",\"SCDECL\",\"XSCDECL\",\"NAME\",\"PREVCCL\",\"EOF_OP\",\"OPTION_OP\",\"OPT_OUTFILE\",\n\"OPT_PREFIX\",\"OPT_YYCLASS\",\"CCE_ALNUM\",\"CCE_ALPHA\",\"CCE_BLANK\",\"CCE_CNTRL\",\"CCE_DIGIT\",\n\"CCE_GRAPH\",\"CCE_LOWER\",\"CCE_PRINT\",\"CCE_PUNCT\",\"CCE_SPACE\",\"CCE_UPPER\",\"CCE_XDIGIT\",\n\"'='\",\"'\\\\n'\",\"'{'\",\"'}'\",\"'^'\",\"'<'\",\"'>'\",\"'*'\",\"','\",\"'$'\",\"'|'\",\"'/'\",\"'+'\",\n\"'?'\",\"'.'\",\"'\\\\\\\"'\",\"'('\",\"')'\",\"'['\",\"']'\",\"'-'\",\"goal\",\"initlex\",\"sect1\",\n\"sect1end\",\"startconddecl\",\"namelist1\",\"options\",\"optionlist\",\"option\",\"sect2\",\n\"initforrule\",\"flexrule\",\"scon_stk_ptr\",\"scon\",\"namelist2\",\"sconname\",\"rule\",\n\"re\",\"re2\",\"series\",\"singleton\",\"fullccl\",\"ccl\",\"ccl_expr\",\"string\", NULL\n};\n#endif\n\nstatic const short yyr1[] = {     0,\n    48,    49,    50,    50,    50,    50,    51,    52,    52,    53,\n    53,    53,    54,    55,    55,    56,    56,    56,    57,    57,\n    57,    58,    59,    59,    59,    59,    60,    61,    61,    61,\n    62,    62,    62,    63,    64,    64,    64,    64,    65,    65,\n    66,    67,    67,    68,    68,    68,    68,    68,    68,    68,\n    68,    68,    68,    68,    68,    69,    69,    70,    70,    70,\n    70,    71,    71,    71,    71,    71,    71,    71,    71,    71,\n    71,    71,    71,    72,    72\n};\n\nstatic const short yyr2[] = {     0,\n     5,     0,     3,     2,     0,     1,     1,     1,     1,     2,\n     1,     1,     2,     2,     0,     3,     3,     3,     5,     5,\n     0,     0,     2,     1,     1,     1,     0,     4,     3,     0,\n     3,     1,     1,     1,     2,     3,     2,     1,     3,     1,\n     2,     2,     1,     2,     2,     2,     6,     5,     4,     1,\n     1,     1,     3,     3,     1,     3,     4,     4,     2,     2,\n     0,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n     1,     1,     1,     2,     0\n};\n\nstatic const short yydefact[] = {     2,\n     0,     6,     0,     7,     8,     9,    15,    21,     0,     4,\n    13,    30,    12,    11,     3,     0,     0,     0,    14,    27,\n     1,    22,    10,     0,     0,     0,     0,     0,    21,     0,\n    16,    17,    18,    29,    33,    34,     0,    32,    30,    26,\n    55,    52,    25,     0,    50,    75,     0,    61,     0,    24,\n    38,     0,    40,    43,    51,    28,     0,    20,    23,     0,\n     0,    61,     0,    19,    37,     0,    41,    35,    42,     0,\n    44,    45,    46,    31,    74,    53,    54,     0,    59,    62,\n    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,\n    73,    56,    60,    39,    36,     0,    57,     0,    49,     0,\n    58,     0,    48,    47,     0,     0,     0\n};\n\nstatic const short yydefgoto[] = {   105,\n     1,     3,     8,     9,    15,    10,    11,    19,    12,    21,\n    49,    28,    22,    37,    38,    50,    51,    52,    53,    54,\n    55,    63,    93,    60\n};\n\nstatic const short yypact[] = {-32768,\n    78,-32768,    81,-32768,-32768,-32768,-32768,-32768,     6,-32768,\n    -2,     5,-32768,-32768,    -7,   -14,     1,     9,-32768,    28,\n-32768,    14,-32768,    55,    65,    74,    57,    30,-32768,    -1,\n-32768,-32768,-32768,-32768,-32768,-32768,    58,-32768,    44,-32768,\n-32768,-32768,-32768,    24,-32768,-32768,    24,    63,    69,-32768,\n    23,    24,    24,    41,-32768,-32768,    90,-32768,-32768,    26,\n    27,-32768,     0,-32768,-32768,    24,-32768,    59,    41,    95,\n-32768,-32768,-32768,-32768,-32768,-32768,-32768,    32,    53,-32768,\n-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,\n-32768,-32768,-32768,    24,-32768,     4,-32768,    98,-32768,     2,\n-32768,    72,-32768,-32768,   103,   104,-32768\n};\n\nstatic const short yypgoto[] = {-32768,\n-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    76,    84,\n-32768,-32768,-32768,-32768,    50,    64,    25,-32768,    43,   -49,\n-32768,    48,-32768,-32768\n};\n\n\n#define\tYYLAST\t\t110\n\n\nstatic const short yytable[] = {    40,\n    23,    41,    79,    69,   -22,   102,    13,    42,    43,    16,\n    17,    18,    24,    14,    80,    81,    82,    83,    84,    85,\n    86,    87,    88,    89,    90,    91,    41,    25,    75,    44,\n    35,   103,    42,    99,    79,    26,    20,    36,   100,    45,\n    46,    47,    29,    48,    69,    92,    80,    81,    82,    83,\n    84,    85,    86,    87,    88,    89,    90,    91,    65,    66,\n    67,    27,    31,    66,    45,    46,    47,    76,    48,    70,\n    77,    61,    32,    58,    71,    20,    68,    97,     2,    72,\n    73,    33,    -5,    -5,    -5,     4,     5,     6,    -5,    34,\n    56,     7,    57,    62,    95,    66,    64,    36,    96,    98,\n   101,   104,   106,   107,    39,    30,    74,    59,    94,    78\n};\n\nstatic const short yycheck[] = {     1,\n     8,     3,     3,    53,     0,     4,     1,     9,    10,    12,\n    13,    14,    27,     8,    15,    16,    17,    18,    19,    20,\n    21,    22,    23,    24,    25,    26,     3,    27,     3,    31,\n     1,    30,     9,    30,     3,    27,    32,     8,    35,    41,\n    42,    43,    29,    45,    94,    46,    15,    16,    17,    18,\n    19,    20,    21,    22,    23,    24,    25,    26,    36,    37,\n    38,    34,     8,    37,    41,    42,    43,    42,    45,    29,\n    44,    47,     8,    30,    34,    32,    52,    46,     1,    39,\n    40,     8,     5,     6,     7,     5,     6,     7,    11,    33,\n    33,    11,    35,    31,    36,    37,    28,     8,     4,    47,\n     3,    30,     0,     0,    29,    22,    57,    44,    66,    62\n};\n/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n/* This file comes from bison-1.28.  */\n\n/* Skeleton output parser for bison,\n   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* As a special exception, when this file is copied by Bison into a\n   Bison output file, you may use that output file without restriction.\n   This special exception was added by the Free Software Foundation\n   in version 1.24 of Bison.  */\n\n/* This is the parser code that is written into each bison parser\n  when the %semantic_parser declaration is not specified in the grammar.\n  It was written by Richard Stallman by simplifying the hairy parser\n  used when %semantic_parser is specified.  */\n\n#ifndef YYSTACK_USE_ALLOCA\n#ifdef alloca\n#define YYSTACK_USE_ALLOCA\n#else /* alloca not defined */\n#ifdef __GNUC__\n#define YYSTACK_USE_ALLOCA\n#define alloca __builtin_alloca\n#else /* not GNU C.  */\n#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))\n#define YYSTACK_USE_ALLOCA\n#include <alloca.h>\n#else /* not sparc */\n/* We think this test detects Watcom and Microsoft C.  */\n/* This used to test MSDOS, but that is a bad idea\n   since that symbol is in the user namespace.  */\n#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)\n#if 0 /* No need for malloc.h, which pollutes the namespace;\n\t instead, just don't use alloca.  */\n#include <malloc.h>\n#endif\n#else /* not MSDOS, or __TURBOC__ */\n#if defined(_AIX)\n/* I don't know what this was needed for, but it pollutes the namespace.\n   So I turned it off.   rms, 2 May 1997.  */\n/* #include <malloc.h>  */\n #pragma alloca\n#define YYSTACK_USE_ALLOCA\n#else /* not MSDOS, or __TURBOC__, or _AIX */\n#if 0\n#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,\n\t\t and on HPUX 10.  Eventually we can turn this on.  */\n#define YYSTACK_USE_ALLOCA\n#define alloca __builtin_alloca\n#endif /* __hpux */\n#endif\n#endif /* not _AIX */\n#endif /* not MSDOS, or __TURBOC__ */\n#endif /* not sparc */\n#endif /* not GNU C */\n#endif /* alloca not defined */\n#endif /* YYSTACK_USE_ALLOCA not defined */\n\n#ifdef YYSTACK_USE_ALLOCA\n#define YYSTACK_ALLOC alloca\n#else\n#define YYSTACK_ALLOC malloc\n#endif\n\n/* Note: there must be only one dollar sign in this file.\n   It is replaced by the list of actions, each action\n   as one case of the switch.  */\n\n#define yyerrok\t\t(yyerrstatus = 0)\n#define yyclearin\t(yychar = YYEMPTY)\n#define YYEMPTY\t\t-2\n#define YYEOF\t\t0\n#define YYACCEPT\tgoto yyacceptlab\n#define YYABORT \tgoto yyabortlab\n#define YYERROR\t\tgoto yyerrlab1\n/* Like YYERROR except do call yyerror.\n   This remains here temporarily to ease the\n   transition to the new meaning of YYERROR, for GCC.\n   Once GCC version 2 has supplanted version 1, this can go.  */\n#define YYFAIL\t\tgoto yyerrlab\n#define YYRECOVERING()  (!!yyerrstatus)\n#define YYBACKUP(token, value) \\\ndo\t\t\t\t\t\t\t\t\\\n  if (yychar == YYEMPTY && yylen == 1)\t\t\t\t\\\n    { yychar = (token), yylval = (value);\t\t\t\\\n      yychar1 = YYTRANSLATE (yychar);\t\t\t\t\\\n      YYPOPSTACK;\t\t\t\t\t\t\\\n      goto yybackup;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\\\n    { yyerror (\"syntax error: cannot back up\"); YYERROR; }\t\\\nwhile (0)\n\n#define YYTERROR\t1\n#define YYERRCODE\t256\n\n#ifndef YYPURE\n#define YYLEX\t\tyylex()\n#endif\n\n#ifdef YYPURE\n#ifdef YYLSP_NEEDED\n#ifdef YYLEX_PARAM\n#define YYLEX\t\tyylex(&yylval, &yylloc, YYLEX_PARAM)\n#else\n#define YYLEX\t\tyylex(&yylval, &yylloc)\n#endif\n#else /* not YYLSP_NEEDED */\n#ifdef YYLEX_PARAM\n#define YYLEX\t\tyylex(&yylval, YYLEX_PARAM)\n#else\n#define YYLEX\t\tyylex(&yylval)\n#endif\n#endif /* not YYLSP_NEEDED */\n#endif\n\n/* If nonreentrant, generate the variables here */\n\n#ifndef YYPURE\n\nint\tyychar;\t\t\t/*  the lookahead symbol\t\t*/\nYYSTYPE\tyylval;\t\t\t/*  the semantic value of the\t\t*/\n\t\t\t\t/*  lookahead symbol\t\t\t*/\n\n#ifdef YYLSP_NEEDED\nYYLTYPE yylloc;\t\t\t/*  location data for the lookahead\t*/\n\t\t\t\t/*  symbol\t\t\t\t*/\n#endif\n\nint yynerrs;\t\t\t/*  number of parse errors so far       */\n#endif  /* not YYPURE */\n\n#if YYDEBUG != 0\nint yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n/* Since this is uninitialized, it does not stop multiple parsers\n   from coexisting.  */\n#endif\n\n/*  YYINITDEPTH indicates the initial size of the parser's stacks\t*/\n\n#ifndef\tYYINITDEPTH\n#define YYINITDEPTH 200\n#endif\n\n/*  YYMAXDEPTH is the maximum size the stacks can grow to\n    (effective only if the built-in stack extension method is used).  */\n\n#if YYMAXDEPTH == 0\n#undef YYMAXDEPTH\n#endif\n\n#ifndef YYMAXDEPTH\n#define YYMAXDEPTH 10000\n#endif\n/* Define __yy_memcpy.  Note that the size argument\n   should be passed with type unsigned int, because that is what the non-GCC\n   definitions require.  With GCC, __builtin_memcpy takes an arg\n   of type size_t, but it can handle unsigned int.  */\n\n#if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n#define __yy_memcpy(TO,FROM,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n#else\t\t\t\t/* not GNU C or C++ */\n#ifndef __cplusplus\n\n/* This is the most reliable way to avoid incompatibilities\n   in available built-in functions on various systems.  */\nstatic void\n__yy_memcpy (to, from, count)\n     char *to;\n     char *from;\n     unsigned int count;\n{\n  register char *f = from;\n  register char *t = to;\n  register int i = count;\n\n  while (i-- > 0)\n    *t++ = *f++;\n}\n\n#else /* __cplusplus */\n\n/* This is the most reliable way to avoid incompatibilities\n   in available built-in functions on various systems.  */\nstatic void\n__yy_memcpy (char *to, char *from, unsigned int count)\n{\n  register char *t = to;\n  register char *f = from;\n  register int i = count;\n\n  while (i-- > 0)\n    *t++ = *f++;\n}\n\n#endif\n#endif\n\n/* The user can define YYPARSE_PARAM as the name of an argument to be passed\n   into yyparse.  The argument should have type void *.\n   It should actually point to an object.\n   Grammar actions can access the variable by casting it\n   to the proper pointer type.  */\n\n#ifdef YYPARSE_PARAM\n#ifdef __cplusplus\n#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM\n#define YYPARSE_PARAM_DECL\n#else /* not __cplusplus */\n#define YYPARSE_PARAM_ARG YYPARSE_PARAM\n#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;\n#endif /* not __cplusplus */\n#else /* not YYPARSE_PARAM */\n#define YYPARSE_PARAM_ARG\n#define YYPARSE_PARAM_DECL\n#endif /* not YYPARSE_PARAM */\n\n/* Prevent warning if -Wstrict-prototypes.  */\n#ifdef __GNUC__\n#ifdef YYPARSE_PARAM\nint yyparse (void *);\n#else\nint yyparse (void);\n#endif\n#endif\n\nint\nyyparse(YYPARSE_PARAM_ARG)\n     YYPARSE_PARAM_DECL\n{\n  register int yystate;\n  register int yyn;\n  register short *yyssp;\n  register YYSTYPE *yyvsp;\n  int yyerrstatus;\t/*  number of tokens to shift before error messages enabled */\n  int yychar1 = 0;\t\t/*  lookahead token as an internal (translated) token number */\n\n  short\tyyssa[YYINITDEPTH];\t/*  the state stack\t\t\t*/\n  YYSTYPE yyvsa[YYINITDEPTH];\t/*  the semantic value stack\t\t*/\n\n  short *yyss = yyssa;\t\t/*  refer to the stacks thru separate pointers */\n  YYSTYPE *yyvs = yyvsa;\t/*  to allow yyoverflow to reallocate them elsewhere */\n\n#ifdef YYLSP_NEEDED\n  YYLTYPE yylsa[YYINITDEPTH];\t/*  the location stack\t\t\t*/\n  YYLTYPE *yyls = yylsa;\n  YYLTYPE *yylsp;\n\n#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)\n#else\n#define YYPOPSTACK   (yyvsp--, yyssp--)\n#endif\n\n  int yystacksize = YYINITDEPTH;\n  int yyfree_stacks = 0;\n\n#ifdef YYPURE\n  int yychar;\n  YYSTYPE yylval;\n  int yynerrs;\n#ifdef YYLSP_NEEDED\n  YYLTYPE yylloc;\n#endif\n#endif\n\n  YYSTYPE yyval;\t\t/*  the variable used to return\t\t*/\n\t\t\t\t/*  semantic values from the action\t*/\n\t\t\t\t/*  routines\t\t\t\t*/\n\n  int yylen;\n\n#if YYDEBUG != 0\n  if (yydebug)\n    fprintf(err, \"Starting parse\\n\");\n#endif\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY;\t\t/* Cause a token to be read.  */\n\n  /* Initialize stack pointers.\n     Waste one element of value and location stack\n     so that they stay on the same level as the state stack.\n     The wasted elements are never initialized.  */\n\n  yyssp = yyss - 1;\n  yyvsp = yyvs;\n#ifdef YYLSP_NEEDED\n  yylsp = yyls;\n#endif\n\n/* Push a new state, which is found in  yystate  .  */\n/* In all cases, when you get here, the value and location stacks\n   have just been pushed. so pushing a state here evens the stacks.  */\nyynewstate:\n\n  *++yyssp = yystate;\n\n  if (yyssp >= yyss + yystacksize - 1)\n    {\n      /* Give user a chance to reallocate the stack */\n      /* Use copies of these so that the &'s don't force the real ones into memory. */\n      YYSTYPE *yyvs1 = yyvs;\n      short *yyss1 = yyss;\n#ifdef YYLSP_NEEDED\n      YYLTYPE *yyls1 = yyls;\n#endif\n\n      /* Get the current used size of the three stacks, in elements.  */\n      int size = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      /* Each stack pointer address is followed by the size of\n\t the data in use in that stack, in bytes.  */\n#ifdef YYLSP_NEEDED\n      /* This used to be a conditional around just the two extra args,\n\t but that might be undefined if yyoverflow is a macro.  */\n      yyoverflow(\"parser stack overflow\",\n\t\t &yyss1, size * sizeof (*yyssp),\n\t\t &yyvs1, size * sizeof (*yyvsp),\n\t\t &yyls1, size * sizeof (*yylsp),\n\t\t &yystacksize);\n#else\n      yyoverflow(\"parser stack overflow\",\n\t\t &yyss1, size * sizeof (*yyssp),\n\t\t &yyvs1, size * sizeof (*yyvsp),\n\t\t &yystacksize);\n#endif\n\n      yyss = yyss1; yyvs = yyvs1;\n#ifdef YYLSP_NEEDED\n      yyls = yyls1;\n#endif\n#else /* no yyoverflow */\n      /* Extend the stack our own way.  */\n      if (yystacksize >= YYMAXDEPTH)\n\t{\n\t  yyerror(\"parser stack overflow\");\n\t  if (yyfree_stacks)\n\t    {\n\t      free (yyss);\n\t      free (yyvs);\n#ifdef YYLSP_NEEDED\n\t      free (yyls);\n#endif\n\t    }\n\t  return 2;\n\t}\n      yystacksize *= 2;\n      if (yystacksize > YYMAXDEPTH)\n\tyystacksize = YYMAXDEPTH;\n#ifndef YYSTACK_USE_ALLOCA\n      yyfree_stacks = 1;\n#endif\n      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));\n      __yy_memcpy ((char *)yyss, (char *)yyss1,\n\t\t   size * (unsigned int) sizeof (*yyssp));\n      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));\n      __yy_memcpy ((char *)yyvs, (char *)yyvs1,\n\t\t   size * (unsigned int) sizeof (*yyvsp));\n#ifdef YYLSP_NEEDED\n      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));\n      __yy_memcpy ((char *)yyls, (char *)yyls1,\n\t\t   size * (unsigned int) sizeof (*yylsp));\n#endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + size - 1;\n      yyvsp = yyvs + size - 1;\n#ifdef YYLSP_NEEDED\n      yylsp = yyls + size - 1;\n#endif\n\n#if YYDEBUG != 0\n      if (yydebug)\n\tfprintf(err, \"Stack size increased to %d\\n\", yystacksize);\n#endif\n\n      if (yyssp >= yyss + yystacksize - 1)\n\tYYABORT;\n    }\n\n#if YYDEBUG != 0\n  if (yydebug)\n    fprintf(err, \"Entering state %d\\n\", yystate);\n#endif\n\n  goto yybackup;\n yybackup:\n\n/* Do appropriate processing given the current state.  */\n/* Read a lookahead token if we need one and don't already have one.  */\n/* yyresume: */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n\n  yyn = yypact[yystate];\n  if (yyn == YYFLAG)\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* yychar is either YYEMPTY or YYEOF\n     or a valid token in external form.  */\n\n  if (yychar == YYEMPTY)\n    {\n#if YYDEBUG != 0\n      if (yydebug)\n\tfprintf(err, \"Reading a token: \");\n#endif\n      yychar = YYLEX;\n    }\n\n  /* Convert token to internal form (in yychar1) for indexing tables with */\n\n  if (yychar <= 0)\t\t/* This means end of input. */\n    {\n      yychar1 = 0;\n      yychar = YYEOF;\t\t/* Don't call YYLEX any more */\n\n#if YYDEBUG != 0\n      if (yydebug)\n\tfprintf(err, \"Now at end of input.\\n\");\n#endif\n    }\n  else\n    {\n      yychar1 = YYTRANSLATE(yychar);\n\n#if YYDEBUG != 0\n      if (yydebug)\n\t{\n\t  fprintf (err, \"Next token is %d (%s\", yychar, yytname[yychar1]);\n\t  /* Give the individual parser a way to print the precise meaning\n\t     of a token, for further debugging info.  */\n#ifdef YYPRINT\n\t  YYPRINT (err, yychar, yylval);\n#endif\n\t  fprintf (err, \")\\n\");\n\t}\n#endif\n    }\n\n  yyn += yychar1;\n  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)\n    goto yydefault;\n\n  yyn = yytable[yyn];\n\n  /* yyn is what to do for this token type in this state.\n     Negative => reduce, -yyn is rule number.\n     Positive => shift, yyn is new state.\n       New state is final state => don't bother to shift,\n       just return success.\n     0, or most negative number => error.  */\n\n  if (yyn < 0)\n    {\n      if (yyn == YYFLAG)\n\tgoto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n  else if (yyn == 0)\n    goto yyerrlab;\n\n  if (yyn == YYFINAL)\n    YYACCEPT;\n\n  /* Shift the lookahead token.  */\n\n#if YYDEBUG != 0\n  if (yydebug)\n    fprintf(err, \"Shifting token %d (%s), \", yychar, yytname[yychar1]);\n#endif\n\n  /* Discard the token being shifted unless it is eof.  */\n  if (yychar != YYEOF)\n    yychar = YYEMPTY;\n\n  *++yyvsp = yylval;\n#ifdef YYLSP_NEEDED\n  *++yylsp = yylloc;\n#endif\n\n  /* count tokens shifted since error; after three, turn off error status.  */\n  if (yyerrstatus) yyerrstatus--;\n\n  yystate = yyn;\n  goto yynewstate;\n\n/* Do the default action for the current state.  */\nyydefault:\n\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n\n/* Do a reduction.  yyn is the number of a rule to reduce with.  */\nyyreduce:\n  yylen = yyr2[yyn];\n  if (yylen > 0)\n    yyval = yyvsp[1-yylen]; /* implement default value of the action */\n\n#if YYDEBUG != 0\n  if (yydebug)\n    {\n      int i;\n\n      fprintf (err, \"Reducing via rule %d (line %d), \",\n\t       yyn, yyrline[yyn]);\n\n      /* Print the symbols being reduced, and their result.  */\n      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)\n\tfprintf (err, \"%s \", yytname[yyrhs[i]]);\n      fprintf (err, \" -> %s\\n\", yytname[yyr1[yyn]]);\n    }\n#endif\n\n\n  switch (yyn) {\n\ncase 1:\n{ /* add default rule */\n\t\t\tint def_rule;\n\n\t\t\tpat = cclinit();\n\t\t\tcclnegate( pat );\n\n\t\t\tdef_rule = mkstate( -pat );\n\n\t\t\t/* Remember the number of the default rule so we\n\t\t\t * don't generate \"can't match\" warnings for it.\n\t\t\t */\n\t\t\tdefault_rule = num_rules;\n\n\t\t\tfinish_rule( def_rule, false, 0, 0 );\n\n\t\t\tfor ( i = 1; i <= lastsc; ++i )\n\t\t\t\tscset[i] = mkbranch( scset[i], def_rule );\n\n\t\t\tif ( spprdflt )\n\t\t\t\tadd_action(\n\t\t\t\t\"YY_FATAL_ERROR( \\\"flex scanner jammed\\\" )\" );\n\t\t\telse\n\t\t\t\tadd_action( \"ECHO\" );\n\n\t\t\tadd_action( \";\\n\\tYY_BREAK\\n\" );\n\t\t\t;\n    break;}\ncase 2:\n{ /* initialize for processing rules */\n\n\t\t\t/* Create default DFA start condition. */\n\t\t\tscinstal( \"INITIAL\", false );\n\t\t\t;\n    break;}\ncase 6:\n{ synerr( \"unknown error processing section 1\" ); ;\n    break;}\ncase 7:\n{\n\t\t\tcheck_options();\n\t\t\tscon_stk = allocate_integer_array( lastsc + 1 );\n\t\t\tscon_stk_ptr = 0;\n\t\t\t;\n    break;}\ncase 8:\n{ xcluflg = false; ;\n    break;}\ncase 9:\n{ xcluflg = true; ;\n    break;}\ncase 10:\n{ scinstal( nmstr, xcluflg ); ;\n    break;}\ncase 11:\n{ scinstal( nmstr, xcluflg ); ;\n    break;}\ncase 12:\n{ synerr( \"bad start condition list\" ); ;\n    break;}\ncase 16:\n{\n\t\t\toutfilename = copy_string( nmstr );\n\t\t\tdid_outfilename = 1;\n\t\t\t;\n    break;}\ncase 17:\n{ prefix = copy_string( nmstr ); ;\n    break;}\ncase 18:\n{ yyclass = copy_string( nmstr ); ;\n    break;}\ncase 19:\n{ scon_stk_ptr = yyvsp[-3]; ;\n    break;}\ncase 20:\n{ scon_stk_ptr = yyvsp[-3]; ;\n    break;}\ncase 22:\n{\n\t\t\t/* Initialize for a parse of one rule. */\n\t\t\ttrlcontxt = variable_trail_rule = varlength = false;\n\t\t\ttrailcnt = headcnt = rulelen = 0;\n\t\t\tcurrent_state_type = STATE_NORMAL;\n\t\t\tprevious_continued_action = continued_action;\n\t\t\tin_rule = true;\n\n\t\t\tnew_rule();\n\t\t\t;\n    break;}\ncase 23:\n{\n\t\t\tpat = yyvsp[0];\n\t\t\tfinish_rule( pat, variable_trail_rule,\n\t\t\t\theadcnt, trailcnt );\n\n\t\t\tif ( scon_stk_ptr > 0 )\n\t\t\t\t{\n\t\t\t\tfor ( i = 1; i <= scon_stk_ptr; ++i )\n\t\t\t\t\tscbol[scon_stk[i]] =\n\t\t\t\t\t\tmkbranch( scbol[scon_stk[i]],\n\t\t\t\t\t\t\t\tpat );\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* Add to all non-exclusive start conditions,\n\t\t\t\t * including the default (0) start condition.\n\t\t\t\t */\n\n\t\t\t\tfor ( i = 1; i <= lastsc; ++i )\n\t\t\t\t\tif ( ! scxclu[i] )\n\t\t\t\t\t\tscbol[i] = mkbranch( scbol[i],\n\t\t\t\t\t\t\t\t\tpat );\n\t\t\t\t}\n\n\t\t\tif ( ! bol_needed )\n\t\t\t\t{\n\t\t\t\tbol_needed = true;\n\n\t\t\t\tif ( performance_report > 1 )\n\t\t\t\t\tpinpoint_message(\n\t\t\t\"'^' operator results in sub-optimal performance\" );\n\t\t\t\t}\n\t\t\t;\n    break;}\ncase 24:\n{\n\t\t\tpat = yyvsp[0];\n\t\t\tfinish_rule( pat, variable_trail_rule,\n\t\t\t\theadcnt, trailcnt );\n\n\t\t\tif ( scon_stk_ptr > 0 )\n\t\t\t\t{\n\t\t\t\tfor ( i = 1; i <= scon_stk_ptr; ++i )\n\t\t\t\t\tscset[scon_stk[i]] =\n\t\t\t\t\t\tmkbranch( scset[scon_stk[i]],\n\t\t\t\t\t\t\t\tpat );\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfor ( i = 1; i <= lastsc; ++i )\n\t\t\t\t\tif ( ! scxclu[i] )\n\t\t\t\t\t\tscset[i] =\n\t\t\t\t\t\t\tmkbranch( scset[i],\n\t\t\t\t\t\t\t\tpat );\n\t\t\t\t}\n\t\t\t;\n    break;}\ncase 25:\n{\n\t\t\tif ( scon_stk_ptr > 0 )\n\t\t\t\tbuild_eof_action();\n\t\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* This EOF applies to all start conditions\n\t\t\t\t * which don't already have EOF actions.\n\t\t\t\t */\n\t\t\t\tfor ( i = 1; i <= lastsc; ++i )\n\t\t\t\t\tif ( ! sceof[i] )\n\t\t\t\t\t\tscon_stk[++scon_stk_ptr] = i;\n\n\t\t\t\tif ( scon_stk_ptr == 0 )\n\t\t\t\t\twarn(\n\t\t\t\"all start conditions already have <<EOF>> rules\" );\n\n\t\t\t\telse\n\t\t\t\t\tbuild_eof_action();\n\t\t\t\t}\n\t\t\t;\n    break;}\ncase 26:\n{ synerr( \"unrecognized rule\" ); ;\n    break;}\ncase 27:\n{ yyval = scon_stk_ptr; ;\n    break;}\ncase 28:\n{ yyval = yyvsp[-2]; ;\n    break;}\ncase 29:\n{\n\t\t\tyyval = scon_stk_ptr;\n\n\t\t\tfor ( i = 1; i <= lastsc; ++i )\n\t\t\t\t{\n\t\t\t\tint j;\n\n\t\t\t\tfor ( j = 1; j <= scon_stk_ptr; ++j )\n\t\t\t\t\tif ( scon_stk[j] == i )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif ( j > scon_stk_ptr )\n\t\t\t\t\tscon_stk[++scon_stk_ptr] = i;\n\t\t\t\t}\n\t\t\t;\n    break;}\ncase 30:\n{ yyval = scon_stk_ptr; ;\n    break;}\ncase 33:\n{ synerr( \"bad start condition list\" ); ;\n    break;}\ncase 34:\n{\n\t\t\tif ( (scnum = sclookup( nmstr )) == 0 )\n\t\t\t\tformat_pinpoint_message(\n\t\t\t\t\t\"undeclared start condition %s\",\n\t\t\t\t\tnmstr );\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfor ( i = 1; i <= scon_stk_ptr; ++i )\n\t\t\t\t\tif ( scon_stk[i] == scnum )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tformat_warn(\n\t\t\t\t\t\t\t\"<%s> specified twice\",\n\t\t\t\t\t\t\tscname[scnum] );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\tif ( i > scon_stk_ptr )\n\t\t\t\t\tscon_stk[++scon_stk_ptr] = scnum;\n\t\t\t\t}\n\t\t\t;\n    break;}\ncase 35:\n{\n\t\t\tif ( transchar[lastst[yyvsp[0]]] != SYM_EPSILON )\n\t\t\t\t/* Provide final transition \\now/ so it\n\t\t\t\t * will be marked as a trailing context\n\t\t\t\t * state.\n\t\t\t\t */\n\t\t\t\tyyvsp[0] = link_machines( yyvsp[0],\n\t\t\t\t\t\tmkstate( SYM_EPSILON ) );\n\n\t\t\tmark_beginning_as_normal( yyvsp[0] );\n\t\t\tcurrent_state_type = STATE_NORMAL;\n\n\t\t\tif ( previous_continued_action )\n\t\t\t\t{\n\t\t\t\t/* We need to treat this as variable trailing\n\t\t\t\t * context so that the backup does not happen\n\t\t\t\t * in the action but before the action switch\n\t\t\t\t * statement.  If the backup happens in the\n\t\t\t\t * action, then the rules \"falling into\" this\n\t\t\t\t * one's action will *also* do the backup,\n\t\t\t\t * erroneously.\n\t\t\t\t */\n\t\t\t\tif ( ! varlength || headcnt != 0 )\n\t\t\t\t\twarn(\n\t\t\"trailing context made variable due to preceding '|' action\" );\n\n\t\t\t\t/* Mark as variable. */\n\t\t\t\tvarlength = true;\n\t\t\t\theadcnt = 0;\n\t\t\t\t}\n\n\t\t\tif ( lex_compat || (varlength && headcnt == 0) )\n\t\t\t\t{ /* variable trailing context rule */\n\t\t\t\t/* Mark the first part of the rule as the\n\t\t\t\t * accepting \"head\" part of a trailing\n\t\t\t\t * context rule.\n\t\t\t\t *\n\t\t\t\t * By the way, we didn't do this at the\n\t\t\t\t * beginning of this production because back\n\t\t\t\t * then current_state_type was set up for a\n\t\t\t\t * trail rule, and add_accept() can create\n\t\t\t\t * a new state ...\n\t\t\t\t */\n\t\t\t\tadd_accept( yyvsp[-1],\n\t\t\t\t\tnum_rules | YY_TRAILING_HEAD_MASK );\n\t\t\t\tvariable_trail_rule = true;\n\t\t\t\t}\n\t\t\t\n\t\t\telse\n\t\t\t\ttrailcnt = rulelen;\n\n\t\t\tyyval = link_machines( yyvsp[-1], yyvsp[0] );\n\t\t\t;\n    break;}\ncase 36:\n{ synerr( \"trailing context used twice\" ); ;\n    break;}\ncase 37:\n{\n\t\t\theadcnt = 0;\n\t\t\ttrailcnt = 1;\n\t\t\trulelen = 1;\n\t\t\tvarlength = false;\n\n\t\t\tcurrent_state_type = STATE_TRAILING_CONTEXT;\n\n\t\t\tif ( trlcontxt )\n\t\t\t\t{\n\t\t\t\tsynerr( \"trailing context used twice\" );\n\t\t\t\tyyval = mkstate( SYM_EPSILON );\n\t\t\t\t}\n\n\t\t\telse if ( previous_continued_action )\n\t\t\t\t{\n\t\t\t\t/* See the comment in the rule for \"re2 re\"\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\twarn(\n\t\t\"trailing context made variable due to preceding '|' action\" );\n\n\t\t\t\tvarlength = true;\n\t\t\t\t}\n\n\t\t\tif ( lex_compat || varlength )\n\t\t\t\t{\n\t\t\t\t/* Again, see the comment in the rule for\n\t\t\t\t * \"re2 re\" above.\n\t\t\t\t */\n\t\t\t\tadd_accept( yyvsp[-1],\n\t\t\t\t\tnum_rules | YY_TRAILING_HEAD_MASK );\n\t\t\t\tvariable_trail_rule = true;\n\t\t\t\t}\n\n\t\t\ttrlcontxt = true;\n\n\t\t\teps = mkstate( SYM_EPSILON );\n\t\t\tyyval = link_machines( yyvsp[-1],\n\t\t\t\tlink_machines( eps, mkstate( '\\n' ) ) );\n\t\t\t;\n    break;}\ncase 38:\n{\n\t\t\tyyval = yyvsp[0];\n\n\t\t\tif ( trlcontxt )\n\t\t\t\t{\n\t\t\t\tif ( lex_compat || (varlength && headcnt == 0) )\n\t\t\t\t\t/* Both head and trail are\n\t\t\t\t\t * variable-length.\n\t\t\t\t\t */\n\t\t\t\t\tvariable_trail_rule = true;\n\t\t\t\telse\n\t\t\t\t\ttrailcnt = rulelen;\n\t\t\t\t}\n\t\t\t;\n    break;}\ncase 39:\n{\n\t\t\tvarlength = true;\n\t\t\tyyval = mkor( yyvsp[-2], yyvsp[0] );\n\t\t\t;\n    break;}\ncase 40:\n{ yyval = yyvsp[0]; ;\n    break;}\ncase 41:\n{\n\t\t\t/* This rule is written separately so the\n\t\t\t * reduction will occur before the trailing\n\t\t\t * series is parsed.\n\t\t\t */\n\n\t\t\tif ( trlcontxt )\n\t\t\t\tsynerr( \"trailing context used twice\" );\n\t\t\telse\n\t\t\t\ttrlcontxt = true;\n\n\t\t\tif ( varlength )\n\t\t\t\t/* We hope the trailing context is\n\t\t\t\t * fixed-length.\n\t\t\t\t */\n\t\t\t\tvarlength = false;\n\t\t\telse\n\t\t\t\theadcnt = rulelen;\n\n\t\t\trulelen = 0;\n\n\t\t\tcurrent_state_type = STATE_TRAILING_CONTEXT;\n\t\t\tyyval = yyvsp[-1];\n\t\t\t;\n    break;}\ncase 42:\n{\n\t\t\t/* This is where concatenation of adjacent patterns\n\t\t\t * gets done.\n\t\t\t */\n\t\t\tyyval = link_machines( yyvsp[-1], yyvsp[0] );\n\t\t\t;\n    break;}\ncase 43:\n{ yyval = yyvsp[0]; ;\n    break;}\ncase 44:\n{\n\t\t\tvarlength = true;\n\n\t\t\tyyval = mkclos( yyvsp[-1] );\n\t\t\t;\n    break;}\ncase 45:\n{\n\t\t\tvarlength = true;\n\t\t\tyyval = mkposcl( yyvsp[-1] );\n\t\t\t;\n    break;}\ncase 46:\n{\n\t\t\tvarlength = true;\n\t\t\tyyval = mkopt( yyvsp[-1] );\n\t\t\t;\n    break;}\ncase 47:\n{\n\t\t\tvarlength = true;\n\n\t\t\tif ( yyvsp[-3] > yyvsp[-1] || yyvsp[-3] < 0 )\n\t\t\t\t{\n\t\t\t\tsynerr( \"bad iteration values\" );\n\t\t\t\tyyval = yyvsp[-5];\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( yyvsp[-3] == 0 )\n\t\t\t\t\t{\n\t\t\t\t\tif ( yyvsp[-1] <= 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tsynerr(\n\t\t\t\t\t\t\"bad iteration values\" );\n\t\t\t\t\t\tyyval = yyvsp[-5];\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tyyval = mkopt(\n\t\t\t\t\t\t\tmkrep( yyvsp[-5], 1, yyvsp[-1] ) );\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tyyval = mkrep( yyvsp[-5], yyvsp[-3], yyvsp[-1] );\n\t\t\t\t}\n\t\t\t;\n    break;}\ncase 48:\n{\n\t\t\tvarlength = true;\n\n\t\t\tif ( yyvsp[-2] <= 0 )\n\t\t\t\t{\n\t\t\t\tsynerr( \"iteration value must be positive\" );\n\t\t\t\tyyval = yyvsp[-4];\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\tyyval = mkrep( yyvsp[-4], yyvsp[-2], INFINITY );\n\t\t\t;\n    break;}\ncase 49:\n{\n\t\t\t/* The singleton could be something like \"(foo)\",\n\t\t\t * in which case we have no idea what its length\n\t\t\t * is, so we punt here.\n\t\t\t */\n\t\t\tvarlength = true;\n\n\t\t\tif ( yyvsp[-1] <= 0 )\n\t\t\t\t{\n\t\t\t\tsynerr( \"iteration value must be positive\" );\n\t\t\t\tyyval = yyvsp[-3];\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\tyyval = link_machines( yyvsp[-3],\n\t\t\t\t\t\tcopysingl( yyvsp[-3], yyvsp[-1] - 1 ) );\n\t\t\t;\n    break;}\ncase 50:\n{\n\t\t\tif ( ! madeany )\n\t\t\t\t{\n\t\t\t\t/* Create the '.' character class. */\n\t\t\t\tanyccl = cclinit();\n\t\t\t\tccladd( anyccl, '\\n' );\n\t\t\t\tcclnegate( anyccl );\n\n\t\t\t\tif ( useecs )\n\t\t\t\t\tmkeccl( ccltbl + cclmap[anyccl],\n\t\t\t\t\t\tccllen[anyccl], nextecm,\n\t\t\t\t\t\tecgroup, csize, csize );\n\n\t\t\t\tmadeany = true;\n\t\t\t\t}\n\n\t\t\t++rulelen;\n\n\t\t\tyyval = mkstate( -anyccl );\n\t\t\t;\n    break;}\ncase 51:\n{\n\t\t\tif ( ! cclsorted )\n\t\t\t\t/* Sort characters for fast searching.  We\n\t\t\t\t * use a shell sort since this list could\n\t\t\t\t * be large.\n\t\t\t\t */\n\t\t\t\tcshell( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]], true );\n\n\t\t\tif ( useecs )\n\t\t\t\tmkeccl( ccltbl + cclmap[yyvsp[0]], ccllen[yyvsp[0]],\n\t\t\t\t\tnextecm, ecgroup, csize, csize );\n\n\t\t\t++rulelen;\n\n\t\t\tyyval = mkstate( -yyvsp[0] );\n\t\t\t;\n    break;}\ncase 52:\n{\n\t\t\t++rulelen;\n\n\t\t\tyyval = mkstate( -yyvsp[0] );\n\t\t\t;\n    break;}\ncase 53:\n{ yyval = yyvsp[-1]; ;\n    break;}\ncase 54:\n{ yyval = yyvsp[-1]; ;\n    break;}\ncase 55:\n{\n\t\t\t++rulelen;\n\n\t\t\tif ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )\n\t\t\t\tyyvsp[0] = clower( yyvsp[0] );\n\n\t\t\tyyval = mkstate( yyvsp[0] );\n\t\t\t;\n    break;}\ncase 56:\n{ yyval = yyvsp[-1]; ;\n    break;}\ncase 57:\n{\n\t\t\tcclnegate( yyvsp[-1] );\n\t\t\tyyval = yyvsp[-1];\n\t\t\t;\n    break;}\ncase 58:\n{\n\t\t\tif ( caseins )\n\t\t\t\t{\n\t\t\t\tif ( yyvsp[-2] >= 'A' && yyvsp[-2] <= 'Z' )\n\t\t\t\t\tyyvsp[-2] = clower( yyvsp[-2] );\n\t\t\t\tif ( yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )\n\t\t\t\t\tyyvsp[0] = clower( yyvsp[0] );\n\t\t\t\t}\n\n\t\t\tif ( yyvsp[-2] > yyvsp[0] )\n\t\t\t\tsynerr( \"negative range in character class\" );\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfor ( i = yyvsp[-2]; i <= yyvsp[0]; ++i )\n\t\t\t\t\tccladd( yyvsp[-3], i );\n\n\t\t\t\t/* Keep track if this ccl is staying in\n\t\t\t\t * alphabetical order.\n\t\t\t\t */\n\t\t\t\tcclsorted = cclsorted && (yyvsp[-2] > lastchar);\n\t\t\t\tlastchar = yyvsp[0];\n\t\t\t\t}\n\n\t\t\tyyval = yyvsp[-3];\n\t\t\t;\n    break;}\ncase 59:\n{\n\t\t\tif ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )\n\t\t\t\tyyvsp[0] = clower( yyvsp[0] );\n\n\t\t\tccladd( yyvsp[-1], yyvsp[0] );\n\t\t\tcclsorted = cclsorted && (yyvsp[0] > lastchar);\n\t\t\tlastchar = yyvsp[0];\n\t\t\tyyval = yyvsp[-1];\n\t\t\t;\n    break;}\ncase 60:\n{\n\t\t\t/* Too hard to properly maintain cclsorted. */\n\t\t\tcclsorted = false;\n\t\t\tyyval = yyvsp[-1];\n\t\t\t;\n    break;}\ncase 61:\n{\n\t\t\tcclsorted = true;\n\t\t\tlastchar = 0;\n\t\t\tcurrccl = yyval = cclinit();\n\t\t\t;\n    break;}\ncase 62:\n{ CCL_EXPR(isalnum) ;\n    break;}\ncase 63:\n{ CCL_EXPR(isalpha) ;\n    break;}\ncase 64:\n{ CCL_EXPR(IS_BLANK) ;\n    break;}\ncase 65:\n{ CCL_EXPR(iscntrl) ;\n    break;}\ncase 66:\n{ CCL_EXPR(isdigit) ;\n    break;}\ncase 67:\n{ CCL_EXPR(isgraph) ;\n    break;}\ncase 68:\n{ CCL_EXPR(islower) ;\n    break;}\ncase 69:\n{ CCL_EXPR(isprint) ;\n    break;}\ncase 70:\n{ CCL_EXPR(ispunct) ;\n    break;}\ncase 71:\n{ CCL_EXPR(isspace) ;\n    break;}\ncase 72:\n{\n\t\t\t\tif ( caseins )\n\t\t\t\t\tCCL_EXPR(islower)\n\t\t\t\telse\n\t\t\t\t\tCCL_EXPR(isupper)\n\t\t\t\t;\n    break;}\ncase 73:\n{ CCL_EXPR(isxdigit) ;\n    break;}\ncase 74:\n{\n\t\t\tif ( caseins && yyvsp[0] >= 'A' && yyvsp[0] <= 'Z' )\n\t\t\t\tyyvsp[0] = clower( yyvsp[0] );\n\n\t\t\t++rulelen;\n\n\t\t\tyyval = link_machines( yyvsp[-1], mkstate( yyvsp[0] ) );\n\t\t\t;\n    break;}\ncase 75:\n{ yyval = mkstate( SYM_EPSILON ); ;\n    break;}\n}\n   /* the action file gets copied in in place of this dollarsign */\n  yyvsp -= yylen;\n  yyssp -= yylen;\n#ifdef YYLSP_NEEDED\n  yylsp -= yylen;\n#endif\n\n#if YYDEBUG != 0\n  if (yydebug)\n    {\n      short *ssp1 = yyss - 1;\n      fprintf (err, \"state stack now\");\n      while (ssp1 != yyssp)\n\tfprintf (err, \" %d\", *++ssp1);\n      fprintf (err, \"\\n\");\n    }\n#endif\n\n  *++yyvsp = yyval;\n\n#ifdef YYLSP_NEEDED\n  yylsp++;\n  if (yylen == 0)\n    {\n      yylsp->first_line = yylloc.first_line;\n      yylsp->first_column = yylloc.first_column;\n      yylsp->last_line = (yylsp-1)->last_line;\n      yylsp->last_column = (yylsp-1)->last_column;\n      yylsp->text = 0;\n    }\n  else\n    {\n      yylsp->last_line = (yylsp+yylen-1)->last_line;\n      yylsp->last_column = (yylsp+yylen-1)->last_column;\n    }\n#endif\n\n  /* Now \"shift\" the result of the reduction.\n     Determine what state that goes to,\n     based on the state we popped back to\n     and the rule number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;\n  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTBASE];\n\n  goto yynewstate;\n\nyyerrlab:   /* here on detecting error */\n\n  if (! yyerrstatus)\n    /* If not already recovering from an error, report this error.  */\n    {\n      ++yynerrs;\n\n#ifdef YYERROR_VERBOSE\n      yyn = yypact[yystate];\n\n      if (yyn > YYFLAG && yyn < YYLAST)\n\t{\n\t  int size = 0;\n\t  char *msg;\n\t  int x, count;\n\n\t  count = 0;\n\t  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */\n\t  for (x = (yyn < 0 ? -yyn : 0);\n\t       x < (sizeof(yytname) / sizeof(char *)); x++)\n\t    if (yycheck[x + yyn] == x)\n\t      size += strlen(yytname[x]) + 15, count++;\n\t  msg = (char *) malloc(size + 15);\n\t  if (msg != 0)\n\t    {\n\t      strcpy(msg, \"parse error\");\n\n\t      if (count < 5)\n\t\t{\n\t\t  count = 0;\n\t\t  for (x = (yyn < 0 ? -yyn : 0);\n\t\t       x < (sizeof(yytname) / sizeof(char *)); x++)\n\t\t    if (yycheck[x + yyn] == x)\n\t\t      {\n\t\t\tstrcat(msg, count == 0 ? \", expecting `\" : \" or `\");\n\t\t\tstrcat(msg, yytname[x]);\n\t\t\tstrcat(msg, \"'\");\n\t\t\tcount++;\n\t\t      }\n\t\t}\n\t      yyerror(msg);\n\t      free(msg);\n\t    }\n\t  else\n\t    yyerror (\"parse error; also virtual memory exceeded\");\n\t}\n      else\n#endif /* YYERROR_VERBOSE */\n\tyyerror(\"parse error\");\n    }\n\n  goto yyerrlab1;\nyyerrlab1:   /* here on error raised explicitly by an action */\n\n  if (yyerrstatus == 3)\n    {\n      /* if just tried and failed to reuse lookahead token after an error, discard it.  */\n\n      /* return failure if at end of input */\n      if (yychar == YYEOF)\n\tYYABORT;\n\n#if YYDEBUG != 0\n      if (yydebug)\n\tfprintf(err, \"Discarding token %d (%s).\\n\", yychar, yytname[yychar1]);\n#endif\n\n      yychar = YYEMPTY;\n    }\n\n  /* Else will try to reuse lookahead token\n     after shifting the error token.  */\n\n  yyerrstatus = 3;\t\t/* Each real token shifted decrements this */\n\n  goto yyerrhandle;\n\nyyerrdefault:  /* current state does not do anything special for the error token. */\n\n#if 0\n  /* This is wrong; only states that explicitly want error tokens\n     should shift them.  */\n  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/\n  if (yyn) goto yydefault;\n#endif\n\nyyerrpop:   /* pop the current state because it cannot handle the error token */\n\n  if (yyssp == yyss) YYABORT;\n  yyvsp--;\n  yystate = *--yyssp;\n#ifdef YYLSP_NEEDED\n  yylsp--;\n#endif\n\n#if YYDEBUG != 0\n  if (yydebug)\n    {\n      short *ssp1 = yyss - 1;\n      fprintf (err, \"Error: state stack now\");\n      while (ssp1 != yyssp)\n\tfprintf (err, \" %d\", *++ssp1);\n      fprintf (err, \"\\n\");\n    }\n#endif\n\nyyerrhandle:\n\n  yyn = yypact[yystate];\n  if (yyn == YYFLAG)\n    goto yyerrdefault;\n\n  yyn += YYTERROR;\n  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)\n    goto yyerrdefault;\n\n  yyn = yytable[yyn];\n  if (yyn < 0)\n    {\n      if (yyn == YYFLAG)\n\tgoto yyerrpop;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n  else if (yyn == 0)\n    goto yyerrpop;\n\n  if (yyn == YYFINAL)\n    YYACCEPT;\n\n#if YYDEBUG != 0\n  if (yydebug)\n    fprintf(err, \"Shifting error token, \");\n#endif\n\n  *++yyvsp = yylval;\n#ifdef YYLSP_NEEDED\n  *++yylsp = yylloc;\n#endif\n\n  yystate = yyn;\n  goto yynewstate;\n\n yyacceptlab:\n  /* YYACCEPT comes here.  */\n  if (yyfree_stacks)\n    {\n      free (yyss);\n      free (yyvs);\n#ifdef YYLSP_NEEDED\n      free (yyls);\n#endif\n    }\n  return 0;\n\n yyabortlab:\n  /* YYABORT comes here.  */\n  if (yyfree_stacks)\n    {\n      free (yyss);\n      free (yyvs);\n#ifdef YYLSP_NEEDED\n      free (yyls);\n#endif\n    }\n  return 1;\n}\n\n\n\n/* build_eof_action - build the \"<<EOF>>\" action for the active start\n *                    conditions\n */\n\nvoid build_eof_action()\n\t{\n\tregister int i;\n\tchar action_text[MAXLINE];\n\n\tfor ( i = 1; i <= scon_stk_ptr; ++i )\n\t\t{\n\t\tif ( sceof[scon_stk[i]] )\n\t\t\tformat_pinpoint_message(\n\t\t\t\t\"multiple <<EOF>> rules for start condition %s\",\n\t\t\t\tscname[scon_stk[i]] );\n\n\t\telse\n\t\t\t{\n\t\t\tsceof[scon_stk[i]] = true;\n\t\t\tsprintf( action_text, \"case YY_STATE_EOF(%s):\\n\",\n\t\t\t\tscname[scon_stk[i]] );\n\t\t\tadd_action( action_text );\n\t\t\t}\n\t\t}\n\n\tline_directive_out( (FILE *) 0, 1 );\n\n\t/* This isn't a normal rule after all - don't count it as\n\t * such, so we don't have any holes in the rule numbering\n\t * (which make generating \"rule can never match\" warnings\n\t * more difficult.\n\t */\n\t--num_rules;\n\t++num_eof_rules;\n\t}\n\n\n/* format_synerr - write out formatted syntax error */\n\nvoid format_synerr( msg, arg )\nchar msg[], arg[];\n\t{\n\tchar errmsg[MAXLINE];\n\n\t(void) sprintf( errmsg, msg, arg );\n\tsynerr( errmsg );\n\t}\n\n\n/* synerr - report a syntax error */\n\nvoid synerr( str )\nchar str[];\n\t{\n\tsyntaxerror = true;\n\tpinpoint_message( str );\n\t}\n\n\n/* format_warn - write out formatted warning */\n\nvoid format_warn( msg, arg )\nchar msg[], arg[];\n\t{\n\tchar warn_msg[MAXLINE];\n\n\t(void) sprintf( warn_msg, msg, arg );\n\twarn( warn_msg );\n\t}\n\n\n/* warn - report a warning, unless -w was given */\n\nvoid warn( str )\nchar str[];\n\t{\n\tline_warning( str, linenum );\n\t}\n\n/* format_pinpoint_message - write out a message formatted with one string,\n *\t\t\t     pinpointing its location\n */\n\nvoid format_pinpoint_message( msg, arg )\nchar msg[], arg[];\n\t{\n\tchar errmsg[MAXLINE];\n\n\t(void) sprintf( errmsg, msg, arg );\n\tpinpoint_message( errmsg );\n\t}\n\n\n/* pinpoint_message - write out a message, pinpointing its location */\n\nvoid pinpoint_message( str )\nchar str[];\n\t{\n\tline_pinpoint( str, linenum );\n\t}\n\n\n/* line_warning - report a warning at a given line, unless -w was given */\n\nvoid line_warning( str, line )\nchar str[];\nint line;\n\t{\n\tchar warning[MAXLINE];\n\n\tif ( ! nowarn )\n\t\t{\n\t\tsprintf( warning, \"warning, %s\", str );\n\t\tline_pinpoint( warning, line );\n\t\t}\n\t}\n\n\n/* line_pinpoint - write out a message, pinpointing it at the given line */\n\nvoid line_pinpoint( str, line )\nchar str[];\nint line;\n\t{\n\tfprintf( err, \"\\\"%s\\\", line %d: %s\\n\", infilename, line, str );\n\t}\n\n\n/* yyerror - eat up an error message from the parser;\n *\t     currently, messages are ignore\n */\n\nvoid yyerror( msg )\nchar msg[];\n\t{\n\t}\n/* A lexical scanner generated by flex */\n\n/* Scanner skeleton version:\n * $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $\n */\n\n#define FLEX_SCANNER\n#define YY_FLEX_MAJOR_VERSION 2\n#define YY_FLEX_MINOR_VERSION 5\n\n#include <stdio.h>\n\n\n/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */\n#ifdef c_plusplus\n#ifndef __cplusplus\n#define __cplusplus\n#endif\n#endif\n\n\n#ifdef __cplusplus\n\n#include <stdlib.h>\n#include <unistd.h>\n\n/* Use prototypes in function declarations. */\n#define YY_USE_PROTOS\n\n/* The \"const\" storage-class-modifier is valid. */\n#define YY_USE_CONST\n\n#else\t/* ! __cplusplus */\n\n#if __STDC__\n\n#define YY_USE_PROTOS\n#define YY_USE_CONST\n\n#endif\t/* __STDC__ */\n#endif\t/* ! __cplusplus */\n\n#ifdef __TURBOC__\n #pragma warn -rch\n #pragma warn -use\n#include <io.h>\n#include <stdlib.h>\n#define YY_USE_CONST\n#define YY_USE_PROTOS\n#endif\n\n#ifdef YY_USE_CONST\n#define yyconst const\n#else\n#define yyconst\n#endif\n\n\n#ifdef YY_USE_PROTOS\n#define YY_PROTO(proto) proto\n#else\n#define YY_PROTO(proto) ()\n#endif\n\n/* Returned upon end-of-file. */\n#define YY_NULL 0\n\n/* Promotes a possibly negative, possibly signed char to an unsigned\n * integer for use as an array index.  If the signed char is negative,\n * we want to instead treat it as an 8-bit unsigned char, hence the\n * double cast.\n */\n#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\n\n/* Enter a start condition.  This macro really ought to take a parameter,\n * but we do it the disgusting crufty way forced on us by the ()-less\n * definition of BEGIN.\n */\n#define BEGIN yy_start = 1 + 2 *\n\n/* Translate the current start state into a value that can be later handed\n * to BEGIN to return to the state.  The YYSTATE alias is for lex\n * compatibility.\n */\n#define YY_START ((yy_start - 1) / 2)\n#define YYSTATE YY_START\n\n/* Action number for EOF rule of a given start state. */\n#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n\n/* Special action meaning \"start processing a new file\". */\n#define YY_NEW_FILE yyrestart( yyin )\n\n#define YY_END_OF_BUFFER_CHAR 0\n\n/* Size of default input buffer. */\n#define YY_BUF_SIZE 16384\n\ntypedef struct yy_buffer_state *YY_BUFFER_STATE;\n\nextern int yyleng;\nextern FILE *yyin, *yyout;\n\n#define EOB_ACT_CONTINUE_SCAN 0\n#define EOB_ACT_END_OF_FILE 1\n#define EOB_ACT_LAST_MATCH 2\n\n/* The funky do-while in the following #define is used to turn the definition\n * int a single C statement (which needs a semi-colon terminator).  This\n * avoids problems with code like:\n *\n * \tif ( condition_holds )\n *\t\tyyless( 5 );\n *\telse\n *\t\tdo_something_else();\n *\n * Prior to using the do-while the compiler would get upset at the\n * \"else\" because it interpreted the \"if\" statement as being all\n * done when it reached the ';' after the yyless() call.\n */\n\n/* Return all but the first 'n' matched characters back to the input stream. */\n\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n\t\t*yy_cp = yy_hold_char; \\\n\t\tYY_RESTORE_YY_MORE_OFFSET \\\n\t\tyy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\\n\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n\t\t} \\\n\twhile ( 0 )\n\n#define unput(c) yyunput( c, yytext_ptr )\n\n/* The following is because we cannot portably get our hands on size_t\n * (without autoconf's help, which isn't available because we want\n * flex-generated scanners to compile on their own).\n */\ntypedef unsigned int yy_size_t;\n\n\nstruct yy_buffer_state\n\t{\n\tFILE *yy_input_file;\n\n\tchar *yy_ch_buf;\t\t/* input buffer */\n\tchar *yy_buf_pos;\t\t/* current position in input buffer */\n\n\t/* Size of input buffer in bytes, not including room for EOB\n\t * characters.\n\t */\n\tyy_size_t yy_buf_size;\n\n\t/* Number of characters read into yy_ch_buf, not including EOB\n\t * characters.\n\t */\n\tint yy_n_chars;\n\n\t/* Whether we \"own\" the buffer - i.e., we know we created it,\n\t * and can realloc() it to grow it, and should free() it to\n\t * delete it.\n\t */\n\tint yy_is_our_buffer;\n\n\t/* Whether this is an \"interactive\" input source; if so, and\n\t * if we're using stdio for input, then we want to use getc()\n\t * instead of fread(), to make sure we stop fetching input after\n\t * each newline.\n\t */\n\tint yy_is_interactive;\n\n\t/* Whether we're considered to be at the beginning of a line.\n\t * If so, '^' rules will be active on the next match, otherwise\n\t * not.\n\t */\n\tint yy_at_bol;\n\n\t/* Whether to try to fill the input buffer when we reach the\n\t * end of it.\n\t */\n\tint yy_fill_buffer;\n\n\tint yy_buffer_status;\n#define YY_BUFFER_NEW 0\n#define YY_BUFFER_NORMAL 1\n\t/* When an EOF's been seen but there's still some text to process\n\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n\t * shouldn't try reading from the input source any more.  We might\n\t * still have a bunch of tokens to match, though, because of\n\t * possible backing-up.\n\t *\n\t * When we actually see the EOF, we change the status to \"new\"\n\t * (via yyrestart()), so that the user can continue scanning by\n\t * just pointing yyin at a new input file.\n\t */\n#define YY_BUFFER_EOF_PENDING 2\n\t};\n\nstatic YY_BUFFER_STATE yy_current_buffer = 0;\n\n/* We provide macros for accessing buffer states in case in the\n * future we want to put the buffer states in a more general\n * \"scanner state\".\n */\n#define YY_CURRENT_BUFFER yy_current_buffer\n\n\n/* yy_hold_char holds the character lost when yytext is formed. */\nstatic char yy_hold_char;\n\nstatic int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */\n\n\nint yyleng;\n\n/* Points to current character in buffer. */\nstatic char *yy_c_buf_p = (char *) 0;\nstatic int yy_init = 1;\t\t/* whether we need to initialize */\nstatic int yy_start = 0;\t/* start state number */\n\n/* Flag which is used to allow yywrap()'s to do buffer switches\n * instead of setting up a fresh yyin.  A bit of a hack ...\n */\nstatic int yy_did_buffer_switch_on_eof;\n\nvoid yyrestart YY_PROTO(( FILE *input_file ));\n\nvoid yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));\nvoid yy_load_buffer_state YY_PROTO(( void ));\nYY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));\nvoid yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));\nvoid yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));\nvoid yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));\n#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )\n\nYY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));\nYY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));\nYY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));\n\nstatic void *yy_flex_alloc YY_PROTO(( yy_size_t ));\nstatic void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));\nstatic void yy_flex_free YY_PROTO(( void * ));\n\n#define yy_new_buffer yy_create_buffer\n\n#define yy_set_interactive(is_interactive) \\\n\t{ \\\n\tif ( ! yy_current_buffer ) \\\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n\tyy_current_buffer->yy_is_interactive = is_interactive; \\\n\t}\n\n#define yy_set_bol(at_bol) \\\n\t{ \\\n\tif ( ! yy_current_buffer ) \\\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n\tyy_current_buffer->yy_at_bol = at_bol; \\\n\t}\n\n#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)\n\ntypedef unsigned char YY_CHAR;\nFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;\ntypedef int yy_state_type;\nextern char *yytext;\n#define yytext_ptr yytext\n\nstatic yy_state_type yy_get_previous_state YY_PROTO(( void ));\nstatic yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));\nstatic int yy_get_next_buffer YY_PROTO(( void ));\nstatic void yy_fatal_error YY_PROTO(( yyconst char msg[] ));\n\n/* Done after the current pattern has been matched and before the\n * corresponding action - sets up yytext.\n */\n#define YY_DO_BEFORE_ACTION \\\n\tyytext_ptr = yy_bp; \\\n\tyyleng = (int) (yy_cp - yy_bp); \\\n\tyy_hold_char = *yy_cp; \\\n\t*yy_cp = '\\0'; \\\n\tyy_c_buf_p = yy_cp;\n\n#define YY_NUM_RULES 165\n#define YY_END_OF_BUFFER 166\nstatic yyconst short int yy_accept[769] =\n    {   0,\n        0,    0,    0,    0,   87,   87,  163,  163,    0,    0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n        0,    0,    0,    0,    0,    0,    0,    0,  166,  164,\n        7,   18,  164,   16,    1,   17,  164,  164,  164,  164,\n       15,  108,  100,  101,  108,   93,  108,  107,  108,  108,\n      108,  107,   99,   89,  108,  108,   91,   92,   87,   88,\n       87,   86,   85,   86,   86,  163,  163,   28,   29,   28,\n       28,   28,   28,   28,   28,   31,   30,   32,   31,  113,\n      109,  110,  112,  114,  141,  142,  141,  139,  138,  140,\n\n      115,  117,  115,  116,  115,  120,  120,  120,  120,  122,\n      124,  122,  122,  122,  122,  123,  151,  155,  151,  154,\n      156,  156,  152,  152,  152,  149,  150,  164,   82,  164,\n       21,   22,   21,   20,  157,  159,  157,  160,  161,  147,\n      147,  148,  147,  147,  147,  147,  147,  147,  147,   81,\n       34,   33,   81,   81,   81,   81,   35,   81,   81,   81,\n       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,\n       81,   81,   81,   81,   81,   81,   26,   23,   26,   24,\n        7,   18,    0,   16,    1,   17,    0,    0,    0,   14,\n        8,    0,    0,    0,    0,    4,    5,    0,    2,   15,\n\n      100,  101,    0,    0,    0,   95,    0,    0,  105,  105,\n        0,  162,  162,  162,   94,    0,   99,   89,    0,    0,\n        0,   91,   92,  104,   90,    0,   87,   88,   86,   85,\n       85,   83,   84,  163,  163,   28,   29,   28,   28,   28,\n       28,   31,   30,   32,  111,  112,  142,  138,  117,    0,\n      118,  119,  124,  121,  151,  155,    0,  153,    0,  144,\n      152,  152,  152,    0,   82,    0,   21,   22,   21,   19,\n      157,  159,  158,  147,  147,  147,  148,  143,  147,  147,\n      147,   34,   33,    0,   80,    0,    0,   81,   81,   81,\n       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,\n\n       81,   81,   81,   36,   81,   81,   81,   81,   81,   81,\n       81,   81,   81,   81,    0,   25,   24,    0,   14,    8,\n        0,   12,    0,    0,    0,    0,    0,    4,    5,    0,\n        6,    0,   96,    0,   97,    0,    0,  105,  105,    0,\n      105,  105,  105,  162,  162,    0,  106,   90,   98,    0,\n      104,    0,   83,   84,   28,   28,   28,   27,   28,    0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n        0,  152,  152,  143,  143,  147,  147,    0,    0,   81,\n       81,   81,   81,   81,   44,   81,   81,   81,   49,   81,\n       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,\n\n       81,   81,   81,   81,   81,   81,   81,   81,    0,   81,\n       81,   81,   81,    0,    0,    0,   12,    0,    0,    0,\n        0,    0,    0,    4,    5,    0,  105,  105,  105,  105,\n      105,  105,  162,    0,    0,   28,   28,    0,    0,    0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n      152,  152,  147,  147,   37,   38,   81,   81,   81,   81,\n       81,   81,   81,   81,   50,   51,   81,   81,   81,   55,\n       81,   81,   81,   81,   81,   81,   60,   81,   81,   81,\n       81,   81,   81,   67,    0,    0,    0,   81,   81,   81,\n       81,    0,   13,    0,    0,    0,    0,    0,    0,  105,\n\n      105,  105,  105,  105,  105,    0,    0,   28,   28,  137,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n        0,    0,  152,  152,  147,  147,   39,   81,   41,   81,\n       43,   81,   81,   81,   47,   81,   52,   81,   81,   81,\n       81,   81,   81,   81,   81,   81,   62,   81,   81,   65,\n       81,    0,    0,    0,    0,   81,   81,   81,   81,    3,\n        0,    0,    0,    0,  105,  105,  105,    0,    0,   28,\n       28,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n        0,    0,    0,  145,  146,  145,  146,   81,   42,   81,\n       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,\n\n       81,   78,   61,   81,   64,   81,    0,    0,    0,    0,\n       81,   81,   69,   70,    0,   10,    0,   11,    0,  103,\n        0,  102,    0,    0,    0,    0,    0,    0,    0,    0,\n        0,    0,    0,    0,   81,   81,   81,   45,   81,   48,\n       81,   81,   81,   81,   77,   81,   59,   63,   66,    0,\n        0,    0,    0,   79,   81,    0,  102,    0,    0,    0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,   81,\n       81,   81,   46,   81,   81,   56,   81,   81,    0,    0,\n        0,    0,   68,    0,    9,    0,  125,  126,  127,  128,\n      129,  130,  131,  132,  133,  134,  135,    0,   81,   81,\n\n       81,   81,   81,   81,   81,    0,    0,    0,    0,    0,\n      136,   81,   81,   81,   81,   54,   81,   81,    0,    0,\n        0,    0,    0,    0,   81,   81,   81,   53,   81,   58,\n        0,    0,    0,    0,    0,    0,   81,   81,   81,   81,\n       72,    0,    0,    0,    0,   73,   81,   81,   81,   81,\n       71,    0,   75,    0,   81,   81,   81,   74,   76,   81,\n       81,   81,   81,   81,   81,   57,   40,    0\n    } ;\n\nstatic yyconst int yy_ec[256] =\n    {   0,\n        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,\n        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    2,    1,    5,    6,    7,    8,    1,    9,   10,\n       10,   11,   12,   13,   14,   10,   15,   16,   16,   16,\n       16,   16,   16,   16,   17,   18,   19,   20,    1,   21,\n       22,   23,   10,    1,   31,   32,   33,   34,   35,   36,\n       37,   38,   39,   40,   41,   42,   43,   44,   45,   46,\n       47,   48,   49,   50,   51,   52,   53,   54,   55,   47,\n       26,   27,   28,   29,   30,    1,   31,   32,   33,   34,\n\n       35,   36,   37,   38,   39,   40,   41,   42,   43,   44,\n       45,   46,   47,   48,   49,   50,   51,   52,   53,   54,\n       55,   47,   56,   57,   58,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1\n    } ;\n\nstatic yyconst int yy_meta[59] =\n    {   0,\n        1,    1,    2,    1,    3,    1,    1,    1,    4,    1,\n        5,    6,    1,    7,    4,    8,    8,    8,    8,    1,\n        1,    1,    1,    9,   10,    1,   11,   12,    1,   13,\n       14,   14,   14,   14,   14,   14,   15,   15,   15,   15,\n       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,\n       15,   15,   15,   15,   15,    4,    1,   16\n    } ;\n\nstatic yyconst short int yy_base[858] =\n    {   0,\n        0,   58,  115,  172,  120,  129, 2712, 2711,  230, 2705,\n      136,  141,  288,    0, 2683, 2682,  144,  151,  185,  191,\n      178,  188,  344,  347,  375,    0,  125,  131,  147,  216,\n      431,  434,  461,    0,  519,    0,  205,  349, 2710, 2716,\n      353, 2716, 2706,    0,  360, 2716, 2705,  144,  570, 2696,\n        0, 2716,  577, 2716, 2703, 2716,  438, 2716, 2684,  126,\n      149,  427,  591, 2716, 2701,  141, 2682, 2716,    0, 2716,\n     2699,    0, 2699, 2697,  155, 2696, 2716,    0, 2716, 2695,\n     2716,    0, 2662, 2641, 2637,    0, 2692, 2716, 2690, 2716,\n     2716, 2663,    0, 2716, 2716, 2716, 2688, 2716,  431, 2716,\n\n     2716, 2716, 2687, 2716,  567, 2716, 2669,  571,  164, 2716,\n     2716, 2685,    0, 2667,  573, 2716,    0, 2716, 2683, 2716,\n      573, 2674,    0, 2649, 2628, 2716, 2716,  222, 2716,  356,\n      448, 2716,  450, 2667,    0, 2716, 2678, 2716,    0,    0,\n      198, 2716, 2677, 2621, 2716, 2667,    0, 2642, 2621, 2716,\n     2673, 2716, 2671, 2668, 2640, 2639, 2716,  544, 2639,  579,\n     2634, 2635,  318,    0, 2623, 2631,  424,  562, 2614,  587,\n     2629, 2613, 2618, 2626, 2629, 2604, 2716, 2716, 2653,  612,\n      634, 2716, 2654,    0,  637, 2716, 2653,  600, 2616,    0,\n        0,  641,  647,  651,  669,    0,    0,  453, 2716,    0,\n\n      672, 2716, 2651, 2597,  605, 2716, 2649, 2616,  620,  657,\n      645, 2716,  662,    0, 2716, 2592,  688, 2716, 2646, 2592,\n     2636, 2625, 2716,    0, 2716, 2610,    0, 2716,    0,    0,\n     2642,    0,    0, 2640, 2716,    0, 2716,    0, 2602, 2598,\n      745,    0, 2638, 2716, 2716,    0, 2716,  688, 2716,  773,\n     2716, 2716, 2716, 2716,    0, 2716,  673, 2716,    0, 2716,\n        0, 2599, 2595,  690, 2716,  698,  707, 2716,  709, 2716,\n        0, 2716, 2716,    0,  596, 2579, 2716,  827,    0, 2596,\n     2592, 2632, 2716, 2628, 2716, 2593, 2592,    0,  642, 2582,\n      563, 2617, 2579,  620, 2578, 2577, 2583,  669, 2570, 2584,\n\n     2572,    0, 2569, 2716, 2570, 2571, 2579, 2582,  685,  125,\n     2570, 2567, 2566,  688, 2608, 2716,  716, 2568,    0,    0,\n      720, 2716, 2608,  884, 2562, 2559, 2569,    0,    0,  723,\n     2716,  739, 2716,  805, 2716,  808, 2562,  787,  869,  876,\n      930,  881,  973,  800,    0, 2548, 2716, 2716, 2716, 2570,\n        0, 2559,    0,    0, 2568, 2557,    0, 2716,    0, 1009,\n     2581,  678,  870,  871,  874,  879,  913,  992,  974, 1013,\n      885, 2565, 2554,    0, 1067, 2563, 2552, 2546, 2545, 2557,\n     2562, 2561, 2550, 2557,    0, 2554, 2537, 2556,    0, 2536,\n     2543, 2533, 2548, 2568, 2537, 2549, 2544, 2542, 2541, 2532,\n\n     2539, 2540, 2538, 2539,  578, 2520, 2538, 2525,  860, 2526,\n     2528, 2521, 2517, 2529,  817, 1044, 2716,  822, 1095,  914,\n     2532, 2523, 2517,    0,    0, 2524, 1102, 1025, 1142, 2539,\n     1028, 1163, 2716, 2513, 2521, 2523, 2507,    0, 2526, 1058,\n      891, 1014, 1019,  894, 1038, 1080, 1072, 1086, 1083, 1081,\n     2520, 2504, 2518, 2502, 2716, 2716, 2505, 2493, 2492, 2495,\n     2507, 1148, 2507, 2492,    0,    0, 2492, 2493, 2507,    0,\n     2525, 2490, 2498, 2522, 2485, 2495,    0, 2500, 2491, 2487,\n     2479, 2479, 2483,    0,  875, 2494, 2481, 2494, 2480, 2475,\n     2491, 2519, 2716,  920,  999, 2465, 2474, 2468, 2494, 2496,\n\n     1105, 1184, 1081,  902,  969, 2479, 2491, 2463, 2477, 2716,\n      165, 1090, 1144, 1143, 1147, 1163, 1095, 1145, 1037, 1085,\n     1150, 1173, 2461, 2475, 2459, 2473,    0, 2458,    0, 2460,\n        0, 1165, 2454, 2469,    0, 2461,    0, 2471, 2410, 2414,\n     2434, 2400, 2393, 2405, 2385, 2382,    0, 2383, 2335,    0,\n     2335, 2330, 2326, 2309, 2278, 2259, 2269, 2268, 2256, 2297,\n     1046, 2238, 2242, 2253, 1179, 1142, 1145, 2247, 2246,    0,\n        0, 1191, 1192, 1172, 1201, 1202, 1204, 1205, 1206, 1207,\n     1209, 1210, 1208,    0,    0,    0,    0, 2254,    0, 2221,\n     2229, 2218, 2208, 2200, 2209, 2198, 2195, 2165, 2168, 2149,\n\n     2132,    0,    0, 2129,    0, 2139, 2143, 2134, 2124, 2137,\n     2117, 2116,    0,    0, 1228, 2716, 1232, 2716, 2111, 2716,\n     2117, 2716, 2115, 2114, 2108, 2107, 2106, 2103, 2102, 2098,\n     2095, 2063, 2047, 1213, 2012, 1986, 1975,    0, 1954,    0,\n     1947, 1950, 1941, 1945,    0, 1942,    0,    0,    0, 1938,\n     1940, 1934, 1905,    0, 1872, 1234, 2716, 1888, 1882, 1881,\n     1864, 1848, 1832, 1828, 1827, 1826, 1823, 1806, 1809, 1784,\n     1787, 1772,    0, 1781, 1786,    0, 1766, 1767, 1759, 1744,\n     1213, 1736,    0, 1236, 2716, 1245, 2716, 2716, 2716, 2716,\n     2716, 2716, 2716, 2716, 2716, 2716, 2716, 1750, 1727, 1720,\n\n     1701, 1687, 1670, 1681, 1667, 1679, 1659,  689, 1658, 1671,\n     2716, 1657, 1627, 1621, 1635,    0, 1603, 1596, 1595, 1608,\n     1602, 1587, 1586, 1583, 1581, 1587, 1555,    0, 1547,    0,\n     1527, 1507, 1520, 1503, 1483, 1482, 1485, 1443, 1440, 1228,\n     2716, 1225, 1224, 1206, 1210, 2716, 1213, 1202, 1018,  948,\n     2716,  945, 2716,  884,  780,  771,  779, 2716, 2716,  689,\n      673,  581,  408,  318,   86,    0,    0, 2716, 1263, 1279,\n     1295, 1311, 1327, 1343, 1359, 1375, 1391, 1407, 1423, 1439,\n     1455, 1471, 1481, 1496, 1505, 1520, 1536, 1545, 1560, 1576,\n     1592, 1608, 1624, 1634, 1649, 1659, 1674, 1690, 1706, 1718,\n\n     1728, 1743, 1759, 1775, 1791, 1807, 1817, 1832, 1843, 1236,\n     1858, 1874, 1890, 1898, 1905, 1920, 1936, 1952, 1968, 1977,\n     1985, 2001, 2017, 2033, 2049, 2065, 2081, 2097, 2113, 2123,\n     2138, 2148, 2155, 2170, 2182, 2192, 2207, 2223, 2239, 2255,\n     2265, 2280, 2291, 2306, 2322, 2338, 2354, 2364, 2373, 2388,\n     2404, 2420, 2429, 2437, 2453, 2469, 2485\n    } ;\n\nstatic yyconst short int yy_def[858] =\n    {   0,\n      768,  768,  769,  769,  770,  771,  772,  772,  768,    9,\n      773,  773,  768,   13,  774,  774,  775,  775,  776,  776,\n      777,  777,  778,  778,  768,   25,  779,  779,  780,  780,\n      781,  781,  768,   33,  768,   35,  782,  782,  768,  768,\n      768,  768,  768,  783,  768,  768,  768,  768,  784,  768,\n      785,  768,  768,  768,  768,  768,  768,  768,  768,  786,\n      787,  788,  768,  768,  768,  768,  768,  768,  789,  768,\n      789,  790,  791,  790,  790,  792,  768,  793,  768,  793,\n      768,  794,  794,  794,  793,  795,  768,  768,  795,  768,\n      768,  768,  796,  768,  768,  768,  768,  768,  768,  768,\n\n      768,  768,  768,  768,  787,  768,  768,  787,  797,  768,\n      768,  768,  798,  768,  787,  768,  799,  768,  799,  768,\n      800,  768,  801,  801,  801,  768,  768,  802,  768,  802,\n      803,  768,  803,  768,  804,  768,  804,  768,  805,  806,\n      806,  768,  806,  806,  768,  806,  807,  807,  807,  768,\n      768,  768,  768,  808,  768,  768,  768,  809,  809,  809,\n      809,  809,  809,  809,  809,  809,  809,  810,  809,  809,\n      809,  809,  809,  809,  809,  809,  768,  768,  811,  768,\n      768,  768,  768,  783,  768,  768,  768,  768,  768,  812,\n      813,  768,  768,  768,  768,  814,  815,  816,  768,  785,\n\n      768,  768,  768,  768,  817,  768,  768,  768,  818,  818,\n      819,  768,  768,  820,  768,  821,  768,  768,  768,  768,\n      768,  768,  768,  822,  768,  768,  823,  768,  824,  825,\n      825,  826,  827,  828,  768,  829,  768,  830,  830,  830,\n      768,  831,  768,  768,  768,  832,  768,  768,  768,  833,\n      768,  768,  768,  768,  834,  768,  835,  768,  835,  768,\n      836,  836,  836,  837,  768,  837,  838,  768,  838,  768,\n      839,  768,  768,  840,  840,  840,  768,  768,  841,  841,\n      841,  768,  768,  842,  768,  768,  768,  843,  843,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,\n\n      843,  843,  843,  768,  843,  843,  843,  843,  843,  843,\n      843,  843,  843,  843,  844,  768,  768,  768,  845,  846,\n      847,  768,  768,  768,  768,  768,  768,  848,  849,  850,\n      768,  850,  768,  851,  768,  851,  768,  852,  852,  852,\n      768,  852,  852,  768,  853,  854,  768,  768,  768,  768,\n      855,  768,  826,  827,  830,  830,  241,  768,  241,  241,\n      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,\n      833,  836,  836,  278,  278,  841,  841,  768,  768,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,\n\n      843,  843,  843,  843,  843,  843,  843,  843,  768,  843,\n      843,  843,  843,  768,  847,  847,  768,  847,  847,  768,\n      768,  768,  768,  848,  849,  768,  341,  852,  343,  341,\n      852,  343,  768,  768,  768,  830,  830,  360,  768,  833,\n      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,\n      836,  836,  841,  841,  768,  768,  843,  843,  843,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,\n      843,  843,  843,  843,  768,  768,  768,  843,  843,  843,\n      843,  768,  768,  847,  847,  768,  768,  768,  768,  427,\n\n      852,  343,  852,  852,  852,  768,  768,  830,  830,  768,\n      833,  833,  833,  833,  833,  833,  833,  833,  833,  833,\n      833,  833,  836,  836,  841,  841,  843,  843,  843,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,\n      843,  768,  768,  768,  768,  843,  843,  843,  843,  768,\n      856,  768,  768,  768,  852,  852,  852,  768,  768,  830,\n      830,  833,  833,  833,  833,  833,  833,  833,  833,  833,\n      833,  833,  833,  836,  836,  841,  841,  843,  843,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  843,\n\n      843,  843,  843,  843,  843,  843,  768,  768,  768,  768,\n      843,  843,  843,  843,  856,  768,  856,  768,  768,  768,\n      768,  768,  833,  833,  833,  833,  833,  833,  833,  833,\n      833,  833,  833,  833,  843,  843,  843,  843,  843,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  843,  768,\n      768,  768,  768,  843,  843,  857,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  833,  843,\n      843,  843,  843,  843,  843,  843,  843,  843,  768,  768,\n      768,  768,  843,  857,  768,  857,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  843,  843,\n\n      843,  843,  843,  843,  843,  768,  768,  768,  768,  768,\n      768,  843,  843,  843,  843,  843,  843,  843,  768,  768,\n      768,  768,  768,  768,  843,  843,  843,  843,  843,  843,\n      768,  768,  768,  768,  768,  768,  843,  843,  843,  843,\n      768,  768,  768,  768,  768,  768,  843,  843,  843,  843,\n      768,  768,  768,  768,  843,  843,  843,  768,  768,  843,\n      843,  843,  843,  843,  843,  843,  843,    0,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768\n    } ;\n\nstatic yyconst short int yy_nxt[2775] =\n    {   0,\n       40,   41,   42,   43,   40,   40,   40,   40,   40,   40,\n       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,\n       40,   40,   40,   44,   44,   40,   40,   40,   40,   44,\n       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,\n       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,\n       44,   44,   44,   44,   44,   40,   40,   40,   40,   45,\n       46,   47,   40,   48,   40,   49,   40,   40,   40,   40,\n       40,   40,   50,   40,   40,   40,   40,   40,   40,   40,\n       40,   51,   51,   40,   40,   40,   40,   51,   51,   51,\n       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n\n       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n       51,   51,   51,   40,   40,   40,   53,   54,   55,   56,\n      767,   57,   70,   71,   58,   58,   58,  129,  130,   58,\n       73,   70,   74,  129,  130,   59,   75,   87,   88,   89,\n       60,   61,   87,   88,   89,  188,   96,   97,  224,  132,\n      133,  210,  211,   96,   97,  404,   98,  134,  405,   99,\n       99,   99,   99,   98,  213,  213,   99,   99,   99,   99,\n       62,   58,   58,   63,   64,   65,   56,  252,   57,   66,\n       40,   58,   58,   58,  439,  189,   58,  102,  103,  104,\n       40,  252,   67,  102,  103,  104,  225,   60,   61,  275,\n\n       68,  100,  214,  107,  108,  276,  109,  178,  100,  179,\n      232,  105,  233,  107,  108,  572,  109,  105,  132,  133,\n      180,  180,  180,  180,  265,  266,  134,   62,   58,   58,\n       78,   78,   79,   80,   78,   78,   78,   78,   78,   78,\n       81,   78,   78,   78,   78,   78,   78,   78,   78,   78,\n       78,   78,   78,   82,   82,   78,   78,   78,   78,   82,\n       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,\n       82,   82,   82,   82,   82,   82,   82,   83,   82,   82,\n       82,   82,   82,   82,   84,   78,   78,   78,   90,   90,\n       40,   90,   90,   90,   90,   90,   90,   90,   91,   90,\n\n       91,   90,   90,   90,   90,   90,   90,   90,   90,   90,\n       92,   93,   93,   90,   90,   90,   90,   93,   93,   93,\n       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,\n       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,\n       93,   93,   93,   90,   90,   90,  111,  112,  296,  111,\n      112,  178,  766,  179,  181,  182,  183,  113,  265,  266,\n      113,  185,  186,  187,  180,  180,  180,  180,  297,  114,\n      115,  116,  114,  115,  116,  117,  117,  118,  119,  120,\n      117,  117,  117,  121,  117,  117,  117,  117,  117,  122,\n      117,  117,  117,  117,  117,  117,  117,  117,  123,  123,\n\n      117,  117,  117,  117,  123,  123,  123,  123,  123,  123,\n      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,\n      123,  123,  124,  123,  123,  123,  123,  123,  123,  125,\n      126,  117,  127,  136,  137,  138,  136,  137,  138,  206,\n      206,  207,  215,  215,  215,  215,  248,  248,  248,  248,\n      268,  269,  268,  269,  300,  331,  332,  139,  301,  765,\n      139,  140,  141,  142,  143,  140,  140,  140,  144,  140,\n      140,  145,  140,  140,  140,  146,  140,  140,  140,  140,\n      140,  140,  140,  140,  147,  147,  140,  140,  140,  140,\n      147,  147,  147,  147,  147,  147,  147,  147,  147,  147,\n\n      147,  147,  147,  147,  147,  147,  147,  147,  148,  147,\n      147,  147,  147,  147,  147,  149,  140,  140,  140,  150,\n      151,  152,  153,  154,  150,  150,  150,  150,  150,  150,\n      150,  150,  150,  150,  150,  155,  156,  150,  150,  150,\n      157,  150,  150,  150,  150,  150,  150,  150,  150,  158,\n      159,  160,  161,  162,  163,  164,  164,  165,  164,  164,\n      166,  167,  168,  169,  170,  164,  171,  172,  164,  173,\n      174,  175,  164,  176,  150,  150,  150,  191,  201,  202,\n      203,  258,  213,  213,  204,  289,  213,  213,  213,  213,\n      292,  290,  217,  218,  219,  383,  303,  275,  220,  259,\n\n      192,  188,  193,  276,  193,  221,  304,  335,  336,  293,\n      193,  222,  384,  193,  194,  195,  480,  193,  196,  223,\n      214,  306,  481,  197,  214,  198,  214,  317,  317,  317,\n      317,  307,  764,  205,  308,  181,  182,  183,  185,  186,\n      187,  189,  321,  322,  323,  339,  340,  205,  321,  322,\n      323,  387,  321,  322,  323,  388,  324,  324,  324,  324,\n      342,  342,  324,  324,  324,  324,  324,  324,  324,  324,\n      321,  322,  323,  201,  202,  203,  341,  344,  344,  204,\n      380,  258,  339,  340,  324,  324,  324,  324,  325,  217,\n      218,  219,  265,  266,  381,  220,  326,  439,  343,  259,\n\n      265,  266,  221,  248,  248,  248,  248,  673,  222,  268,\n      269,  268,  269,  327,  392,  402,  223,  409,  393,  440,\n      410,  416,  417,  418,  403,  331,  332,  763,  205,  411,\n      412,  317,  317,  317,  317,  419,  419,  419,  419,  721,\n      413,  331,  332,  722,  205,  357,  357,  358,  359,  357,\n      357,  357,  357,  357,  357,  360,  357,  357,  357,  357,\n      357,  357,  357,  357,  357,  357,  357,  357,  360,  360,\n      357,  357,  357,  357,  360,  360,  360,  360,  360,  360,\n      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,\n      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,\n\n      357,  357,  357,  362,  363,  364,  365,  335,  336,  366,\n      335,  336,  339,  340,  367,  212,  212,  762,  368,  493,\n      494,  369,  761,  370,  417,  494,  371,  374,  374,  760,\n      374,  374,  374,  374,  374,  374,  374,  375,  374,  374,\n      374,  374,  374,  374,  374,  374,  374,  374,  374,  374,\n      375,  375,  374,  374,  374,  374,  375,  375,  375,  375,\n      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,\n      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,\n      375,  375,  374,  374,  374,  420,  322,  323,  427,  439,\n      439,  428,  428,  439,  339,  340,  431,  431,  439,  324,\n\n      324,  324,  324,  338,  439,  485,  339,  340,  486,  487,\n      439,  441,  443,  439,  442,  420,  322,  323,  450,  552,\n      759,  513,  493,  494,  516,  553,  444,  339,  340,  429,\n      338,  338,  439,  338,  338,  338,  338,  338,  338,  338,\n      338,  338,  338,  338,  338,  338,  338,  338,  338,  338,\n      338,  338,  338,  430,  430,  339,  340,  445,  338,  338,\n      430,  430,  430,  430,  430,  430,  430,  430,  430,  430,\n      430,  430,  430,  430,  430,  430,  430,  430,  430,  430,\n      430,  430,  430,  430,  430,  338,  338,  338,  432,  432,\n      432,  432,  758,  439,  339,  340,  432,  757,  339,  340,\n\n      495,  417,  418,  432,  432,  432,  432,  432,  432,  360,\n      360,  439,  438,  360,  360,  360,  360,  360,  360,  448,\n      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,\n      360,  360,  439,  439,  360,  360,  360,  360,  439,  446,\n      501,  501,  447,  504,  504,  416,  417,  418,  616,  617,\n      339,  340,  638,  339,  340,  515,  439,  439,  449,  419,\n      419,  419,  419,  514,  360,  360,  360,  375,  375,  580,\n      375,  375,  375,  375,  375,  375,  375,  439,  375,  375,\n      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,\n      517,  439,  375,  375,  375,  375,  495,  417,  418,  439,\n\n      439,  511,  439,  512,  439,  439,  339,  340,  209,  439,\n      419,  419,  419,  419,  439,  519,  520,  581,  518,  522,\n      566,  566,  375,  375,  375,  500,  500,  573,  521,  578,\n      339,  340,  500,  500,  500,  500,  500,  500,  500,  500,\n      500,  500,  500,  500,  500,  500,  500,  500,  500,  500,\n      500,  500,  500,  500,  500,  500,  500,  502,  502,  502,\n      502,  532,  439,  439,  439,  502,  439,  339,  340,  439,\n      339,  340,  502,  502,  502,  502,  502,  502,  505,  505,\n      505,  505,  439,  533,  582,  576,  505,  574,  579,  534,\n      575,  439,  439,  505,  505,  505,  505,  505,  505,  567,\n\n      567,  567,  567,  590,  339,  340,  338,  567,  577,  583,\n      439,  439,  625,  591,  567,  567,  567,  567,  567,  567,\n      439,  439,  624,  439,  439,  439,  439,  439,  439,  439,\n      616,  617,  439,  623,  616,  617,  685,  686,  685,  686,\n      756,  628,  626,  632,  708,  755,  634,  685,  686,  302,\n      302,  627,  629,  754,  753,  630,  631,  633,  752,  751,\n      750,  709,  669,   52,   52,   52,   52,   52,   52,   52,\n       52,   52,   52,   52,   52,   52,   52,   52,   52,   69,\n       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,\n       69,   69,   69,   69,   69,   72,   72,   72,   72,   72,\n\n       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,\n       72,   76,   76,   76,   76,   76,   76,   76,   76,   76,\n       76,   76,   76,   76,   76,   76,   76,   86,   86,   86,\n       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,\n       86,   86,   86,   40,   40,   40,   40,   40,   40,   40,\n       40,   40,   40,   40,   40,   40,   40,   40,   40,   95,\n       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,\n       95,   95,   95,   95,   95,  101,  101,  101,  101,  101,\n      101,  101,  101,  101,  101,  101,  101,  101,  101,  101,\n      101,  106,  106,  106,  106,  106,  106,  106,  106,  106,\n\n      106,  106,  106,  106,  106,  106,  106,  110,  110,  110,\n      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,\n      110,  110,  110,  128,  128,  128,  128,  128,  128,  128,\n      128,  128,  128,  128,  128,  128,  128,  128,  128,  131,\n      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,\n      131,  131,  131,  131,  131,  135,  135,  135,  135,  135,\n      135,  135,  135,  135,  135,  135,  135,  135,  135,  135,\n      135,  177,  177,  177,  177,  177,  177,  177,  177,  177,\n      177,  177,  177,  177,  177,  177,  177,  184,  184,  184,\n      184,  749,  748,  184,  184,  184,  190,  190,  190,  190,\n\n      190,  190,  190,  190,  190,  190,  190,  190,  190,  190,\n      190,  200,  200,  200,  200,  747,  746,  200,  200,  200,\n      209,  745,  209,  209,  209,  209,  209,  209,  209,  209,\n      209,  209,  209,  209,  209,  209,  212,  744,  212,  212,\n      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,\n      212,  212,  216,  216,  216,  743,  742,  216,  216,  216,\n      227,  741,  227,  227,  227,  227,  227,  227,  227,  227,\n      227,  227,  227,  227,  227,  227,  229,  740,  229,  229,\n      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,\n      229,  229,  230,  739,  230,  230,  230,  230,  230,  230,\n\n      230,  230,  230,  230,  230,  230,  230,  230,  234,  234,\n      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,\n      234,  234,  234,  234,  236,  738,  236,  236,  737,  236,\n      236,  236,  736,  735,  236,  236,  734,  733,  732,  236,\n      238,  238,  238,  238,  731,  730,  238,  238,  238,  242,\n      729,  242,  242,  242,  242,  242,  242,  242,  242,  242,\n      242,  242,  242,  242,  242,  246,  246,  246,  246,  728,\n      727,  246,  246,  246,  251,  726,  251,  251,  251,  251,\n      251,  251,  251,  251,  251,  251,  251,  251,  251,  251,\n      254,  725,  254,  254,  254,  254,  254,  254,  254,  254,\n\n      254,  724,  254,  254,  254,  254,  255,  723,  720,  719,\n      255,  255,  255,  255,  718,  717,  255,  255,  257,  716,\n      257,  257,  257,  257,  257,  257,  257,  257,  257,  257,\n      257,  257,  257,  257,  261,  261,  261,  261,  715,  714,\n      261,  261,  261,  264,  264,  264,  264,  264,  264,  264,\n      264,  264,  264,  264,  264,  264,  264,  264,  264,  267,\n      267,  267,  267,  713,  267,  267,  267,  267,  267,  267,\n      267,  267,  267,  267,  267,  271,  712,  711,  271,  271,\n      271,  271,  271,  271,  271,  710,  271,  271,  271,  271,\n      271,  273,  707,  273,  273,  273,  273,  273,  273,  273,\n\n      273,  273,  273,  273,  273,  273,  273,  274,  706,  274,\n      274,  705,  274,  274,  274,  704,  703,  274,  274,  702,\n      701,  700,  274,  279,  279,  279,  279,  699,  698,  279,\n      279,  279,  284,  697,  284,  284,  284,  284,  284,  284,\n      284,  284,  284,  284,  284,  284,  284,  284,  288,  288,\n      696,  288,  288,  695,  694,  693,  288,  288,  315,  692,\n      315,  315,  315,  315,  315,  315,  315,  315,  315,  315,\n      315,  315,  315,  315,  319,  691,  319,  319,  319,  319,\n      319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n      320,  690,  320,  320,  320,  320,  320,  320,  320,  320,\n\n      320,  320,  320,  320,  320,  320,  328,  328,  689,  688,\n      328,  328,  328,  329,  329,  687,  683,  329,  329,  329,\n      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,\n      330,  330,  330,  330,  330,  330,  334,  334,  334,  334,\n      334,  334,  334,  334,  334,  334,  334,  334,  334,  334,\n      334,  334,  338,  682,  338,  338,  338,  338,  338,  338,\n      338,  338,  338,  681,  338,  338,  338,  338,  209,  680,\n      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,\n      209,  209,  209,  209,  345,  345,  679,  678,  677,  676,\n      345,  346,  346,  346,  346,  675,  674,  346,  346,  346,\n\n      346,  351,  673,  351,  351,  351,  351,  351,  351,  351,\n      351,  351,  351,  351,  351,  351,  351,  227,  672,  227,\n      227,  227,  227,  227,  227,  227,  227,  227,  227,  227,\n      227,  227,  227,  229,  671,  229,  229,  229,  229,  229,\n      229,  229,  229,  229,  229,  229,  229,  229,  229,  230,\n      670,  230,  230,  230,  230,  230,  230,  230,  230,  230,\n      230,  230,  230,  230,  230,  353,  668,  353,  353,  353,\n      353,  353,  353,  353,  353,  353,  353,  353,  353,  353,\n      353,  354,  667,  354,  354,  354,  354,  354,  354,  354,\n      354,  354,  354,  354,  354,  354,  354,  234,  234,  234,\n\n      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,\n      234,  234,  234,  236,  666,  236,  236,  665,  236,  236,\n      236,  664,  663,  236,  236,  662,  661,  660,  236,  238,\n      238,  238,  238,  659,  658,  238,  238,  238,  242,  657,\n      242,  242,  242,  242,  242,  242,  242,  242,  242,  242,\n      242,  242,  242,  242,  246,  246,  246,  246,  656,  655,\n      246,  246,  246,  361,  361,  654,  653,  652,  361,  361,\n      255,  651,  650,  649,  255,  255,  255,  255,  648,  647,\n      255,  255,  257,  646,  257,  257,  257,  257,  257,  257,\n      257,  257,  257,  257,  257,  257,  257,  257,  261,  261,\n\n      261,  261,  645,  644,  261,  261,  261,  264,  264,  264,\n      264,  264,  264,  264,  264,  264,  264,  264,  264,  264,\n      264,  264,  264,  267,  267,  267,  267,  643,  267,  267,\n      267,  267,  267,  267,  267,  267,  267,  267,  267,  271,\n      642,  641,  271,  271,  271,  271,  271,  271,  271,  640,\n      271,  271,  271,  271,  271,  274,  639,  274,  274,  638,\n      274,  274,  274,  637,  636,  274,  274,  635,  622,  621,\n      274,  279,  279,  279,  279,  620,  619,  279,  279,  279,\n      284,  618,  284,  284,  284,  284,  284,  284,  284,  284,\n      284,  284,  284,  284,  284,  284,  288,  288,  560,  288,\n\n      288,  614,  613,  612,  288,  288,  315,  611,  315,  315,\n      315,  315,  315,  315,  315,  315,  315,  315,  315,  315,\n      315,  315,  319,  610,  319,  319,  319,  319,  319,  319,\n      319,  319,  319,  319,  319,  319,  319,  319,  320,  609,\n      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,\n      320,  320,  320,  320,  415,  415,  415,  415,  415,  415,\n      415,  415,  415,  415,  415,  415,  415,  415,  415,  415,\n      424,  424,  424,  424,  608,  607,  424,  424,  424,  425,\n      425,  425,  425,  606,  605,  425,  425,  425,  330,  330,\n      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,\n\n      330,  330,  330,  330,  334,  334,  334,  334,  334,  334,\n      334,  334,  334,  334,  334,  334,  334,  334,  334,  334,\n      338,  604,  338,  338,  338,  338,  338,  338,  338,  338,\n      338,  603,  338,  338,  338,  338,  433,  433,  602,  601,\n      600,  599,  433,  346,  346,  346,  346,  598,  597,  346,\n      346,  346,  346,  351,  596,  351,  351,  351,  351,  351,\n      351,  351,  351,  351,  351,  351,  351,  351,  351,  615,\n      615,  615,  615,  615,  615,  615,  615,  615,  615,  615,\n      615,  615,  615,  615,  615,  684,  684,  684,  684,  684,\n      684,  684,  684,  684,  684,  684,  684,  684,  684,  684,\n\n      684,  595,  594,  593,  592,  589,  588,  587,  586,  585,\n      584,  571,  570,  569,  568,  565,  564,  563,  562,  561,\n      560,  559,  558,  557,  556,  555,  554,  551,  550,  549,\n      548,  547,  546,  545,  544,  543,  542,  541,  540,  539,\n      538,  537,  536,  535,  531,  530,  529,  528,  527,  526,\n      525,  524,  523,  510,  509,  508,  507,  506,  503,  499,\n      498,  497,  496,  492,  491,  490,  489,  488,  484,  483,\n      482,  479,  478,  477,  476,  475,  474,  473,  472,  471,\n      470,  469,  468,  467,  466,  465,  464,  463,  462,  461,\n      460,  459,  458,  457,  456,  455,  454,  453,  452,  451,\n\n      439,  437,  436,  435,  434,  347,  426,  423,  422,  421,\n      322,  414,  316,  408,  407,  406,  401,  400,  399,  398,\n      397,  396,  395,  394,  391,  390,  389,  386,  385,  382,\n      379,  378,  285,  282,  377,  376,  278,  373,  372,  243,\n      356,  355,  235,  231,  352,  350,  349,  348,  218,  347,\n      337,  206,  333,  202,  318,  186,  182,  316,  314,  313,\n      312,  311,  310,  309,  305,  299,  298,  295,  294,  291,\n      287,  286,  285,  283,  282,  281,  280,  260,  278,  277,\n      272,  270,  263,  262,  260,  256,  250,  253,  250,  249,\n      247,  245,  244,  243,  241,  240,  239,  237,  235,  228,\n\n      231,  228,  226,  218,  208,  202,  199,  186,  182,  768,\n       94,   94,   85,   77,   77,   39,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768\n    } ;\n\nstatic yyconst short int yy_chk[2775] =\n    {   0,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,\n        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n\n        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,\n      765,    3,    5,    5,    3,    3,    3,   27,   27,    3,\n        6,    6,    6,   28,   28,    3,    6,   11,   11,   11,\n        3,    3,   12,   12,   12,   48,   17,   17,   66,   29,\n       29,   60,   60,   18,   18,  310,   17,   29,  310,   17,\n       17,   17,   17,   18,   61,   61,   18,   18,   18,   18,\n        3,    3,    3,    4,    4,    4,    4,  109,    4,    4,\n       21,    4,    4,    4,  511,   48,    4,   19,   19,   19,\n       22,  109,    4,   20,   20,   20,   66,    4,    4,  141,\n\n        4,   17,   61,   21,   21,  141,   21,   37,   18,   37,\n       75,   19,   75,   22,   22,  511,   22,   20,   30,   30,\n       37,   37,   37,   37,  128,  128,   30,    4,    4,    4,\n        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,\n        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,\n        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,\n        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,\n        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,\n        9,    9,    9,    9,    9,    9,    9,    9,   13,   13,\n       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,\n\n       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,\n       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,\n       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,\n       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,\n       13,   13,   13,   13,   13,   13,   23,   23,  163,   24,\n       24,   38,  764,   38,   41,   41,   41,   23,  130,  130,\n       24,   45,   45,   45,   38,   38,   38,   38,  163,   23,\n       23,   23,   24,   24,   24,   25,   25,   25,   25,   25,\n       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,\n       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,\n\n       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,\n       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,\n       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,\n       25,   25,   25,   31,   31,   31,   32,   32,   32,   57,\n       57,   57,   62,   62,   62,   62,   99,   99,   99,   99,\n      131,  131,  133,  133,  167,  198,  198,   31,  167,  763,\n       32,   33,   33,   33,   33,   33,   33,   33,   33,   33,\n       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,\n       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,\n       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,\n\n       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,\n       33,   33,   33,   33,   33,   33,   33,   33,   33,   35,\n       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,\n       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,\n       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,\n       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,\n       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,\n       35,   35,   35,   35,   35,   35,   35,   49,   53,   53,\n       53,  121,  105,  105,   53,  158,  108,  108,  115,  115,\n      160,  158,   63,   63,   63,  291,  168,  275,   63,  121,\n\n       49,  188,   49,  275,   49,   63,  168,  205,  205,  160,\n       49,   63,  291,   49,   49,   49,  405,   49,   49,   63,\n      105,  170,  405,   49,  108,   49,  115,  180,  180,  180,\n      180,  170,  762,   53,  170,  181,  181,  181,  185,  185,\n      185,  188,  192,  192,  192,  209,  209,   63,  193,  193,\n      193,  294,  194,  194,  194,  294,  192,  192,  192,  192,\n      211,  211,  193,  193,  193,  193,  194,  194,  194,  194,\n      195,  195,  195,  201,  201,  201,  210,  213,  213,  201,\n      289,  257,  210,  210,  195,  195,  195,  195,  192,  217,\n      217,  217,  264,  264,  289,  217,  194,  362,  211,  257,\n\n      266,  266,  217,  248,  248,  248,  248,  761,  217,  267,\n      267,  269,  269,  195,  298,  309,  217,  314,  298,  362,\n      314,  321,  321,  321,  309,  330,  330,  760,  201,  314,\n      314,  317,  317,  317,  317,  321,  321,  321,  321,  708,\n      314,  332,  332,  708,  217,  241,  241,  241,  241,  241,\n      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,\n      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,\n      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,\n      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,\n      241,  241,  241,  241,  241,  241,  241,  241,  241,  241,\n\n      241,  241,  241,  250,  250,  250,  250,  334,  334,  250,\n      336,  336,  338,  338,  250,  344,  344,  757,  250,  415,\n      415,  250,  756,  250,  418,  418,  250,  278,  278,  755,\n      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,\n      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,\n      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,\n      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,\n      278,  278,  278,  278,  278,  278,  278,  278,  278,  278,\n      278,  278,  278,  278,  278,  324,  324,  324,  339,  363,\n      364,  340,  340,  365,  339,  339,  342,  342,  366,  324,\n\n      324,  324,  324,  340,  371,  409,  342,  342,  409,  409,\n      441,  363,  365,  444,  364,  420,  420,  420,  371,  485,\n      754,  441,  494,  494,  444,  485,  366,  504,  504,  340,\n      341,  341,  367,  341,  341,  341,  341,  341,  341,  341,\n      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,\n      341,  341,  341,  341,  341,  341,  341,  367,  341,  341,\n      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,\n      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,\n      341,  341,  341,  341,  341,  341,  341,  341,  343,  343,\n      343,  343,  752,  369,  505,  505,  343,  750,  343,  343,\n\n      495,  495,  495,  343,  343,  343,  343,  343,  343,  360,\n      360,  368,  360,  360,  360,  360,  360,  360,  360,  369,\n      360,  360,  360,  360,  360,  360,  360,  360,  360,  360,\n      360,  360,  370,  442,  360,  360,  360,  360,  443,  368,\n      428,  428,  368,  431,  431,  416,  416,  416,  561,  561,\n      428,  428,  749,  431,  431,  443,  519,  445,  370,  416,\n      416,  416,  416,  442,  360,  360,  360,  375,  375,  519,\n      375,  375,  375,  375,  375,  375,  375,  440,  375,  375,\n      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,\n      445,  447,  375,  375,  375,  375,  419,  419,  419,  446,\n\n      450,  440,  449,  440,  520,  448,  503,  503,  503,  512,\n      419,  419,  419,  419,  517,  447,  448,  520,  446,  450,\n      501,  501,  375,  375,  375,  427,  427,  512,  449,  517,\n      501,  501,  427,  427,  427,  427,  427,  427,  427,  427,\n      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,\n      427,  427,  427,  427,  427,  427,  427,  429,  429,  429,\n      429,  462,  514,  513,  518,  429,  515,  566,  566,  521,\n      567,  567,  429,  429,  429,  429,  429,  429,  432,  432,\n      432,  432,  516,  462,  521,  515,  432,  513,  518,  462,\n      514,  574,  522,  432,  432,  432,  432,  432,  432,  502,\n\n      502,  502,  502,  532,  565,  565,  565,  502,  516,  522,\n      572,  573,  574,  532,  502,  502,  502,  502,  502,  502,\n      575,  576,  573,  577,  578,  579,  580,  583,  581,  582,\n      615,  615,  634,  572,  617,  617,  656,  656,  684,  684,\n      748,  577,  575,  581,  681,  747,  583,  686,  686,  810,\n      810,  576,  578,  745,  744,  579,  580,  582,  743,  742,\n      740,  681,  634,  769,  769,  769,  769,  769,  769,  769,\n      769,  769,  769,  769,  769,  769,  769,  769,  769,  770,\n      770,  770,  770,  770,  770,  770,  770,  770,  770,  770,\n      770,  770,  770,  770,  770,  771,  771,  771,  771,  771,\n\n      771,  771,  771,  771,  771,  771,  771,  771,  771,  771,\n      771,  772,  772,  772,  772,  772,  772,  772,  772,  772,\n      772,  772,  772,  772,  772,  772,  772,  773,  773,  773,\n      773,  773,  773,  773,  773,  773,  773,  773,  773,  773,\n      773,  773,  773,  774,  774,  774,  774,  774,  774,  774,\n      774,  774,  774,  774,  774,  774,  774,  774,  774,  775,\n      775,  775,  775,  775,  775,  775,  775,  775,  775,  775,\n      775,  775,  775,  775,  775,  776,  776,  776,  776,  776,\n      776,  776,  776,  776,  776,  776,  776,  776,  776,  776,\n      776,  777,  777,  777,  777,  777,  777,  777,  777,  777,\n\n      777,  777,  777,  777,  777,  777,  777,  778,  778,  778,\n      778,  778,  778,  778,  778,  778,  778,  778,  778,  778,\n      778,  778,  778,  779,  779,  779,  779,  779,  779,  779,\n      779,  779,  779,  779,  779,  779,  779,  779,  779,  780,\n      780,  780,  780,  780,  780,  780,  780,  780,  780,  780,\n      780,  780,  780,  780,  780,  781,  781,  781,  781,  781,\n      781,  781,  781,  781,  781,  781,  781,  781,  781,  781,\n      781,  782,  782,  782,  782,  782,  782,  782,  782,  782,\n      782,  782,  782,  782,  782,  782,  782,  783,  783,  783,\n      783,  739,  738,  783,  783,  783,  784,  784,  784,  784,\n\n      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,\n      784,  785,  785,  785,  785,  737,  736,  785,  785,  785,\n      786,  735,  786,  786,  786,  786,  786,  786,  786,  786,\n      786,  786,  786,  786,  786,  786,  787,  734,  787,  787,\n      787,  787,  787,  787,  787,  787,  787,  787,  787,  787,\n      787,  787,  788,  788,  788,  733,  732,  788,  788,  788,\n      789,  731,  789,  789,  789,  789,  789,  789,  789,  789,\n      789,  789,  789,  789,  789,  789,  790,  729,  790,  790,\n      790,  790,  790,  790,  790,  790,  790,  790,  790,  790,\n      790,  790,  791,  727,  791,  791,  791,  791,  791,  791,\n\n      791,  791,  791,  791,  791,  791,  791,  791,  792,  792,\n      792,  792,  792,  792,  792,  792,  792,  792,  792,  792,\n      792,  792,  792,  792,  793,  726,  793,  793,  725,  793,\n      793,  793,  724,  723,  793,  793,  722,  721,  720,  793,\n      794,  794,  794,  794,  719,  718,  794,  794,  794,  795,\n      717,  795,  795,  795,  795,  795,  795,  795,  795,  795,\n      795,  795,  795,  795,  795,  796,  796,  796,  796,  715,\n      714,  796,  796,  796,  797,  713,  797,  797,  797,  797,\n      797,  797,  797,  797,  797,  797,  797,  797,  797,  797,\n      798,  712,  798,  798,  798,  798,  798,  798,  798,  798,\n\n      798,  710,  798,  798,  798,  798,  799,  709,  707,  706,\n      799,  799,  799,  799,  705,  704,  799,  799,  800,  703,\n      800,  800,  800,  800,  800,  800,  800,  800,  800,  800,\n      800,  800,  800,  800,  801,  801,  801,  801,  702,  701,\n      801,  801,  801,  802,  802,  802,  802,  802,  802,  802,\n      802,  802,  802,  802,  802,  802,  802,  802,  802,  803,\n      803,  803,  803,  700,  803,  803,  803,  803,  803,  803,\n      803,  803,  803,  803,  803,  804,  699,  698,  804,  804,\n      804,  804,  804,  804,  804,  682,  804,  804,  804,  804,\n      804,  805,  680,  805,  805,  805,  805,  805,  805,  805,\n\n      805,  805,  805,  805,  805,  805,  805,  806,  679,  806,\n      806,  678,  806,  806,  806,  677,  675,  806,  806,  674,\n      672,  671,  806,  807,  807,  807,  807,  670,  669,  807,\n      807,  807,  808,  668,  808,  808,  808,  808,  808,  808,\n      808,  808,  808,  808,  808,  808,  808,  808,  809,  809,\n      667,  809,  809,  666,  665,  664,  809,  809,  811,  663,\n      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,\n      811,  811,  811,  811,  812,  662,  812,  812,  812,  812,\n      812,  812,  812,  812,  812,  812,  812,  812,  812,  812,\n      813,  661,  813,  813,  813,  813,  813,  813,  813,  813,\n\n      813,  813,  813,  813,  813,  813,  814,  814,  660,  659,\n      814,  814,  814,  815,  815,  658,  655,  815,  815,  815,\n      816,  816,  816,  816,  816,  816,  816,  816,  816,  816,\n      816,  816,  816,  816,  816,  816,  817,  817,  817,  817,\n      817,  817,  817,  817,  817,  817,  817,  817,  817,  817,\n      817,  817,  818,  653,  818,  818,  818,  818,  818,  818,\n      818,  818,  818,  652,  818,  818,  818,  818,  819,  651,\n      819,  819,  819,  819,  819,  819,  819,  819,  819,  819,\n      819,  819,  819,  819,  820,  820,  650,  646,  644,  643,\n      820,  821,  821,  821,  821,  642,  641,  821,  821,  821,\n\n      821,  822,  639,  822,  822,  822,  822,  822,  822,  822,\n      822,  822,  822,  822,  822,  822,  822,  823,  637,  823,\n      823,  823,  823,  823,  823,  823,  823,  823,  823,  823,\n      823,  823,  823,  824,  636,  824,  824,  824,  824,  824,\n      824,  824,  824,  824,  824,  824,  824,  824,  824,  825,\n      635,  825,  825,  825,  825,  825,  825,  825,  825,  825,\n      825,  825,  825,  825,  825,  826,  633,  826,  826,  826,\n      826,  826,  826,  826,  826,  826,  826,  826,  826,  826,\n      826,  827,  632,  827,  827,  827,  827,  827,  827,  827,\n      827,  827,  827,  827,  827,  827,  827,  828,  828,  828,\n\n      828,  828,  828,  828,  828,  828,  828,  828,  828,  828,\n      828,  828,  828,  829,  631,  829,  829,  630,  829,  829,\n      829,  629,  628,  829,  829,  627,  626,  625,  829,  830,\n      830,  830,  830,  624,  623,  830,  830,  830,  831,  621,\n      831,  831,  831,  831,  831,  831,  831,  831,  831,  831,\n      831,  831,  831,  831,  832,  832,  832,  832,  619,  612,\n      832,  832,  832,  833,  833,  611,  610,  609,  833,  833,\n      834,  608,  607,  606,  834,  834,  834,  834,  604,  601,\n      834,  834,  835,  600,  835,  835,  835,  835,  835,  835,\n      835,  835,  835,  835,  835,  835,  835,  835,  836,  836,\n\n      836,  836,  599,  598,  836,  836,  836,  837,  837,  837,\n      837,  837,  837,  837,  837,  837,  837,  837,  837,  837,\n      837,  837,  837,  838,  838,  838,  838,  597,  838,  838,\n      838,  838,  838,  838,  838,  838,  838,  838,  838,  839,\n      596,  595,  839,  839,  839,  839,  839,  839,  839,  594,\n      839,  839,  839,  839,  839,  840,  593,  840,  840,  592,\n      840,  840,  840,  591,  590,  840,  840,  588,  569,  568,\n      840,  841,  841,  841,  841,  564,  563,  841,  841,  841,\n      842,  562,  842,  842,  842,  842,  842,  842,  842,  842,\n      842,  842,  842,  842,  842,  842,  843,  843,  560,  843,\n\n      843,  559,  558,  557,  843,  843,  844,  556,  844,  844,\n      844,  844,  844,  844,  844,  844,  844,  844,  844,  844,\n      844,  844,  845,  555,  845,  845,  845,  845,  845,  845,\n      845,  845,  845,  845,  845,  845,  845,  845,  846,  554,\n      846,  846,  846,  846,  846,  846,  846,  846,  846,  846,\n      846,  846,  846,  846,  847,  847,  847,  847,  847,  847,\n      847,  847,  847,  847,  847,  847,  847,  847,  847,  847,\n      848,  848,  848,  848,  553,  552,  848,  848,  848,  849,\n      849,  849,  849,  551,  549,  849,  849,  849,  850,  850,\n      850,  850,  850,  850,  850,  850,  850,  850,  850,  850,\n\n      850,  850,  850,  850,  851,  851,  851,  851,  851,  851,\n      851,  851,  851,  851,  851,  851,  851,  851,  851,  851,\n      852,  548,  852,  852,  852,  852,  852,  852,  852,  852,\n      852,  546,  852,  852,  852,  852,  853,  853,  545,  544,\n      543,  542,  853,  854,  854,  854,  854,  541,  540,  854,\n      854,  854,  854,  855,  539,  855,  855,  855,  855,  855,\n      855,  855,  855,  855,  855,  855,  855,  855,  855,  856,\n      856,  856,  856,  856,  856,  856,  856,  856,  856,  856,\n      856,  856,  856,  856,  856,  857,  857,  857,  857,  857,\n      857,  857,  857,  857,  857,  857,  857,  857,  857,  857,\n\n      857,  538,  536,  534,  533,  530,  528,  526,  525,  524,\n      523,  509,  508,  507,  506,  500,  499,  498,  497,  496,\n      492,  491,  490,  489,  488,  487,  486,  483,  482,  481,\n      480,  479,  478,  476,  475,  474,  473,  472,  471,  469,\n      468,  467,  464,  463,  461,  460,  459,  458,  457,  454,\n      453,  452,  451,  439,  437,  436,  435,  434,  430,  426,\n      423,  422,  421,  414,  413,  412,  411,  410,  408,  407,\n      406,  404,  403,  402,  401,  400,  399,  398,  397,  396,\n      395,  394,  393,  392,  391,  390,  388,  387,  386,  384,\n      383,  382,  381,  380,  379,  378,  377,  376,  373,  372,\n\n      361,  356,  355,  352,  350,  346,  337,  327,  326,  325,\n      323,  318,  315,  313,  312,  311,  308,  307,  306,  305,\n      303,  301,  300,  299,  297,  296,  295,  293,  292,  290,\n      287,  286,  284,  282,  281,  280,  276,  263,  262,  243,\n      240,  239,  234,  231,  226,  222,  221,  220,  219,  216,\n      208,  207,  204,  203,  189,  187,  183,  179,  176,  175,\n      174,  173,  172,  171,  169,  166,  165,  162,  161,  159,\n      156,  155,  154,  153,  151,  149,  148,  146,  144,  143,\n      137,  134,  125,  124,  122,  119,  114,  112,  107,  103,\n       97,   92,   89,   87,   85,   84,   83,   80,   76,   74,\n\n       73,   71,   67,   65,   59,   55,   50,   47,   43,   39,\n       16,   15,   10,    8,    7,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768,  768,  768,  768,  768,  768,  768,\n      768,  768,  768,  768\n    } ;\n\nstatic yy_state_type yy_last_accepting_state;\nstatic char *yy_last_accepting_cpos;\n\n/* The intent behind this definition is that it'll catch\n * any uses of REJECT which flex missed.\n */\n#define REJECT reject_used_but_not_detected\n#define yymore() yymore_used_but_not_detected\n#define YY_MORE_ADJ 0\n#define YY_RESTORE_YY_MORE_OFFSET\nchar *yytext;\n#define INITIAL 0\n/* scan.l - scanner for flex input */\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Vern Paxson.\n * \n * The United States Government has rights in this work pursuant\n * to contract no. DE-AC03-76SF00098 between the United States\n * Department of Energy and the University of California.\n *\n * Redistribution and use in source and binary forms with or without\n * modification are permitted provided that: (1) source distributions retain\n * this entire copyright notice and comment, and (2) distributions including\n * binaries display the following acknowledgement:  ``This product includes\n * software developed by the University of California, Berkeley and its\n * contributors'' in the documentation or other materials provided with the\n * distribution and in all advertising materials mentioning features or use\n * of this software.  Neither the name of the University nor the names of\n * its contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* $Header: /a1/cvsadm/cvsroot/expsir/csubjects/flex/versions.alt/versions.orig/v5/flex.c,v 1.1.1.2 2003/09/02 20:21:58 expsir Exp $ */\n\n\n#define ACTION_ECHO add_action( yytext )\n#define ACTION_IFDEF(def, should_define) \\\n\t{ \\\n\tif ( should_define ) \\\n\t\taction_define( def, 1 ); \\\n\t}\n\n#define MARK_END_OF_PROLOG mark_prolog();\n\n#define YY_DECL \\\n\tint flexscan()\n\n#define RETURNCHAR \\\n\tyylval = (unsigned char) yytext[0]; \\\n\treturn CHAR;\n\n#define RETURNNAME \\\n\tstrcpy( nmstr, yytext ); \\\n\treturn NAME;\n\n#define PUT_BACK_STRING(str, start) \\\n\tfor ( i = strlen( str ) - 1; i >= start; --i ) \\\n\t\tunput((str)[i])\n\n#define CHECK_REJECT(str) \\\n\tif ( all_upper( str ) ) \\\n\t\treject = true;\n\n#define CHECK_YYMORE(str) \\\n\tif ( all_lower( str ) ) \\\n\t\tyymore_used = true;\n#define YY_STACK_USED 1\n#define YY_NO_TOP_STATE 1\n#define SECT2 1\n#define SECT2PROLOG 2\n#define SECT3 3\n#define CODEBLOCK 4\n#define PICKUPDEF 5\n#define SC 6\n#define CARETISBOL 7\n#define NUM 8\n#define QUOTE 9\n\n#define FIRSTCCL 10\n#define CCL 11\n#define ACTION 12\n#define RECOVER 13\n#define COMMENT 14\n#define ACTION_STRING 15\n#define PERCENT_BRACE_ACTION 16\n\n#define OPTION 17\n#define LINEDIR 18\n\n\n/* Macros after this point can all be overridden by user definitions in\n * section 1.\n */\n\n#ifndef YY_SKIP_YYWRAP\n#ifdef __cplusplus\nextern \"C\" int yywrap YY_PROTO(( void ));\n#else\nextern int yywrap YY_PROTO(( void ));\n#endif\n#endif\n\n#ifndef YY_NO_UNPUT\nstatic void yyunput YY_PROTO(( int c, char *buf_ptr ));\n#endif\n\n#ifndef yytext_ptr\nstatic void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));\n#endif\n\n#ifdef YY_NEED_STRLEN\nstatic int yy_flex_strlen YY_PROTO(( yyconst char * ));\n#endif\n\n#ifndef YY_NO_INPUT\n#ifdef __cplusplus\nstatic int yyinput YY_PROTO(( void ));\n#else\nstatic int input YY_PROTO(( void ));\n#endif\n#endif\n\n#if YY_STACK_USED\nstatic int yy_start_stack_ptr = 0;\nstatic int yy_start_stack_depth = 0;\nstatic int *yy_start_stack = 0;\n#ifndef YY_NO_PUSH_STATE\nstatic void yy_push_state YY_PROTO(( int new_state ));\n#endif\n#ifndef YY_NO_POP_STATE\nstatic void yy_pop_state YY_PROTO(( void ));\n#endif\n#ifndef YY_NO_TOP_STATE\nstatic int yy_top_state YY_PROTO(( void ));\n#endif\n\n#else\n#define YY_NO_PUSH_STATE 1\n#define YY_NO_POP_STATE 1\n#define YY_NO_TOP_STATE 1\n#endif\n\n#ifdef YY_MALLOC_DECL\nYY_MALLOC_DECL\n#else\n#if __STDC__\n#ifndef __cplusplus\n#include <stdlib.h>\n#endif\n#else\n/* Just try to get by without declaring the routines.  This will fail\n * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)\n * or sizeof(void*) != sizeof(int).\n */\n#endif\n#endif\n\n/* Amount of stuff to slurp up with each read. */\n#ifndef YY_READ_BUF_SIZE\n#define YY_READ_BUF_SIZE 8192\n#endif\n\n/* Copy whatever the last rule matched to the standard output. */\n\n#ifndef ECHO\n/* This used to be an fputs(), but since the string might contain NUL's,\n * we now use fwrite().\n */\n#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )\n#endif\n\n/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n * is returned in \"result\".\n */\n#ifndef YY_INPUT\n#define YY_INPUT(buf,result,max_size) \\\n\tif ( yy_current_buffer->yy_is_interactive ) \\\n\t\t{ \\\n\t\tint c = '*', n; \\\n\t\tfor ( n = 0; n < max_size && \\\n\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\\n\t\t\tbuf[n] = (char) c; \\\n\t\tif ( c == '\\n' ) \\\n\t\t\tbuf[n++] = (char) c; \\\n\t\tif ( c == EOF && ferror( yyin ) ) \\\n\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n\t\tresult = n; \\\n\t\t} \\\n\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\\n\t\t  && ferror( yyin ) ) \\\n\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n#endif\n\n/* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n * we don't want an extra ';' after the \"return\" because that will cause\n * some compilers to complain about unreachable statements.\n */\n#ifndef yyterminate\n#define yyterminate() return YY_NULL\n#endif\n\n/* Number of entries by which start-condition stack grows. */\n#ifndef YY_START_STACK_INCR\n#define YY_START_STACK_INCR 25\n#endif\n\n/* Report a fatal error. */\n#ifndef YY_FATAL_ERROR\n#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )\n#endif\n\n/* Default declaration of generated scanner - a define so the user can\n * easily add parameters.\n */\n#ifndef YY_DECL\n#define YY_DECL int yylex YY_PROTO(( void ))\n#endif\n\n/* Code executed at the beginning of each rule, after yytext and yyleng\n * have been set up.\n */\n#ifndef YY_USER_ACTION\n#define YY_USER_ACTION\n#endif\n\n/* Code executed at the end of each rule. */\n#ifndef YY_BREAK\n#define YY_BREAK break;\n#endif\n\n#define YY_RULE_SETUP \\\n\tif ( yyleng > 0 ) \\\n\t\tyy_current_buffer->yy_at_bol = \\\n\t\t\t\t(yytext[yyleng - 1] == '\\n'); \\\n\tYY_USER_ACTION\n\nYY_DECL\n\t{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp, *yy_bp;\n\tregister int yy_act;\n\n\n\tstatic int bracelevel, didadef, indented_code;\n\tstatic int doing_rule_action = false;\n\tstatic int option_sense;\n\n\tint doing_codeblock = false;\n\tint i;\n\tChar nmdef[MAXLINE], myesc();\n\n\n\n\tif ( yy_init )\n\t\t{\n\t\tyy_init = 0;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yy_start )\n\t\t\tyy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! yy_current_buffer )\n\t\t\tyy_current_buffer =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE );\n\n\t\tyy_load_buffer_state();\n\t\t}\n\n\twhile ( 1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yy_start;\n\t\tyy_current_state += YY_AT_BOL();\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tregister YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyy_last_accepting_state = yy_current_state;\n\t\t\t\tyy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 769 )\n\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_base[yy_current_state] != 2716 );\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\t\tif ( yy_act == 0 )\n\t\t\t{ /* have to back up */\n\t\t\tyy_cp = yy_last_accepting_cpos;\n\t\t\tyy_current_state = yy_last_accepting_state;\n\t\t\tyy_act = yy_accept[yy_current_state];\n\t\t\t}\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yy_hold_char;\n\t\t\tyy_cp = yy_last_accepting_cpos;\n\t\t\tyy_current_state = yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\n\ncase 1:\nYY_RULE_SETUP\nindented_code = true; BEGIN(CODEBLOCK);\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\nACTION_ECHO; yy_push_state( COMMENT );\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\nyy_push_state( LINEDIR );\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\nreturn SCDECL;\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\nreturn XSCDECL;\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n{\n\t\t\t++linenum;\n\t\t\tline_directive_out( (FILE *) 0, 1 );\n\t\t\tindented_code = false;\n\t\t\tBEGIN(CODEBLOCK);\n\t\t\t}\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n/* discard */\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n{\n\t\t\tsectnum = 2;\n\t\t\tbracelevel = 0;\n\t\t\tmark_defs1();\n\t\t\tline_directive_out( (FILE *) 0, 1 );\n\t\t\tBEGIN(SECT2PROLOG);\n\t\t\treturn SECTEND;\n\t\t\t}\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\nyytext_is_array = false; ++linenum;\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\nyytext_is_array = true; ++linenum;\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\nBEGIN(OPTION); return OPTION_OP;\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n++linenum; /* ignore */\n\tYY_BREAK\ncase 13:\nYY_RULE_SETUP\n++linenum;\t/* ignore */\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\nsynerr( _( \"unrecognized '%' directive\" ) );\n\tYY_BREAK\ncase 15:\nYY_RULE_SETUP\n{\n\t\t\tstrcpy( nmstr, yytext );\n\t\t\tdidadef = false;\n\t\t\tBEGIN(PICKUPDEF);\n\t\t\t}\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\nRETURNNAME;\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n++linenum; /* allows blank lines in section 1 */\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\nACTION_ECHO; ++linenum; /* maybe end of comment line */\n\tYY_BREAK\n\n\ncase 19:\nYY_RULE_SETUP\nACTION_ECHO; yy_pop_state();\n\tYY_BREAK\ncase 20:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n++linenum; ACTION_ECHO;\n\tYY_BREAK\n\n\ncase 23:\nYY_RULE_SETUP\nyy_pop_state();\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\nlinenum = myctoi( yytext );\n\tYY_BREAK\ncase 25:\nYY_RULE_SETUP\n{\n\t\t\tflex_free( (void *) infilename );\n\t\t\tinfilename = copy_string( yytext + 1 );\n\t\t\tinfilename[strlen( infilename ) - 1] = '\\0';\n\t\t\t}\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n/* ignore spurious characters */\n\tYY_BREAK\n\n\ncase 27:\nYY_RULE_SETUP\n++linenum; BEGIN(INITIAL);\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 29:\nYY_RULE_SETUP\n{\n\t\t\t++linenum;\n\t\t\tACTION_ECHO;\n\t\t\tif ( indented_code )\n\t\t\t\tBEGIN(INITIAL);\n\t\t\t}\n\tYY_BREAK\n\n\ncase 30:\nYY_RULE_SETUP\n/* separates name and definition */\n\tYY_BREAK\ncase 31:\nYY_RULE_SETUP\n{\n\t\t\tstrcpy( (char *) nmdef, yytext );\n\n\t\t\t/* Skip trailing whitespace. */\n\t\t\tfor ( i = strlen( (char *) nmdef ) - 1;\n\t\t\t      i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\\t');\n\t\t\t      --i )\n\t\t\t\t;\n\n\t\t\tnmdef[i + 1] = '\\0';\n\n\t\t\tndinstal( nmstr, nmdef );\n\t\t\tdidadef = true;\n\t\t\t}\n\tYY_BREAK\ncase 32:\nYY_RULE_SETUP\n{\n\t\t\tif ( ! didadef )\n\t\t\t\tsynerr( _( \"incomplete name definition\" ) );\n\t\t\tBEGIN(INITIAL);\n\t\t\t++linenum;\n\t\t\t}\n\tYY_BREAK\n\n\ncase 33:\nYY_RULE_SETUP\n++linenum; BEGIN(INITIAL);\n\tYY_BREAK\ncase 34:\nYY_RULE_SETUP\noption_sense = true;\n\tYY_BREAK\ncase 35:\nYY_RULE_SETUP\nreturn '=';\n\tYY_BREAK\ncase 36:\nYY_RULE_SETUP\noption_sense = ! option_sense;\n\tYY_BREAK\ncase 37:\nYY_RULE_SETUP\ncsize = option_sense ? 128 : 256;\n\tYY_BREAK\ncase 38:\nYY_RULE_SETUP\ncsize = option_sense ? 256 : 128;\n\tYY_BREAK\ncase 39:\nYY_RULE_SETUP\nlong_align = option_sense;\n\tYY_BREAK\ncase 40:\nYY_RULE_SETUP\n{\n\t\t\taction_define( \"YY_ALWAYS_INTERACTIVE\", option_sense );\n\t\t\t}\n\tYY_BREAK\ncase 41:\nYY_RULE_SETUP\nyytext_is_array = option_sense;\n\tYY_BREAK\ncase 42:\nYY_RULE_SETUP\nbacking_up_report = option_sense;\n\tYY_BREAK\ncase 43:\nYY_RULE_SETUP\ninteractive = ! option_sense;\n\tYY_BREAK\ncase 44:\nYY_RULE_SETUP\nC_plus_plus = option_sense;\n\tYY_BREAK\ncase 45:\nYY_RULE_SETUP\ncaseins = ! option_sense;\n\tYY_BREAK\ncase 46:\nYY_RULE_SETUP\ncaseins = option_sense;\n\tYY_BREAK\ncase 47:\nYY_RULE_SETUP\nddebug = option_sense;\n\tYY_BREAK\ncase 48:\nYY_RULE_SETUP\nspprdflt = ! option_sense;\n\tYY_BREAK\ncase 49:\nYY_RULE_SETUP\nuseecs = option_sense;\n\tYY_BREAK\ncase 50:\nYY_RULE_SETUP\n{\n\t\t\tuseecs = usemecs = false;\n\t\t\tuse_read = fullspd = true;\n\t\t\t}\n\tYY_BREAK\ncase 51:\nYY_RULE_SETUP\n{\n\t\t\tuseecs = usemecs = false;\n\t\t\tuse_read = fulltbl = true;\n\t\t\t}\n\tYY_BREAK\ncase 52:\nYY_RULE_SETUP\nACTION_IFDEF(\"YY_NO_INPUT\", ! option_sense);\n\tYY_BREAK\ncase 53:\nYY_RULE_SETUP\ninteractive = option_sense;\n\tYY_BREAK\ncase 54:\nYY_RULE_SETUP\nlex_compat = option_sense;\n\tYY_BREAK\ncase 55:\nYY_RULE_SETUP\n{\n\t\t\taction_define( \"YY_MAIN\", option_sense );\n\t\t\tdo_yywrap = ! option_sense;\n\t\t\t}\n\tYY_BREAK\ncase 56:\nYY_RULE_SETUP\nusemecs = option_sense;\n\tYY_BREAK\ncase 57:\nYY_RULE_SETUP\n{\n\t\t\taction_define( \"YY_NEVER_INTERACTIVE\", option_sense );\n\t\t\t}\n\tYY_BREAK\ncase 58:\nYY_RULE_SETUP\nperformance_report += option_sense ? 1 : -1;\n\tYY_BREAK\ncase 59:\nYY_RULE_SETUP\nyytext_is_array = ! option_sense;\n\tYY_BREAK\ncase 60:\nYY_RULE_SETUP\nuse_read = option_sense;\n\tYY_BREAK\ncase 61:\nYY_RULE_SETUP\nreject_really_used = option_sense;\n\tYY_BREAK\ncase 62:\nYY_RULE_SETUP\naction_define( \"YY_STACK_USED\", option_sense );\n\tYY_BREAK\ncase 63:\nYY_RULE_SETUP\ndo_stdinit = option_sense;\n\tYY_BREAK\ncase 64:\nYY_RULE_SETUP\nuse_stdout = option_sense;\n\tYY_BREAK\ncase 65:\nYY_RULE_SETUP\nACTION_IFDEF(\"YY_NO_UNPUT\", ! option_sense);\n\tYY_BREAK\ncase 66:\nYY_RULE_SETUP\nprintstats = option_sense;\n\tYY_BREAK\ncase 67:\nYY_RULE_SETUP\nnowarn = ! option_sense;\n\tYY_BREAK\ncase 68:\nYY_RULE_SETUP\ndo_yylineno = option_sense;\n\tYY_BREAK\ncase 69:\nYY_RULE_SETUP\nyymore_really_used = option_sense;\n\tYY_BREAK\ncase 70:\nYY_RULE_SETUP\ndo_yywrap = option_sense;\n\tYY_BREAK\ncase 71:\nYY_RULE_SETUP\nACTION_IFDEF(\"YY_NO_PUSH_STATE\", ! option_sense);\n\tYY_BREAK\ncase 72:\nYY_RULE_SETUP\nACTION_IFDEF(\"YY_NO_POP_STATE\", ! option_sense);\n\tYY_BREAK\ncase 73:\nYY_RULE_SETUP\nACTION_IFDEF(\"YY_NO_TOP_STATE\", ! option_sense);\n\tYY_BREAK\ncase 74:\nYY_RULE_SETUP\nACTION_IFDEF(\"YY_NO_SCAN_BUFFER\", ! option_sense);\n\tYY_BREAK\ncase 75:\nYY_RULE_SETUP\nACTION_IFDEF(\"YY_NO_SCAN_BYTES\", ! option_sense);\n\tYY_BREAK\ncase 76:\nYY_RULE_SETUP\nACTION_IFDEF(\"YY_NO_SCAN_STRING\", ! option_sense);\n\tYY_BREAK\ncase 77:\nYY_RULE_SETUP\nreturn OPT_OUTFILE;\n\tYY_BREAK\ncase 78:\nYY_RULE_SETUP\nreturn OPT_PREFIX;\n\tYY_BREAK\ncase 79:\nYY_RULE_SETUP\nreturn OPT_YYCLASS;\n\tYY_BREAK\ncase 80:\nYY_RULE_SETUP\n{\n\t\t\tstrcpy( nmstr, yytext + 1 );\n\t\t\tnmstr[strlen( nmstr ) - 1] = '\\0';\n\t\t\treturn NAME;\n\t\t\t}\n\tYY_BREAK\ncase 81:\nYY_RULE_SETUP\n{\n\t\t\tformat_synerr( _( \"unrecognized %%option: %s\" ),\n\t\t\t\tyytext );\n\t\t\tBEGIN(RECOVER);\n\t\t\t}\n\tYY_BREAK\n\ncase 82:\nYY_RULE_SETUP\n++linenum; BEGIN(INITIAL);\n\tYY_BREAK\n\ncase 83:\nYY_RULE_SETUP\n++bracelevel; yyless( 2 );\t/* eat only %{ */\n\tYY_BREAK\ncase 84:\nYY_RULE_SETUP\n--bracelevel; yyless( 2 );\t/* eat only %} */\n\tYY_BREAK\ncase 85:\nYY_RULE_SETUP\nACTION_ECHO;\t/* indented code in prolog */\n\tYY_BREAK\ncase 86:\nYY_RULE_SETUP\n{\t/* non-indented code */\n\t\t\tif ( bracelevel <= 0 )\n\t\t\t\t{ /* not in %{ ... %} */\n\t\t\t\tyyless( 0 );\t/* put it all back */\n\t\t\t\tyy_set_bol( 1 );\n\t\t\t\tmark_prolog();\n\t\t\t\tBEGIN(SECT2);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tACTION_ECHO;\n\t\t\t}\n\tYY_BREAK\ncase 87:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 88:\nYY_RULE_SETUP\n++linenum; ACTION_ECHO;\n\tYY_BREAK\ncase YY_STATE_EOF(SECT2PROLOG):\n{\n\t\t\tmark_prolog();\n\t\t\tsectnum = 0;\n\t\t\tyyterminate(); /* to stop the parser */\n\t\t\t}\n\tYY_BREAK\n\n\ncase 89:\nYY_RULE_SETUP\n++linenum; /* allow blank lines in section 2 */\n\tYY_BREAK\ncase 90:\nYY_RULE_SETUP\n{\n\t\t\tindented_code = false;\n\t\t\tdoing_codeblock = true;\n\t\t\tbracelevel = 1;\n\t\t\tBEGIN(PERCENT_BRACE_ACTION);\n\t\t\t}\n\tYY_BREAK\ncase 91:\nYY_RULE_SETUP\nBEGIN(SC); return '<';\n\tYY_BREAK\ncase 92:\nYY_RULE_SETUP\nreturn '^';\n\tYY_BREAK\ncase 93:\nYY_RULE_SETUP\nBEGIN(QUOTE); return '\"';\n\tYY_BREAK\ncase 94:\n*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\nyy_c_buf_p = yy_cp = yy_bp + 1;\nYY_DO_BEFORE_ACTION; /* set up yytext again */\nYY_RULE_SETUP\nBEGIN(NUM); return '{';\n\tYY_BREAK\ncase 95:\n*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\nyy_c_buf_p = yy_cp = yy_bp + 1;\nYY_DO_BEFORE_ACTION; /* set up yytext again */\nYY_RULE_SETUP\nreturn '$';\n\tYY_BREAK\ncase 96:\nYY_RULE_SETUP\n{\n\t\t\tbracelevel = 1;\n\t\t\tBEGIN(PERCENT_BRACE_ACTION);\n\n\t\t\tif ( in_rule )\n\t\t\t\t{\n\t\t\t\tdoing_rule_action = true;\n\t\t\t\tin_rule = false;\n\t\t\t\treturn '\\n';\n\t\t\t\t}\n\t\t\t}\n\tYY_BREAK\ncase 97:\nYY_RULE_SETUP\ncontinued_action = true; ++linenum; return '\\n';\n\tYY_BREAK\ncase 98:\nYY_RULE_SETUP\n{\n\t\t\tyyless( yyleng - 2 );\t/* put back '/', '*' */\n\t\t\tbracelevel = 0;\n\t\t\tcontinued_action = false;\n\t\t\tBEGIN(ACTION);\n\t\t\t}\n\tYY_BREAK\ncase 99:\nYY_RULE_SETUP\n/* allow indented rules */\n\tYY_BREAK\ncase 100:\nYY_RULE_SETUP\n{\n\t\t\t/* This rule is separate from the one below because\n\t\t\t * otherwise we get variable trailing context, so\n\t\t\t * we can't build the scanner using -{f,F}.\n\t\t\t */\n\t\t\tbracelevel = 0;\n\t\t\tcontinued_action = false;\n\t\t\tBEGIN(ACTION);\n\n\t\t\tif ( in_rule )\n\t\t\t\t{\n\t\t\t\tdoing_rule_action = true;\n\t\t\t\tin_rule = false;\n\t\t\t\treturn '\\n';\n\t\t\t\t}\n\t\t\t}\n\tYY_BREAK\ncase 101:\nYY_RULE_SETUP\n{\n\t\t\tbracelevel = 0;\n\t\t\tcontinued_action = false;\n\t\t\tBEGIN(ACTION);\n\t\t\tunput( '\\n' );\t/* so <ACTION> sees it */\n\n\t\t\tif ( in_rule )\n\t\t\t\t{\n\t\t\t\tdoing_rule_action = true;\n\t\t\t\tin_rule = false;\n\t\t\t\treturn '\\n';\n\t\t\t\t}\n\t\t\t}\n\tYY_BREAK\ncase 102:\ncase 103:\nYY_RULE_SETUP\nreturn EOF_OP;\n\tYY_BREAK\ncase 104:\nYY_RULE_SETUP\n{\n\t\t\tsectnum = 3;\n\t\t\tBEGIN(SECT3);\n\t\t\tyyterminate(); /* to stop the parser */\n\t\t\t}\n\tYY_BREAK\ncase 105:\nYY_RULE_SETUP\n{\n\t\t\tint cclval;\n\n\t\t\tstrcpy( nmstr, yytext );\n\n\t\t\t/* Check to see if we've already encountered this\n\t\t\t * ccl.\n\t\t\t */\n\t\t\tif ( (cclval = ccllookup( (Char *) nmstr )) != 0 )\n\t\t\t\t{\n\t\t\t\tif ( input() != ']' )\n\t\t\t\t\tsynerr( _( \"bad character class\" ) );\n\n\t\t\t\tyylval = cclval;\n\t\t\t\t++cclreuse;\n\t\t\t\treturn PREVCCL;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* We fudge a bit.  We know that this ccl will\n\t\t\t\t * soon be numbered as lastccl + 1 by cclinit.\n\t\t\t\t */\n\t\t\t\tcclinstal( (Char *) nmstr, lastccl + 1 );\n\n\t\t\t\t/* Push back everything but the leading bracket\n\t\t\t\t * so the ccl can be rescanned.\n\t\t\t\t */\n\t\t\t\tyyless( 1 );\n\n\t\t\t\tBEGIN(FIRSTCCL);\n\t\t\t\treturn '[';\n\t\t\t\t}\n\t\t\t}\n\tYY_BREAK\ncase 106:\nYY_RULE_SETUP\n{\n\t\t\tregister Char *nmdefptr;\n\t\t\tChar *ndlookup();\n\n\t\t\tstrcpy( nmstr, yytext + 1 );\n\t\t\tnmstr[yyleng - 2] = '\\0';  /* chop trailing brace */\n\n\t\t\tif ( (nmdefptr = ndlookup( nmstr )) == 0 )\n\t\t\t\tformat_synerr(\n\t\t\t\t\t_( \"undefined definition {%s}\" ),\n\t\t\t\t\t\tnmstr );\n\n\t\t\telse\n\t\t\t\t{ /* push back name surrounded by ()'s */\n\t\t\t\tint len = strlen( (char *) nmdefptr );\n\n\t\t\t\tif ( lex_compat || nmdefptr[0] == '^' ||\n\t\t\t\t     (len > 0 && nmdefptr[len - 1] == '$') )\n\t\t\t\t\t{ /* don't use ()'s after all */\n\t\t\t\t\tPUT_BACK_STRING((char *) nmdefptr, 0);\n\n\t\t\t\t\tif ( nmdefptr[0] == '^' )\n\t\t\t\t\t\tBEGIN(CARETISBOL);\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tunput(')');\n\t\t\t\t\tPUT_BACK_STRING((char *) nmdefptr, 0);\n\t\t\t\t\tunput('(');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tYY_BREAK\ncase 107:\nYY_RULE_SETUP\nreturn (unsigned char) yytext[0];\n\tYY_BREAK\ncase 108:\nYY_RULE_SETUP\nRETURNCHAR;\n\tYY_BREAK\n\n\ncase 109:\nYY_RULE_SETUP\nreturn (unsigned char) yytext[0];\n\tYY_BREAK\ncase 110:\nYY_RULE_SETUP\nBEGIN(SECT2); return '>';\n\tYY_BREAK\ncase 111:\n*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\nyy_c_buf_p = yy_cp = yy_bp + 1;\nYY_DO_BEFORE_ACTION; /* set up yytext again */\nYY_RULE_SETUP\nBEGIN(CARETISBOL); return '>';\n\tYY_BREAK\ncase 112:\nYY_RULE_SETUP\nRETURNNAME;\n\tYY_BREAK\ncase 113:\nYY_RULE_SETUP\n{\n\t\t\tformat_synerr( _( \"bad <start condition>: %s\" ),\n\t\t\t\tyytext );\n\t\t\t}\n\tYY_BREAK\n\ncase 114:\nYY_RULE_SETUP\nBEGIN(SECT2); return '^';\n\tYY_BREAK\n\ncase 115:\nYY_RULE_SETUP\nRETURNCHAR;\n\tYY_BREAK\ncase 116:\nYY_RULE_SETUP\nBEGIN(SECT2); return '\"';\n\tYY_BREAK\ncase 117:\nYY_RULE_SETUP\n{\n\t\t\tsynerr( _( \"missing quote\" ) );\n\t\t\tBEGIN(SECT2);\n\t\t\t++linenum;\n\t\t\treturn '\"';\n\t\t\t}\n\tYY_BREAK\n\n\ncase 118:\n*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\nyy_c_buf_p = yy_cp = yy_bp + 1;\nYY_DO_BEFORE_ACTION; /* set up yytext again */\nYY_RULE_SETUP\nBEGIN(CCL); return '^';\n\tYY_BREAK\ncase 119:\n*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\nyy_c_buf_p = yy_cp = yy_bp + 1;\nYY_DO_BEFORE_ACTION; /* set up yytext again */\nYY_RULE_SETUP\nreturn '^';\n\tYY_BREAK\ncase 120:\nYY_RULE_SETUP\nBEGIN(CCL); RETURNCHAR;\n\tYY_BREAK\n\n\ncase 121:\n*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\nyy_c_buf_p = yy_cp = yy_bp + 1;\nYY_DO_BEFORE_ACTION; /* set up yytext again */\nYY_RULE_SETUP\nreturn '-';\n\tYY_BREAK\ncase 122:\nYY_RULE_SETUP\nRETURNCHAR;\n\tYY_BREAK\ncase 123:\nYY_RULE_SETUP\nBEGIN(SECT2); return ']';\n\tYY_BREAK\ncase 124:\nYY_RULE_SETUP\n{\n\t\t\tsynerr( _( \"bad character class\" ) );\n\t\t\tBEGIN(SECT2);\n\t\t\treturn ']';\n\t\t\t}\n\tYY_BREAK\n\n\ncase 125:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_ALNUM;\n\tYY_BREAK\ncase 126:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_ALPHA;\n\tYY_BREAK\ncase 127:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_BLANK;\n\tYY_BREAK\ncase 128:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_CNTRL;\n\tYY_BREAK\ncase 129:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_DIGIT;\n\tYY_BREAK\ncase 130:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_GRAPH;\n\tYY_BREAK\ncase 131:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_LOWER;\n\tYY_BREAK\ncase 132:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_PRINT;\n\tYY_BREAK\ncase 133:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_PUNCT;\n\tYY_BREAK\ncase 134:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_SPACE;\n\tYY_BREAK\ncase 135:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_UPPER;\n\tYY_BREAK\ncase 136:\nYY_RULE_SETUP\nBEGIN(CCL); return CCE_XDIGIT;\n\tYY_BREAK\ncase 137:\nYY_RULE_SETUP\n{\n\t\t\tformat_synerr(\n\t\t\t\t_( \"bad character class expression: %s\" ),\n\t\t\t\t\tyytext );\n\t\t\tBEGIN(CCL); return CCE_ALNUM;\n\t\t\t}\n\tYY_BREAK\n\n\ncase 138:\nYY_RULE_SETUP\n{\n\t\t\tyylval = myctoi( yytext );\n\t\t\treturn NUMBER;\n\t\t\t}\n\tYY_BREAK\ncase 139:\nYY_RULE_SETUP\nreturn ',';\n\tYY_BREAK\ncase 140:\nYY_RULE_SETUP\nBEGIN(SECT2); return '}';\n\tYY_BREAK\ncase 141:\nYY_RULE_SETUP\n{\n\t\t\tsynerr( _( \"bad character inside {}'s\" ) );\n\t\t\tBEGIN(SECT2);\n\t\t\treturn '}';\n\t\t\t}\n\tYY_BREAK\ncase 142:\nYY_RULE_SETUP\n{\n\t\t\tsynerr( _( \"missing }\" ) );\n\t\t\tBEGIN(SECT2);\n\t\t\t++linenum;\n\t\t\treturn '}';\n\t\t\t}\n\tYY_BREAK\n\n\ncase 143:\nYY_RULE_SETUP\nbracelevel = 0;\n\tYY_BREAK\ncase 144:\nYY_RULE_SETUP\nACTION_ECHO; yy_push_state( COMMENT );\n\tYY_BREAK\n\ncase 145:\nYY_RULE_SETUP\n{\n\t\t\tACTION_ECHO;\n\t\t\tCHECK_REJECT(yytext);\n\t\t\t}\n\tYY_BREAK\ncase 146:\nYY_RULE_SETUP\n{\n\t\t\tACTION_ECHO;\n\t\t\tCHECK_YYMORE(yytext);\n\t\t\t}\n\tYY_BREAK\n\ncase 147:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 148:\nYY_RULE_SETUP\n{\n\t\t\t++linenum;\n\t\t\tACTION_ECHO;\n\t\t\tif ( bracelevel == 0 ||\n\t\t\t     (doing_codeblock && indented_code) )\n\t\t\t\t{\n\t\t\t\tif ( doing_rule_action )\n\t\t\t\t\tadd_action( \"\\tYY_BREAK\\n\" );\n\n\t\t\t\tdoing_rule_action = doing_codeblock = false;\n\t\t\t\tBEGIN(SECT2);\n\t\t\t\t}\n\t\t\t}\n\tYY_BREAK\n\n/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */\n\ncase 149:\nYY_RULE_SETUP\nACTION_ECHO; ++bracelevel;\n\tYY_BREAK\ncase 150:\nYY_RULE_SETUP\nACTION_ECHO; --bracelevel;\n\tYY_BREAK\ncase 151:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 152:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 153:\nYY_RULE_SETUP\nACTION_ECHO; /* character constant */\n\tYY_BREAK\ncase 154:\nYY_RULE_SETUP\nACTION_ECHO; BEGIN(ACTION_STRING);\n\tYY_BREAK\ncase 155:\nYY_RULE_SETUP\n{\n\t\t\t++linenum;\n\t\t\tACTION_ECHO;\n\t\t\tif ( bracelevel == 0 )\n\t\t\t\t{\n\t\t\t\tif ( doing_rule_action )\n\t\t\t\t\tadd_action( \"\\tYY_BREAK\\n\" );\n\n\t\t\t\tdoing_rule_action = false;\n\t\t\t\tBEGIN(SECT2);\n\t\t\t\t}\n\t\t\t}\n\tYY_BREAK\ncase 156:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\n\n\ncase 157:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 158:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\ncase 159:\nYY_RULE_SETUP\n++linenum; ACTION_ECHO;\n\tYY_BREAK\ncase 160:\nYY_RULE_SETUP\nACTION_ECHO; BEGIN(ACTION);\n\tYY_BREAK\ncase 161:\nYY_RULE_SETUP\nACTION_ECHO;\n\tYY_BREAK\n\ncase YY_STATE_EOF(COMMENT):\ncase YY_STATE_EOF(ACTION):\ncase YY_STATE_EOF(ACTION_STRING):\n{\n\t\t\tsynerr( _( \"EOF encountered inside an action\" ) );\n\t\t\tyyterminate();\n\t\t\t}\n\tYY_BREAK\ncase 162:\nYY_RULE_SETUP\n{\n\t\t\tyylval = myesc( (Char *) yytext );\n\n\t\t\tif ( YY_START == FIRSTCCL )\n\t\t\t\tBEGIN(CCL);\n\n\t\t\treturn CHAR;\n\t\t\t}\n\tYY_BREAK\n\ncase 163:\nYY_RULE_SETUP\nECHO;\n\tYY_BREAK\ncase YY_STATE_EOF(SECT3):\nsectnum = 0; yyterminate();\n\tYY_BREAK\n\ncase 164:\nYY_RULE_SETUP\nformat_synerr( _( \"bad character: %s\" ), yytext );\n\tYY_BREAK\ncase 165:\nYY_RULE_SETUP\nYY_FATAL_ERROR( \"flex scanner jammed\" );\n\tYY_BREAK\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(SECT2):\ncase YY_STATE_EOF(CODEBLOCK):\ncase YY_STATE_EOF(PICKUPDEF):\ncase YY_STATE_EOF(SC):\ncase YY_STATE_EOF(CARETISBOL):\ncase YY_STATE_EOF(NUM):\ncase YY_STATE_EOF(QUOTE):\ncase YY_STATE_EOF(FIRSTCCL):\ncase YY_STATE_EOF(CCL):\ncase YY_STATE_EOF(RECOVER):\ncase YY_STATE_EOF(PERCENT_BRACE_ACTION):\ncase YY_STATE_EOF(OPTION):\ncase YY_STATE_EOF(LINEDIR):\n\tyyterminate();\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between yy_current_buffer and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyy_n_chars = yy_current_buffer->yy_n_chars;\n\t\t\tyy_current_buffer->yy_input_file = yyin;\n\t\t\tyy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state );\n\n\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer() )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap() )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyy_c_buf_p = yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyy_c_buf_p =\n\t\t\t\t\tyytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyy_c_buf_p =\n\t\t\t\t&yy_current_buffer->yy_ch_buf[yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of yylex */\n\n\n/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n\nstatic int yy_get_next_buffer()\n\t{\n\tregister char *dest = yy_current_buffer->yy_ch_buf;\n\tregister char *source = yytext_ptr;\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( yy_current_buffer->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars = 0;\n\telse\n\t\t{\n\t\tint num_to_read =\n\t\t\tyy_current_buffer->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n#ifdef YY_USES_REJECT\n\t\t\tYY_FATAL_ERROR(\n\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n#else\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = yy_current_buffer;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyy_flex_realloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t b->yy_buf_size + 2 );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = yy_current_buffer->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n#endif\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),\n\t\t\tyy_n_chars, num_to_read );\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\n\t\t}\n\n\tif ( yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tyy_current_buffer->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tyy_n_chars += number_to_move;\n\tyy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tyy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyytext_ptr = &yy_current_buffer->yy_ch_buf[0];\n\n\treturn ret_val;\n\t}\n\n\n/* yy_get_previous_state - get the state just before the EOB char was reached */\n\nstatic yy_state_type yy_get_previous_state()\n\t{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n\n\tyy_current_state = yy_start;\n\tyy_current_state += YY_AT_BOL();\n\n\tfor ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyy_last_accepting_state = yy_current_state;\n\t\t\tyy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 769 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n\t}\n\n\n/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n\n#ifdef YY_USE_PROTOS\nstatic yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )\n#else\nstatic yy_state_type yy_try_NUL_trans( yy_current_state )\nyy_state_type yy_current_state;\n#endif\n\t{\n\tregister int yy_is_jam;\n\tregister char *yy_cp = yy_c_buf_p;\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\tyy_last_accepting_state = yy_current_state;\n\t\tyy_last_accepting_cpos = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 769 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 768);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n\t}\n\n\n#ifndef YY_NO_UNPUT\n#ifdef YY_USE_PROTOS\nstatic void yyunput( int c, register char *yy_bp )\n#else\nstatic void yyunput( c, yy_bp )\nint c;\nregister char *yy_bp;\n#endif\n\t{\n\tregister char *yy_cp = yy_c_buf_p;\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = yy_hold_char;\n\n\tif ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = yy_n_chars + 2;\n\t\tregister char *dest = &yy_current_buffer->yy_ch_buf[\n\t\t\t\t\tyy_current_buffer->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&yy_current_buffer->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > yy_current_buffer->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tyy_current_buffer->yy_n_chars =\n\t\t\tyy_n_chars = yy_current_buffer->yy_buf_size;\n\n\t\tif ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n\n\tyytext_ptr = yy_bp;\n\tyy_hold_char = *yy_cp;\n\tyy_c_buf_p = yy_cp;\n\t}\n#endif\t/* ifndef YY_NO_UNPUT */\n\n\n#ifdef __cplusplus\nstatic int yyinput()\n#else\nstatic int input()\n#endif\n\t{\n\tint c;\n\n\t*yy_c_buf_p = yy_hold_char;\n\n\tif ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = yy_c_buf_p - yytext_ptr;\n\t\t\t++yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer() )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart( yyin );\n\n\t\t\t\t\t/* fall through */\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap() )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyy_c_buf_p = yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) yy_c_buf_p;\t/* cast for 8-bit char's */\n\t*yy_c_buf_p = '\\0';\t/* preserve yytext */\n\tyy_hold_char = *++yy_c_buf_p;\n\n\tyy_current_buffer->yy_at_bol = (c == '\\n');\n\n\treturn c;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yyrestart( FILE *input_file )\n#else\nvoid yyrestart( input_file )\nFILE *input_file;\n#endif\n\t{\n\tif ( ! yy_current_buffer )\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );\n\n\tyy_init_buffer( yy_current_buffer, input_file );\n\tyy_load_buffer_state();\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n#else\nvoid yy_switch_to_buffer( new_buffer )\nYY_BUFFER_STATE new_buffer;\n#endif\n\t{\n\tif ( yy_current_buffer == new_buffer )\n\t\treturn;\n\n\tif ( yy_current_buffer )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yy_c_buf_p = yy_hold_char;\n\t\tyy_current_buffer->yy_buf_pos = yy_c_buf_p;\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\n\t\t}\n\n\tyy_current_buffer = new_buffer;\n\tyy_load_buffer_state();\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyy_did_buffer_switch_on_eof = 1;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_load_buffer_state( void )\n#else\nvoid yy_load_buffer_state()\n#endif\n\t{\n\tyy_n_chars = yy_current_buffer->yy_n_chars;\n\tyytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;\n\tyyin = yy_current_buffer->yy_input_file;\n\tyy_hold_char = *yy_c_buf_p;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_create_buffer( FILE *file, int size )\n#else\nYY_BUFFER_STATE yy_create_buffer( file, size )\nFILE *file;\nint size;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\n\tb = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer( b, file );\n\n\treturn b;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_delete_buffer( YY_BUFFER_STATE b )\n#else\nvoid yy_delete_buffer( b )\nYY_BUFFER_STATE b;\n#endif\n\t{\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == yy_current_buffer )\n\t\tyy_current_buffer = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyy_flex_free( (void *) b->yy_ch_buf );\n\n\tyy_flex_free( (void *) b );\n\t}\n\n\n#ifndef YY_ALWAYS_INTERACTIVE\n#ifndef YY_NEVER_INTERACTIVE\nextern int isatty YY_PROTO(( int ));\n#endif\n#endif\n\n#ifdef YY_USE_PROTOS\nvoid yy_init_buffer( YY_BUFFER_STATE b, FILE *file )\n#else\nvoid yy_init_buffer( b, file )\nYY_BUFFER_STATE b;\nFILE *file;\n#endif\n\n\n\t{\n\tyy_flush_buffer( b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n#if YY_ALWAYS_INTERACTIVE\n\tb->yy_is_interactive = 1;\n#else\n#if YY_NEVER_INTERACTIVE\n\tb->yy_is_interactive = 0;\n#else\n\tb->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n#endif\n#endif\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_flush_buffer( YY_BUFFER_STATE b )\n#else\nvoid yy_flush_buffer( b )\nYY_BUFFER_STATE b;\n#endif\n\n\t{\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == yy_current_buffer )\n\t\tyy_load_buffer_state();\n\t}\n\n\n#ifndef YY_NO_SCAN_BUFFER\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )\n#else\nYY_BUFFER_STATE yy_scan_buffer( base, size )\nchar *base;\nyy_size_t size;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b );\n\n\treturn b;\n\t}\n#endif\n\n\n#ifndef YY_NO_SCAN_STRING\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )\n#else\nYY_BUFFER_STATE yy_scan_string( yy_str )\nyyconst char *yy_str;\n#endif\n\t{\n\tint len;\n\tfor ( len = 0; yy_str[len]; ++len )\n\t\t;\n\n\treturn yy_scan_bytes( yy_str, len );\n\t}\n#endif\n\n\n#ifndef YY_NO_SCAN_BYTES\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )\n#else\nYY_BUFFER_STATE yy_scan_bytes( bytes, len )\nyyconst char *bytes;\nint len;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n\n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = len + 2;\n\tbuf = (char *) yy_flex_alloc( n );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < len; ++i )\n\t\tbuf[i] = bytes[i];\n\n\tbuf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n\t}\n#endif\n\n\n#ifndef YY_NO_PUSH_STATE\n#ifdef YY_USE_PROTOS\nstatic void yy_push_state( int new_state )\n#else\nstatic void yy_push_state( new_state )\nint new_state;\n#endif\n\t{\n\tif ( yy_start_stack_ptr >= yy_start_stack_depth )\n\t\t{\n\t\tyy_size_t new_size;\n\n\t\tyy_start_stack_depth += YY_START_STACK_INCR;\n\t\tnew_size = yy_start_stack_depth * sizeof( int );\n\n\t\tif ( ! yy_start_stack )\n\t\t\tyy_start_stack = (int *) yy_flex_alloc( new_size );\n\n\t\telse\n\t\t\tyy_start_stack = (int *) yy_flex_realloc(\n\t\t\t\t\t(void *) yy_start_stack, new_size );\n\n\t\tif ( ! yy_start_stack )\n\t\t\tYY_FATAL_ERROR(\n\t\t\t\"out of memory expanding start-condition stack\" );\n\t\t}\n\n\tyy_start_stack[yy_start_stack_ptr++] = YY_START;\n\n\tBEGIN(new_state);\n\t}\n#endif\n\n\n#ifndef YY_NO_POP_STATE\nstatic void yy_pop_state()\n\t{\n\tif ( --yy_start_stack_ptr < 0 )\n\t\tYY_FATAL_ERROR( \"start-condition stack underflow\" );\n\n\tBEGIN(yy_start_stack[yy_start_stack_ptr]);\n\t}\n#endif\n\n\n#ifndef YY_NO_TOP_STATE\nstatic int yy_top_state()\n\t{\n\treturn yy_start_stack[yy_start_stack_ptr - 1];\n\t}\n#endif\n\n#ifndef YY_EXIT_FAILURE\n#define YY_EXIT_FAILURE 2\n#endif\n\n#ifdef YY_USE_PROTOS\nstatic void yy_fatal_error( yyconst char msg[] )\n#else\nstatic void yy_fatal_error( msg )\nchar msg[];\n#endif\n\t{\n\t(void) fprintf( err, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n\t}\n\n\n\n/* Redefine yyless() so it works in section 3 code. */\n\n#undef yyless\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n\t\tyytext[yyleng] = yy_hold_char; \\\n\t\tyy_c_buf_p = yytext + n; \\\n\t\tyy_hold_char = *yy_c_buf_p; \\\n\t\t*yy_c_buf_p = '\\0'; \\\n\t\tyyleng = n; \\\n\t\t} \\\n\twhile ( 0 )\n\n\n/* Internal utility routines. */\n\n#ifndef yytext_ptr\n#ifdef YY_USE_PROTOS\nstatic void yy_flex_strncpy( char *s1, yyconst char *s2, int n )\n#else\nstatic void yy_flex_strncpy( s1, s2, n )\nchar *s1;\nyyconst char *s2;\nint n;\n#endif\n\t{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n\t}\n#endif\n\n#ifdef YY_NEED_STRLEN\n#ifdef YY_USE_PROTOS\nstatic int yy_flex_strlen( yyconst char *s )\n#else\nstatic int yy_flex_strlen( s )\nyyconst char *s;\n#endif\n\t{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n\t}\n#endif\n\n\n#ifdef YY_USE_PROTOS\nstatic void *yy_flex_alloc( yy_size_t size )\n#else\nstatic void *yy_flex_alloc( size )\nyy_size_t size;\n#endif\n\t{\n\treturn (void *) malloc( size );\n\t}\n\n#ifdef YY_USE_PROTOS\nstatic void *yy_flex_realloc( void *ptr, yy_size_t size )\n#else\nstatic void *yy_flex_realloc( ptr, size )\nvoid *ptr;\nyy_size_t size;\n#endif\n\t{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n\t}\n\n#ifdef YY_USE_PROTOS\nstatic void yy_flex_free( void *ptr )\n#else\nstatic void yy_flex_free( ptr )\nvoid *ptr;\n#endif\n\t{\n\tfree( ptr );\n\t}\n\n#if YY_MAIN\nint main()\n\t{\n\tyylex();\n\treturn 0;\n\t}\n#endif\n\n\n\nint yywrap()\n\t{\n\tif ( --num_input_files > 0 )\n\t\t{\n\t\tset_input_file( *++input_files );\n\t\treturn 0;\n\t\t}\n\n\telse\n\t\treturn 1;\n\t}\n\n\n/* set_input_file - open the given file (if NULL, stdin) for scanning */\n\nvoid set_input_file( file )\nchar *file;\n\t{\n\tif ( file && strcmp( file, \"-\" ) )\n\t\t{\n\t\tinfilename = copy_string( file );\n\t\tyyin = fopen( infilename, \"r\" );\n\n\t\tif ( yyin == NULL )\n\t\t\tlerrsf( _( \"can't open %s\" ), file );\n\t\t}\n\n\telse\n\t\t{\n\t\tyyin = stdin;\n\t\tinfilename = copy_string( \"<stdin>\" );\n\t\t}\n\n\tlinenum = 1;\n\t}\n\n\n/* Wrapper routines for accessing the scanner's malloc routines. */\n\nvoid *flex_alloc( size )\nsize_t size;\n\t{\n\treturn (void *) malloc( size );\n\t}\n\nvoid *flex_realloc( ptr, size )\nvoid *ptr;\nsize_t size;\n\t{\n\treturn (void *) realloc( ptr, size );\n\t}\n\nvoid flex_free( ptr )\nvoid *ptr;\n\t{\n\tif ( ptr )\n\t\tfree( ptr );\n\t}\n"}}, "framework": {"brandingInformation": {"homepageUrl": "https://github.com/mull-project/mull"}, "name": "Mull", "version": "0.17.1, LLVM 12.0.0"}, "mutationScore": 100, "schemaVersion": "1.7", "thresholds": {"high": 80, "low": 60}}