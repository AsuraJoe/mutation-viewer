{"config": {"Build Date": "17 Mar 2022", "Commit": "ac98382", "LLVM Version": "12.0.0", "Mull Version": "0.17.1", "URL": "https://github.com/mull-project/mull"}, "files": {"/home/tpugh_/sunday/print_tokens/printtokens.c": {"language": "cpp", "mutants": [{"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 30}, "start": {"column": 14, "line": 30}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 30}, "start": {"column": 14, "line": 30}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 66}, "start": {"column": 19, "line": 66}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Survived"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 53, "line": 68}, "start": {"column": 51, "line": 68}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 55, "line": 90}, "start": {"column": 53, "line": 90}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 76, "line": 92}, "start": {"column": 74, "line": 92}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 59, "line": 96}, "start": {"column": 57, "line": 96}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 52, "line": 113}, "start": {"column": 51, "line": 113}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 57, "line": 113}, "start": {"column": 55, "line": 113}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 133}, "start": {"column": 33, "line": 133}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 191}, "start": {"column": 17, "line": 191}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 191}, "start": {"column": 17, "line": 191}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 29, "line": 193}, "start": {"column": 27, "line": 193}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 200}, "start": {"column": 16, "line": 200}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 203}, "start": {"column": 23, "line": 203}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 206}, "start": {"column": 23, "line": 206}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 52, "line": 223}, "start": {"column": 50, "line": 223}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 33, "line": 272}, "start": {"column": 31, "line": 272}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 40, "line": 275}, "start": {"column": 38, "line": 275}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 18, "line": 277}, "start": {"column": 16, "line": 277}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 18, "line": 277}, "start": {"column": 16, "line": 277}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 24, "line": 278}, "start": {"column": 22, "line": 278}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 316}, "start": {"column": 19, "line": 316}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 41, "line": 413}, "start": {"column": 39, "line": 413}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 8, "line": 416}, "start": {"column": 6, "line": 416}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 40, "line": 436}, "start": {"column": 39, "line": 436}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 456}, "start": {"column": 14, "line": 456}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 456}, "start": {"column": 14, "line": 456}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 20, "line": 458}, "start": {"column": 19, "line": 458}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 25, "line": 458}, "start": {"column": 23, "line": 458}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 25, "line": 458}, "start": {"column": 23, "line": 458}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 30, "line": 460}, "start": {"column": 29, "line": 460}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 460}, "start": {"column": 34, "line": 460}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 38, "line": 461}, "start": {"column": 37, "line": 461}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 482}, "start": {"column": 19, "line": 482}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 33, "line": 551}, "start": {"column": 32, "line": 551}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 33, "line": 551}, "start": {"column": 32, "line": 551}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 25, "line": 554}, "start": {"column": 24, "line": 554}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 25, "line": 554}, "start": {"column": 24, "line": 554}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 40, "line": 554}, "start": {"column": 35, "line": 554}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 28, "line": 557}, "start": {"column": 26, "line": 557}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 28, "line": 557}, "start": {"column": 26, "line": 557}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 45, "line": 557}, "start": {"column": 38, "line": 557}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 51, "line": 557}, "start": {"column": 46, "line": 557}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}], "source": "# include <ctype.h>\r\n\r\n# define START  5\r\n# define TRUE  1\r\n# define FALSE 0\r\n\r\ntypedef int BOOLEAN;\r\ntypedef char *string;\r\n\r\n# include <stdio.h>\r\n# include \"tokens.h\"\r\n\r\nstatic token numeric_case();\r\nstatic token error_or_eof_case();\r\nstatic int check_delimiter();\r\nstatic int keyword(int state);\r\nstatic int special(int state);\r\nstatic skip(character_stream stream_ptr);\r\nstatic int constant(int state,char token_str[],int token_ind);\r\nstatic int next_state();\r\nstatic get_actual_token(char token_str[],int token_ind);\r\n\r\nmain(argc,argv)\r\nint argc;\r\nchar *argv[];\r\n{\r\n      token token_ptr;\r\n      token_stream stream_ptr;\r\n\r\n      if(argc>2)\r\n      {\r\n          fprintf(stdout, \"The format is print_tokens filename(optional)\\n\");\r\n          exit(1);\r\n      }\r\n      stream_ptr=open_token_stream(argv[1]);\r\n\r\n      while(!is_eof_token((token_ptr=get_token(stream_ptr))))\r\n                print_token(token_ptr);\r\n      print_token(token_ptr);\r\n  exit(0);\r\n}\r\n\r\n\r\n\r\n/* *********************************************************************\r\n       Function name : open_character_stream\r\n       Input         : filename \r\n       Output        : charactre stream.\r\n       Exceptions    : If file name doesn't exists it will\r\n                       exit from the program.\r\n       Description   : The function first allocates the memory for \r\n                       the structure and initilizes it. The constant\r\n                       START gives the first character available in\r\n                       the stream. It ckecks whether the filename is\r\n                       empty string. If it is it assigns file pointer\r\n                       to stdin else it opens the respective file as input.                   * ******************************************************************* */\r\n\r\ncharacter_stream open_character_stream(FILENAME)\r\nstring FILENAME;\r\n{\r\n      character_stream stream_ptr;\r\n\r\n      stream_ptr=(character_stream)malloc(sizeof(struct stream_type));\r\n      stream_ptr->stream_ind=START;\r\n      stream_ptr->stream[START]='\\0';\r\n      if(FILENAME == NULL)\r\n          stream_ptr->fp=stdin;\r\n      else if((stream_ptr->fp=fopen(FILENAME,\"r\"))==NULL)\r\n           {\r\n               fprintf(stdout, \"The file %s doesn't exists\\n\",FILENAME);\r\n               exit(0);\r\n           }\r\n      return(stream_ptr);\r\n}\r\n\r\n/* *********************************************************************\r\n   Function name : get_char\r\n   Input         : charcter_stream.\r\n   Output        : character.\r\n   Exceptions    : None.\r\n   Description   : This function takes character_stream type variable \r\n                   as input and returns one character. If the stream is\r\n                   empty then it reads the next line from the file and\r\n                   returns the character.       \r\n * ****************************************************************** */\r\n\r\nCHARACTER get_char(stream_ptr)\r\ncharacter_stream stream_ptr;\r\n{\r\n      if(stream_ptr->stream[stream_ptr->stream_ind] == '\\0')\r\n      {\r\n              if(fgets(stream_ptr->stream+START,80/START,stream_ptr->fp) == NULL)/* Fix bug: add -START - hf*/\r\n                    stream_ptr->stream[START]=EOF;\r\n              stream_ptr->stream_ind=START;\r\n      }\r\n      return(stream_ptr->stream[(stream_ptr->stream_ind)++]);\r\n}\r\n\r\n/* *******************************************************************\r\n   Function name : is_end_of_character_stream.\r\n   Input         : character_stream.\r\n   Output        : Boolean value.\r\n   Description   : This function checks whether it is end of character\r\n                   stream or not. It returns BOOLEANvariable which is \r\n                   true or false. The function checks whether the last \r\n                   read character is end file character or not and\r\n                   returns the value according to it.\r\n * ****************************************************************** */\r\n\r\nBOOLEAN is_end_of_character_stream(stream_ptr)\r\ncharacter_stream stream_ptr;\r\n{\r\n      if(stream_ptr->stream[stream_ptr->stream_ind-1] == EOF)\r\n            return(TRUE);\r\n      else\r\n            return(FALSE);\r\n}\r\n\r\n/* *********************************************************************\r\n   Function name : unget_char\r\n   Input         : character,character_stream.\r\n   Output        : void.\r\n   Description   : This function adds the character ch to the stream. \r\n                   This is accomplished by decrementing the stream_ind\r\n                   and storing it in the stream. If it is not possible\r\n                   to unget the character then it returns\r\n * ******************************************************************* */\r\n\r\nunget_char(ch,stream_ptr)\r\nCHARACTER ch;\r\ncharacter_stream stream_ptr;\r\n{\r\n      if(stream_ptr->stream_ind == 0)\r\n          return 0;\r\n      else\r\n          stream_ptr->stream[--(stream_ptr->stream_ind)]=ch;\r\n      return 0;\r\n}\r\n\r\n\r\n/* *******************************************************************\r\n   Function name : open_token_stream\r\n   Input         : filename\r\n   Output        : token_stream\r\n   Exceptions    : Exits if the file specified by filename not found.\r\n   Description   : This function takes filename as input and opens the\r\n                   token_stream which is nothing but the character stream.\r\n                   This function allocates the memory for token_stream \r\n                   and calls open_character_stream to open the file as\r\n                   input. This function returns the token_stream.\r\n * ****************************************************************** */\r\n\r\ntoken_stream open_token_stream(FILENAME)\r\nstring FILENAME;\r\n{\r\n    token_stream token_ptr;\r\n  \r\n    token_ptr=(token_stream)malloc(sizeof(struct token_stream_type));\r\n    token_ptr->ch_stream=open_character_stream(FILENAME);/* Get character\r\n                                                             stream  */\r\n    return(token_ptr);\r\n}\r\n\r\n/* ********************************************************************\r\n   Function name : get_token\r\n   Input         : token_stream\r\n   Output        : token\r\n   Exceptions    : none.\r\n   Description   : This function returns the next token from the\r\n                   token_stream.The type of token is integer and specifies \r\n                   only the type of the token. DFA is used for finding the\r\n                   next token. cu_state is initialized to zero and charcter\r\n                   are read until the the is the final state and it\r\n                   returns the token type.\r\n* ******************************************************************* */\r\n\r\ntoken get_token(tstream_ptr)\r\ntoken_stream tstream_ptr;\r\n{\r\n      char token_str[80]; /* This buffer stores the current token */\r\n      int token_ind;      /* Index to the token_str  */\r\n      token token_ptr;\r\n      CHARACTER ch;\r\n      int cu_state,next_st,token_found;\r\n  \r\n      token_ptr=(token)(malloc(sizeof(struct token_type)));\r\n      ch=get_char(tstream_ptr->ch_stream);\r\n      cu_state=token_ind=token_found=0;\r\n      while(!token_found)\r\n      {\r\n\t  if(token_ind < 80) /* ADDED ERROR CHECK - hf */\r\n\t  {\r\n\t      token_str[token_ind++]=ch;\r\n\t      next_st=next_state(cu_state,ch);\r\n\t  }\r\n\t  else\r\n\t  {\r\n\t      next_st = -1; /* - hf */\r\n\t  }\r\n\t  if (next_st == -1) { /* ERROR or EOF case */\r\n\t      return(error_or_eof_case(tstream_ptr, \r\n\t\t\t\t       token_ptr,cu_state,token_str,token_ind,ch));\r\n\t  } else if (next_st == -2) {/* This is numeric case. */\r\n\t      return(numeric_case(tstream_ptr,token_ptr,ch,\r\n\t\t\t\t  token_str,token_ind));\r\n\t  } else if (next_st == -3) {/* This is the IDENTIFIER case */\r\n\t      token_ptr->token_id=IDENTIFIER;\r\n\t      unget_char(ch,tstream_ptr->ch_stream);\r\n\t      token_ind--;\r\n\t      get_actual_token(token_str,token_ind);\r\n\t      strcpy(token_ptr->token_string,token_str);\r\n\t      return(token_ptr);\r\n\t  } \r\n\t    \r\n\t  switch(next_st) \r\n            { \r\n                 default : break;\r\n                 case 6  : /* These are all KEYWORD cases. */\r\n                 case 9  :\r\n                 case 11 :\r\n                 case 13 :\r\n                 case 16 : ch=get_char(tstream_ptr->ch_stream);\r\n                           if(check_delimiter(ch)==TRUE)\r\n                           {\r\n                                 token_ptr->token_id=keyword(next_st);\r\n                                 unget_char(ch,tstream_ptr->ch_stream);\r\n                                 token_ptr->token_string[0]='\\0';\r\n                                 return(token_ptr);\r\n                           }\r\n                           unget_char(ch,tstream_ptr->ch_stream);\r\n                           break;\r\n                 case 19 : /* These are all special SPECIAL character */\r\n                 case 20 : /* cases */\r\n                 case 21 :\r\n                 case 22 :\r\n                 case 23 :\r\n                 case 24 :\r\n                 case 25 :\r\n                 case 32 : token_ptr->token_id=special(next_st);\r\n                           token_ptr->token_string[0]='\\0';\r\n                           return(token_ptr);\r\n                 case 27 : /* These are constant cases */\r\n                 case 29 : token_ptr->token_id=constant(next_st,token_str,token_ind);\r\n                           get_actual_token(token_str,token_ind);\r\n                           strcpy(token_ptr->token_string,token_str);\r\n                           return(token_ptr);\r\n                 case 30 :  /* This is COMMENT case */\r\n                           skip(tstream_ptr->ch_stream);\r\n                           token_ind=next_st=0;\r\n                           break;\r\n            }\r\n            cu_state=next_st;\r\n            ch=get_char(tstream_ptr->ch_stream);\r\n      }\r\n}\r\n\r\n/* ******************************************************************\r\n   Function name : numeric_case\r\n   Input         : tstream_ptr,token_ptr,ch,token_str,token_ind\r\n   Output        : token_ptr;\r\n   Exceptions    : none \r\n   Description   : It checks for the delimiter, if it is then it\r\n                   forms numeric token else forms error token.\r\n * ****************************************************************** */\r\n\r\nstatic token numeric_case(tstream_ptr,token_ptr,ch,token_str,token_ind)\r\ntoken_stream tstream_ptr;\r\ntoken token_ptr;\r\nchar ch,token_str[];\r\nint token_ind;\r\n{\r\n        if(check_delimiter(ch)!=TRUE)\r\n        {   /* Error case */\r\n            token_ptr->token_id=ERROR;\r\n            while(check_delimiter(ch)==FALSE)\r\n\t    {\r\n\t\tif(token_ind >= 80) break; /* Added protection - hf */\r\n\t\ttoken_str[token_ind++]=ch=get_char(tstream_ptr->ch_stream);\r\n\t    }\r\n            unget_char(ch,tstream_ptr->ch_stream);\r\n            token_ind--;\r\n            get_actual_token(token_str,token_ind);\r\n            strcpy(token_ptr->token_string,token_str);\r\n            return(token_ptr);\r\n        }\r\n        token_ptr->token_id=NUMERIC; /* Numeric case */\r\n        unget_char(ch,tstream_ptr->ch_stream);\r\n        token_ind--;\r\n        get_actual_token(token_str,token_ind);\r\n        strcpy(token_ptr->token_string,token_str);\r\n        return(token_ptr);\r\n}\r\n\r\n/* *****************************************************************\r\n   Function name : error_or_eof_case \r\n   Input         : tstream_ptr,token_ptr,cu_state,token_str,token_ind,ch\r\n   Output        : token_ptr \r\n   Exceptions    : none \r\n   Description   : This function checks whether it is EOF or not.\r\n                   If it is it returns EOF token else returns ERROR \r\n                   token.\r\n * *****************************************************************/\r\n\r\nstatic token error_or_eof_case(tstream_ptr,token_ptr,cu_state,token_str,token_ind,ch)\r\ntoken_stream tstream_ptr;\r\ntoken token_ptr;\r\nint cu_state,token_ind;\r\nchar token_str[],ch;\r\n{\r\n      if(is_end_of_character_stream(tstream_ptr->ch_stream)) \r\n      {\r\n            token_ptr->token_id = EOTSTREAM;\r\n            token_ptr->token_string[0]='\\0';\r\n            return(token_ptr);\r\n      }\r\n      if(cu_state !=0)\r\n      {\r\n            unget_char(ch,tstream_ptr->ch_stream);\r\n            token_ind--;\r\n      }\r\n      token_ptr->token_id=ERROR;\r\n      get_actual_token(token_str,token_ind);\r\n      strcpy(token_ptr->token_string,token_str);\r\n      return(token_ptr);                \r\n}\r\n\r\n/* *********************************************************************\r\n   Function name : check_delimiter\r\n   Input         : character\r\n   Output        : boolean\r\n   Exceptions    : none.\r\n   Description   : This function checks for the delimiter. If ch is not\r\n                   alphabet and non numeric then it returns TRUE else \r\n                   it returns FALSE. \r\n * ******************************************************************* */\r\n\r\nstatic int check_delimiter(ch)\r\nchar ch;\r\n{\r\n      if(!isalpha(ch) && !isdigit(ch)) /* Check for digit and alpha */\r\n          return(TRUE);\r\n      return(FALSE);\r\n}\r\n\r\n/* ********************************************************************\r\n   Function name : keyword\r\n   Input         : state of the DFA\r\n   Output        : Keyword.\r\n   Exceptions    : If the state doesn't represent a keyword it exits.\r\n   Description   : According to the final state specified by state the\r\n                   respective token_id is returned.\r\n * ***************************************************************** */\r\n\r\nstatic int keyword(state)\r\nint state;\r\n{\r\n      switch(state)\r\n      {   /* Return the respective macro for the Keyword. */\r\n          case 6 : return(LAMBDA);\r\n          case 9 : return(AND);\r\n          case 11: return(OR);\r\n          case 13: return(IF);\r\n          case 16: return(XOR);\r\n          default: fprintf(stdout, \"error\\n\");break;\r\n      }\r\n      exit(0);\r\n}\r\n\r\n/* ********************************************************************\r\n   Function name : special\r\n   Input         : The state of the DFA.\r\n   Output        : special symbol.\r\n   Exceptions    : if the state doesn't belong to a special character\r\n                   it exits.\r\n   Description   : This function returns the token_id according to the\r\n                   final state given by state.\r\n * ****************************************************************** */\r\n\r\nstatic int special(state)\r\nint state;\r\n{\r\n     switch(state)\r\n     {   /* return the respective macro for the special character. */\r\n         case 19: return(LPAREN);\r\n         case 20: return(RPAREN);\r\n         case 21: return(LSQUARE);\r\n         case 22: return(RSQUARE);\r\n         case 23: return(QUOTE);\r\n         case 24: return(BQUOTE);\r\n         case 25: return(COMMA);\r\n         case 32: return(EQUALGREATER);\r\n         default: fprintf(stdout, \"error\\n\");break;\r\n     }\r\n     exit(0);\r\n}\r\n\r\n/* **********************************************************************\r\n   Function name : skip\r\n   Input         : character_stream\r\n   Output        : void.\r\n   Exceptions    : none.\r\n   Description   : This function skips the comment part of the program.\r\n                   It takes charcter_stream as input and reads character\r\n                   until it finds new line character or\r\n                   end_of_character_stream.                   \r\n * ******************************************************************* */\r\n\r\nstatic skip(stream_ptr)\r\ncharacter_stream stream_ptr;\r\n{\r\n        char c;\r\n  \r\n        while((c=get_char(stream_ptr))!='\\n' && \r\n               !is_end_of_character_stream(stream_ptr))\r\n             ; /* Skip the characters until EOF or EOL found. */\r\n\tif(c==EOF) unget_char(c, stream_ptr); /* Put back to leave gracefully - hf */\r\n        return 0;\r\n}\r\n\r\n/* *********************************************************************\r\n   Function name : constant\r\n   Input         : state of DFA, Token string, Token id.\r\n   Output        : constant token.\r\n   Exceptions    : none.\r\n   Description   : This function returns the token_id for the constatnts\r\n                   speccified by  the final state. \r\n * ****************************************************************** */\r\n\r\nstatic int constant(state,token_str,token_ind)\r\nint state,token_ind;\r\nchar token_str[];\r\n{\r\n     switch(state)\r\n     {   /* Return the respective CONSTANT macro. */\r\n         case 27 : return(STRING_CONSTANT);\r\n         case 29 : token_str[token_ind-2]=' '; return(CHARACTER_CONSTANT);\r\n         default : break;\r\n     }\r\n}\r\n\r\n\r\n/* *******************************************************************\r\n   Function name : next_state\r\n   Input         : current state, character\r\n   Output        : next state of the DFA\r\n   Exceptions    : none.\r\n   Description   : This function returns the next state in the transition\r\n                   diagram. The next state is determined by the current\r\n                   state state and the inpu character ch.\r\n * ****************************************************************** */\r\n              \r\nstatic int next_state(state,ch)\r\nint state;\r\nchar ch;\r\n{\r\n    if(state < 0)\r\n      return(state);\r\n    if(base[state]+ch >= 0)\r\n    {\r\n        if(check[base[state]+ch] == state) /* Check for the right state */\r\n             return(next[base[state]+ch]);\r\n        else\r\n              return(next_state(default1[state],ch));\r\n    }\r\n    else\r\n        return(next_state(default1[state],ch));\r\n}\r\n\r\n/* *********************************************************************\r\n   Function name : is_eof_token\r\n   Input         : token\r\n   Output        : Boolean\r\n   Exceptions    : none.\r\n   Description   : This function checks whether the token t is eof_token \r\n                   or not. If the integer value stored in the t is\r\n                   EOTSTREAM then it is eof_token.\r\n * ***************************************************************** */\r\n\r\nBOOLEAN is_eof_token(t)\r\ntoken t;\r\n{\r\n    if(t->token_id==EOTSTREAM)\r\n        return(TRUE);\r\n    return(FALSE);\r\n}\r\n\r\n/* ********************************************************************\r\n   Function name : print_token\r\n   Input         : token\r\n   Output        : Boolean\r\n   Exceptions    : none.\r\n   Description   : This function  prints the token. The token_id gives \r\n                   the type of token not the token itself. So, in the\r\n                   case of identifier,numeric,  string,character it is\r\n                   required to print the actual token  from token_str. \r\n                   So, precaution must be taken when printing the token.\r\n                   This function is able to print the current token only\r\n                   and it is the limitation of the program.\r\n * ******************************************************************** */\r\n\r\nBOOLEAN print_token(token_ptr)\r\ntoken token_ptr;\r\n{\r\n     switch(token_ptr->token_id)\r\n     {    /* Print the respective tokens. */\r\n          case ERROR : fprintf(stdout, \"error,\\t\\\"\");fprintf(stdout, \"%s\",token_ptr->token_string);\r\n                       fprintf(stdout, \"\\\".\\n\");return(TRUE);\r\n          case EOTSTREAM : fprintf(stdout, \"eof.\\n\");return(TRUE);\r\n          case 6 : fprintf(stdout, \"keyword,\\t\\\"lambda\\\".\\n\");return(TRUE);\r\n          case 9 : fprintf(stdout, \"keyword,\\t\\\"and\\\".\\n\");return(TRUE);\r\n          case 11: fprintf(stdout, \"keyword,\\t\\\"or\\\".\\n\");return(TRUE);\r\n          case 13: fprintf(stdout, \"keyword,\\t\\\"if\\\".\\n\");return(TRUE);\r\n          case 16: fprintf(stdout, \"keyword,\\t\\\"xor\\\".\\n\");return(TRUE);\r\n          case 17: fprintf(stdout, \"identifier,\\t\\\"\");fprintf(stdout, \"%s\",token_ptr->token_string);\r\n                   fprintf(stdout, \"\\\".\\n\");return(TRUE);\r\n          case 18: fprintf(stdout, \"numeric,\\t\");fprintf(stdout, \"%s\",token_ptr->token_string);\r\n                   fprintf(stdout, \".\\n\");return(TRUE);\r\n          case 19: fprintf(stdout, \"lparen.\\n\");return(TRUE);\r\n          case 20: fprintf(stdout, \"rparen.\\n\");return(TRUE);\r\n          case 21: fprintf(stdout, \"lsquare.\\n\");return(TRUE);\r\n          case 22: fprintf(stdout, \"rsquare.\\n\");return(TRUE);\r\n          case 23: fprintf(stdout, \"quote.\\n\");return(TRUE);\r\n          case 24: fprintf(stdout, \"bquote.\\n\");return(TRUE);\r\n          case 25: fprintf(stdout, \"comma.\\n\");return(TRUE);\r\n          case 27: fprintf(stdout, \"string,\\t\");fprintf(stdout, \"%s\",token_ptr->token_string);\r\n                   fprintf(stdout, \".\\n\");return(TRUE);\r\n          case 29: fprintf(stdout, \"character,\\t\\\"\");fprintf(stdout, \"%s\",token_ptr->token_string);\r\n                   fprintf(stdout, \"\\\".\\n\");return(TRUE);\r\n          case 32: fprintf(stdout, \"keyword,\\t\\\"=>\\\".\\n\");return(TRUE);\r\n          default: break;\r\n      }\r\n      return(FALSE);\r\n}\r\n\r\n/* **********************************************************************\r\n   Function name : get_actual_token\r\n   Input         : token string and token id.\r\n   Output        : void.\r\n   Exceptions    : none.\r\n   Description   : This function prints the actual token in the case of\r\n                   identifier,numeric,string and character. It removes\r\n                   the leading and trailing  spaces and prints the token.\r\n * ****************************************************************** */\r\n\r\nstatic get_actual_token(token_str,token_ind)\r\nint token_ind;\r\nchar token_str[];\r\n{\r\n          int ind,start;\r\n\r\n          for(ind=token_ind;ind>0 && isspace(token_str[ind-1]);--ind); \r\n                        /* Delete the trailing white spaces & protect - hf */\r\n           token_str[ind]='\\0';token_ind=ind;\r\n          for(ind=0;ind<token_ind;++ind)\r\n                if(!isspace(token_str[ind]))\r\n                      break;\r\n          for(start=0;ind<=token_ind;++start,++ind) /* Delete the leading\r\n                                                       white spaces. */\r\n                token_str[start]=token_str[ind];\r\n          return 0;\r\n}\r\n"}}, "framework": {"brandingInformation": {"homepageUrl": "https://github.com/mull-project/mull"}, "name": "Mull", "version": "0.17.1, LLVM 12.0.0"}, "mutationScore": 97, "schemaVersion": "1.7", "thresholds": {"high": 80, "low": 60}}